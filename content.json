{"meta":{"title":"独角兽之路","subtitle":"到了汉堡，我们每天必须演足8小时","description":"到了含堡，我们每天必须演足8小时","author":"Harlan Zhush","url":"https://3431339973.github.io"},"pages":[{"title":"关于我","date":"2017-03-15T14:49:53.000Z","updated":"2017-03-19T08:22:29.962Z","comments":true,"path":"about/index.html","permalink":"https://3431339973.github.io/about/index.html","excerpt":"","text":""},{"title":"读书","date":"2017-03-15T14:49:53.000Z","updated":"2017-10-21T12:59:23.390Z","comments":true,"path":"book/index.html","permalink":"https://3431339973.github.io/book/index.html","excerpt":"","text":"作者: [美] Marty Cagan豆瓣评分 8.5 链接我的评价虽然是11年的书，不过放到现在，书里面很多情节依然像是发生在周边，有些事情道理都懂，但执行起来却困难重重，推荐给每位软件行业的人，无论你是程序员还是产品经理，或是项目管理者，粗略看一遍，肯定会带着笔纸回来看第二遍 作者: 张大伟豆瓣评分 9.3 链接我的评价看起来更像是卷二的续写，WMS,IMS，再结合卷二的PMS AMS 每个模块都很详细，适合认真学习下 作者: 【加】马尔科姆•格拉德威尔（Malcolm Gladwell）豆瓣评分 7.6 链接我的评价想引发一个流行，首先要有人推，谁来推？就是书里说的 联系员（社交广的人）内行人（喜欢研究，对别人有一定说服力）还有销售员 ，第二 产品要有粘性，客户使用产品的时候 有附加的感受，这样有会有粘性，第三 要出现在恰当的时机，例如淘宝如果出生在 交通不发达的年代，也只有死路一条 作者: 马尔科姆·格拉德威尔豆瓣评分 8.1 链接我的评价成功并不是某一个人努力的结果，需要正好出生在一个 有机遇的时机，用中国话说就是乱世出英雄（感觉差不多意思），当机遇来的时候 正好已经掌握成熟的技能书上说的10000小时 也不过是个虚数，但你确实要经过刻苦的训练，反复的琢磨，同时你还要有个一个良好的成长环境，树立正确的价值观和与人沟通的技巧，最后在你生活地区 是否有 类似荣誉文化的影响（如东北地区的人脾气比较火爆，很明显做生意的都是南方人） 作者: [英] 安德鲁·霍奇斯豆瓣评分 7.5 链接我的评价读起来有点费劲，看不大进去,一个同性恋给另一个同性恋写的传记，我要能看进去就坏了 作者: [美]卡迈恩·加洛豆瓣评分 8.3 链接我的评价好书是好书，我就是个内向的人 每次再公共场合发言都很害怕，看了这本书 发现即使罗永浩这样的人 在演讲的时候 也都不过是 扒书里的套路 ，这给我带来了很大的信心，这本书也应该是我以后每次演讲的 工具书 甚至是练习的模板 作者: 周志明豆瓣评分 8.9 链接我的评价不错，值得推荐，内存和垃圾回收都写的非常详细，在配合案例对java虚拟机的优化很有帮助。后半部分 关于class也写的很好 作者: 刘超豆瓣评分 无 链接我的评价去年看过一遍，根本找不到北，还觉得这本书太深奥了，今年看过深入理解android(1,2)后，又翻了翻这本书，突然感觉，一切都是那么好理解，而且知识覆盖率也相当大，但都不是特别深入 作者: 邓凡平豆瓣评分 8.0 链接我的评价这本相对，第一本阅读起来比较轻松些，因为主要分析的java层的知识点，比较细致，书中对AMS那部分 讲解的非常透彻，到对通知 个服务 不够深入 作者: 邓凡平豆瓣评分 8.0 链接我的评价绝对的好书，对我帮助非常大，虽然系统版本过老，不过对照着新代码和百度看，收获还是不少 作者: 杨丰盛豆瓣评分 6.9 链接我的评价比较全面，对底层分析的也比较深入，不过略显枯燥，而且分析的android过考，所以不建议初学者看 作者: 郭霖豆瓣评分 8.4 链接我的评价入门最好的一本书，没有之一，这本书的优点在于，不那么枯燥，也很好理解 ，这本书 可以让你 在有JAVA基础的条件上 快速的 学会android开发，这里指的的会 不过是参照东西做， 如果想弄明白，这本书显然不够， 不过 可以看一看 作者郭霖的技术博客也也很好 作者: 程杰豆瓣评分 7.9 链接我的评价还行 如果不是科班出身的程序员，可以可以把这本书当做数据的书学习，应付二流公司面试应该没问题，但绝对不是终点，我还在啃算法导论，那本就太枯燥了 作者: 路川豆瓣评分 无 链接我的评价就这本书搞的我那年一个年都没过好，数据写了很多东西，到看完后，记住的没多少 作者: [美] Bruce Eckel / 陈昊鹏豆瓣评分 9.1链接我的评价还能说些什么，大字典 作者: 陈雄华 / 林开雄豆瓣评分 7.7链接我的评价也就入门用吧，想深入 还是读源码收获最大 作者: （美）Cay S. Horstmann / （美）Gary Cornell豆瓣评分 8.6链接我的评价二卷实用性高一些，后期工作中很多时候也会拿过来翻翻，查缺不全 作者: （美）Cay S. Horstmann / （美）Gary Cornell豆瓣评分 8.4链接我的评价很详细，当年刚入门的时候看的，不过当时感觉收获不大，因为都刚学过"},{"title":"categories","date":"2017-03-15T14:49:53.000Z","updated":"2017-03-16T15:33:27.797Z","comments":true,"path":"categories/index.html","permalink":"https://3431339973.github.io/categories/index.html","excerpt":"","text":"comments: false"},{"title":"tags","date":"2015-03-15T14:48:43.000Z","updated":"2017-03-16T15:33:43.405Z","comments":true,"path":"tags/index.html","permalink":"https://3431339973.github.io/tags/index.html","excerpt":"","text":"comments: false"}],"posts":[{"title":"ubuntu16.04 编译android6.0","slug":"20170328","date":"2017-03-28T13:45:17.000Z","updated":"2018-01-21T12:13:29.817Z","comments":true,"path":"2017/03/28/20170328/","link":"","permalink":"https://3431339973.github.io/2017/03/28/20170328/","excerpt":"阅读android源码，应该是每个android 开发者提升 技术最快的途径，如果感兴趣可以自己尝试编译一下android系统，本文编译环境是ubuntu16.04 ，编译的android版本是6.0 由于虚拟机配置比较低，编译器也比较慢，折腾了好几天。估计我的硬盘比我更辛苦，好了进入正题。","text":"阅读android源码，应该是每个android 开发者提升 技术最快的途径，如果感兴趣可以自己尝试编译一下android系统，本文编译环境是ubuntu16.04 ，编译的android版本是6.0 由于虚拟机配置比较低，编译器也比较慢，折腾了好几天。估计我的硬盘比我更辛苦，好了进入正题。 1.源码下载Google采用Git对AOSP项目进行多仓库管理，所以需要先安装git，git的使用之前有记录过123sudo apt-get install git git config --global user.email “test@qq.com” git config --global user.name “tom” 安装git（参考科大源） 按照 Google 官方教程 https://source.android.com/source/downloading.html 将 https://android.googlesource.com/platform/manifest 替换为 git://mirrors.ustc.edu.cn/aosp/platform/manifest。 具体做法摘录如下（以防墙抽风）： 首先下载 repo 工具1234567mkdir ~/binPATH=~/bin:$PATHcurl https://storage.googleapis.com/git-repo-downloads/repo &gt; ~/bin/repo## 如果上述 URL 不可访问，可以用下面的：## curl https://storage-googleapis.proxy.ustclug.org/git-repo-downloads/repo &gt; ~/bin/repochmod a+x ~/bin/repo 然后建立一个工作目录（名字任意）12mkdir WORKING_DIRECTORYcd WORKING_DIRECTORY 初始化仓库：123repo init -u git://mirrors.ustc.edu.cn/aosp/platform/manifest -b android-6.0.1_r62## 如果提示无法连接到 gerrit.googlesource.com，可以编辑 ~/bin/repo，把 REPO_URL 一行替换成下面的：## REPO_URL = &apos;https://gerrit-googlesource.proxy.ustclug.org/git-repo&apos; 有些时候 更换REPO_URL 依然连接失败，没关系 多试几次如果需要某个特定的 Android 版本（Android 版本列表）： 同步源码树（以后只需执行这条命令来同步）：1repo sync 接下来就是等了，这个过程比较慢 我大概用了一晚上 才下完源码。注：在下载过程中会出现很多问题，所以创建一个自动下载脚本，确保出错后自动执行repo sync，要不睡一觉起来发下代码下载失败那多恼火。先在 WORKING_DIRECTORY下创建一个脚本down.sh,代码如下：1234567#!/bin/bashrepo sync -j16while [ $? = 1 ]; do echo “======sync failed, re-sync again======” sleep 3 repo sync -j16done 执行命令12chmod a+x down.sh./down.sh 这样明天早上起来一看 代码就下完了。大概50多G，所以如果用虚拟机编译的化，建议设置100G以上内存。源码的文件夹中只有一个.repo文件夹，这是正常的，等到所有源码下载完毕，其余文件夹就会出现，不要着急 删除.repo下载完源码后，会发现代码有50多G 其中有个隐藏文件夹.repo 他自己就有40多G ，这个文件夹只跟代码同步有关，并不影响编译，果断删除，删除后源码只有7G ，可以备份下源码 2.配置编译环境更换软件源为阿里云为了更快的安装软件，我们需要更换软件源为国内的软件源，这里推荐使用Ubuntu官方指定的国内软件源阿里云1sudo gedit /etc/apt/sources.list 在文件最前面加入下面代码：12345678910deb http://mirrors.aliyun.com/ubuntu/ quantal main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ quantal-security main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ quantal-updates main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ quantal-proposed main restricted universe multiversedeb http://mirrors.aliyun.com/ubuntu/ quantal-backports main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ quantal main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ quantal-security main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ quantal-updates main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ quantal-proposed main restricted universe multiversedeb-src http://mirrors.aliyun.com/ubuntu/ quantal-backports main restricted universe multiverse 1sudo apt-get update 安装依赖1234567891011sudo apt-get install -y git flex bison gperf build-essential libncurses5-dev:i386 sudo apt-get install libx11-dev:i386 libreadline6-dev:i386 libgl1-mesa-dev g++-multilib sudo apt-get install tofrodos python-markdown libxml2-utils xsltproc zlib1g-dev:i386 sudo apt-get install dpkg-dev libsdl1.2-dev libesd0-devsudo apt-get install git-core gnupg flex bison gperf build-essential sudo apt-get install zip curl zlib1g-dev gcc-multilib g++-multilib sudo apt-get install libc6-dev-i386 sudo apt-get install lib32ncurses5-dev x11proto-core-dev libx11-dev sudo apt-get install lib32z-dev ccachesudo apt-get install libgl1-mesa-dev libxml2-utils xsltproc unzip m4sudo apt-get install git-core gnupg flex bison gperf build-essential zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z-dev ccache libgl1-mesa-dev libxml2-utils xsltproc unzip m4 Ubuntu 16.04请务必使用上面的依赖，Ubuntu 16.04需要的依赖和Ubuntu 14.04所需要的依赖是不同的，博主照着Ubuntu 14.04的依赖结果掉进大坑，详见后面的编译过程记录. 安装JDK编译android源码 对应android版本对 ubuntu版本有要求 Android版本 编译要求的Ubuntu最低版本 Android 6.0至AOSP master Ubuntu 14.04 Android 2.3.x至Android 5.x Ubuntu 12.04 Android 1.5至Android 2.2.x Ubuntu 10.04 Android版本 编译要求的Ubuntu最低版本 AOSP的Android主线 OpenJDK 8 Android 5.x至android 6.0 OpenJDK 7 Android 2.3.x至Android 4.4.x Oracle JDK 6 更具体的可以参看:Google源码编译要求 这里我编译的是android6.0 用的是openjdk7Ubuntu 15.04及之后的版本的在线安装库中只支持openjdk8和openjdk9的安装.因此,如果你想要安装openjdk 7需要首先设置ppa:12sudo add-apt-repository ppa:openjdk-r/ppa sudo apt-get update 然后再执行安装命令:1sudo apt-get install openjdk-7-jdk 配置环境变量打开/etc/profile文件:1sudo gedit /etc/profile 在末尾追加下面代码：1234export JAVA_HOME=/usr/lib/jvm/java-7-openjdk-amd64export JRE_HOME=$&#123;JAVA_HOME&#125;/jre export CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/lib export PATH=$&#123;JAVA_HOME&#125;/bin:$PATH 修改了/etc/profile文件需要重启才能生效，但使用下面命令可以在不重启的情况下在当前bash环境生效：1source /etc/profile 有时候,我们需要编译不同版本的android系统,就可能使用不同的jdk版本.关于jdk版本切换,可以使用如下命令:123sudo update-alternatives --config javasudo update-alternatives --config javacsudo update-alternatives --config javap 查询下JDK版本1java -version 修改源码找到 WORKING_DIRECTORY/art/build/Android.common_build.mk 文件 1ifneq ($(WITHOUT_HOST_CLANG),true) 改为1ifneq ($(WITHOUT_HOST_CLANG),false) 如果不修改这里，会遇到一个比较棘手的编译错误，1make:***[out/host/lnux-x86/obj/lib/libartd.so] Error 1 修改的目的是把CLANG这个编译选项关掉，详见后面的编译记录，百度搜狗都无解，这个错误只会在Ubuntu16.04上遇到，Ubuntu14.04则不存在这个问题,这里卡了好几天 编译初始化编译环境确保上述过程完成后,接下来我们需要初始化编译环境,命令如下:1source build/envsetup.sh lunch控制台上会显示 选择 112345678910111213141516171819202122/ou&apos;re building on LinuxLunch menu…pick a combo:1. aosp_arm-eng2. aosp_arm64-eng3. aosp_mlps-eng4. aosp_mlps64-eng5. aosp_x86-eng6. aosp_x86_64-eng7. aosp_deb-userdebug8. aosp_flo-userdebug9. full_fugu-userdebug10. aosp_fugu-userdebug11. mlnl_emulator_arm64-userdebug12. n_e_arm-userdebug13. mlnl_emulator_mlps-userdebug14. mlnl_emulator_x86_64-userdebug15. mlnl_emulator_x86-userdebug16. aosp_flounder-userdebug17. aosp_hammerhead-userdebug18. aosp_hammerhead_fp-userdebug19. aosp_shanu-userdebugrJhlch would you like? [aosp_arm-eng] | 这里说一下user userdebug eng 版本 描述 user 用于正式产品 userdebug 和user类似，但是有root权限，并且可以调试，主要用于调试 eng 开发用的选项，配有额外的调试工具 如果编译后只在模拟器上运行，则lunch时选择：1 如果你想更深一步了解lunch该选哪一个，请参考下面的链接，根据第三列选择编译选项https://source.android.com/source/running.html 开始编译通过make指令进行代码编译,该指令通过-j参数来设置参与编译的线程数量,以提高编译速度.比如这里我们设置8个线程同时编译: 一般google推荐这个数字为2倍的cpu个数再加上2，比如4核，就是101make -j8 关于cpu个数，可以用下面命令查看:1cat /proc/cpuinfo 如果顺利，2个小时左右 就可以看到编译成功了，不过 应该是不可能的 还有其他常用命令 你肯定能遇到 make clean，make update-api 运行编译的文件会在 out目录下 编译成功里面会包含 system.img userdate.img ramdisk.img1emulator 不出意外，你将运行起来一个 黏糊糊 热乎乎的 android6.0 没错 你看 他真的很丑。 总结编译源码 前前后后一共用了一个 多星期，其中不少坑 ，文章里写的也只是 在编译后能记录下来，还有些坑想想都丢人 一般人也不会犯。","categories":[{"name":"Android","slug":"Android","permalink":"https://3431339973.github.io/categories/Android/"}],"tags":[{"name":"源码","slug":"源码","permalink":"https://3431339973.github.io/tags/源码/"},{"name":"Android","slug":"Android","permalink":"https://3431339973.github.io/tags/Android/"}]},{"title":"ShAndroidHttpService 在android设备上跑一个Http服务器","slug":"20170312","date":"2017-03-21T09:35:17.000Z","updated":"2017-10-22T12:08:58.511Z","comments":true,"path":"2017/03/21/20170312/","link":"","permalink":"https://3431339973.github.io/2017/03/21/20170312/","excerpt":"摘要:最近公司在开发一款类似智能家居的硬件项目，需要内网和服务器做交互，同时也需要服务器去操作客户端硬件，考虑到服务器终端。各方面性能比较差，也不想用长连接，所以干脆在android设备上也跑了一个service 给服务端提供http接口来调用，所以封装了这个库，为了让后端人员能直接上手，所以配置方法，和注解，都模仿了SpringMVC","text":"摘要:最近公司在开发一款类似智能家居的硬件项目，需要内网和服务器做交互，同时也需要服务器去操作客户端硬件，考虑到服务器终端。各方面性能比较差，也不想用长连接，所以干脆在android设备上也跑了一个service 给服务端提供http接口来调用，所以封装了这个库，为了让后端人员能直接上手，所以配置方法，和注解，都模仿了SpringMVC ShAndroidHttpServiceAndroid http服务器 Download the latest JAR or grab via Maven:123456&lt;dependency&gt; &lt;groupId&gt;code.zsh.sh.com.shandroidhttpservice&lt;/groupId&gt; &lt;artifactId&gt;httplib&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt;&lt;/dependency&gt; or Gradle:1compile 'code.zsh.sh.com.shandroidhttpservice:httplib:1.0.0' 启动http服务 1234567WebServer webServer = new WebServer(PORT); //配置controller 集合 webServer.setControllerName(getClassName(CONTROLLER)); //配置拦截器 集合 webServer.setInterceptPName(getClassName(INTERCEPTS)); webServer.setDaemon(true); webServer.start(); ShInterceptor 拦截器继承ShInterceptor 实现preHandle 和postHandle 方法前着在收到请求前调用 后者在完成请求后调用12345678910111213141516171819public class HttpIntercepts implements ShInterceptor &#123; @Override public boolean preHandle(HttpRequest request, HttpResponse response, HttpContext context) &#123; try &#123; String target = URLDecoder.decode(request.getRequestLine().getUri(), \"UTF-8\"); Log.e(\"url=\", target); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return true; &#125; @Override public void postHandle(HttpRequest request, HttpResponse response, HttpContext context) &#123; &#125;&#125; Controller Action@Controller改controller的作用域， @RequestMapping调用的action下面的写法最终生成的地址 xxx.xxx.xxx.xxx:xxxx/api/getphoneinof返回值以json类型返回123456789@Controller(space = \"/api\")public class HttpController &#123; @RequestMapping(path = \"/getphoneinof\") public ResultModel getPhoneInof() &#123; ResultModel resultModel = new ResultModel(true); return resultModel; &#125;&#125; 传递参数在方法的前面加上@Requestparam 即可123456@RequestMapping(path = \"/toast\") public ResultModel toast(@Requestparam(\"message\") String message) &#123; ResultModel resultModel = new ResultModel(true); MainActivity.mainActivity.toast(message); return resultModel; &#125; 项目地址 https://github.com/hui46226021/ShAndroidHttpService","categories":[{"name":"Android","slug":"Android","permalink":"https://3431339973.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://3431339973.github.io/tags/Android/"},{"name":"http","slug":"http","permalink":"https://3431339973.github.io/tags/http/"}]},{"title":"Android表单映射框架 SHFormLayout 快速生成表单布局","slug":"ShFormLayout","date":"2017-03-17T14:37:23.000Z","updated":"2017-10-01T12:50:27.948Z","comments":true,"path":"2017/03/17/ShFormLayout/","link":"","permalink":"https://3431339973.github.io/2017/03/17/ShFormLayout/","excerpt":"摘要:由于公司业务 有大量表单页面的需求 故独立封装一套表单映射 布局框架","text":"摘要:由于公司业务 有大量表单页面的需求 故独立封装一套表单映射 布局框架 ShFormUtilsDownloadDownload the latest JAR or grab via Maven:123456&lt;dependency&gt; &lt;groupId&gt;com.sh.zsh.code&lt;/groupId&gt; &lt;artifactId&gt;shform&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt;&lt;/dependency&gt; or Gradle:1compile 'com.sh.zsh.code:shform:3.2.2' 功能表单对象映射 1.页面实现 FormCheckInterface 接口 改接口 是页面表单检查的回调 下面有介绍 2.开启表单注入 FormInit.injection(this); 123456789101112131415@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); nameEdit = (EditText) findViewById(R.id.name); phoneEdit = (EditText) findViewById(R.id.phone); professionEdit = (EditText) findViewById(R.id.profession); spinner = (Spinner) findViewById(R.id.spinner); married = (CheckBox) findViewById(R.id.married); party = (CheckBox) findViewById(R.id.party); /** * 初始化表单注入 要在 所有控件初始化成功后 调用 */ FormInit.injection(this); &#125; 3.在 onDestroy 里 注销 表单 12345678@Overrideprotected void onDestroy() &#123;/** * 注销表单 */FormInit.deleteInjection(this);super.onDestroy();&#125; 4.通过 @FormInjection 绑定控件 12345678910111213141516/** * name 对应 实体类 字段名 * message 参数为空的时候 默认提示 的字符串 * isNull 该字段是否可以为空 默认 false */ @FormInjection(name = \"name\", message = \"名字\",isNull = true) EditText nameEdit; @FormCheck(type = CheckType.Phone) @FormInjection(name = \"phone\", message = \"电话\") EditText phoneEdit; @FormInjection(name = \"profession\", message = \"公司-职业\") EditText professionEdit; @FormInjection(name = \"workingLife\", message = \"工作时间\") Spinner spinner; @FormInjection(name = \"married\") CheckBox married; 4.调用映射方法 12345678/** * 表单自动生成对象 */ UserModel userModel = FormUtls.formToObjectAndCheck(this,UserModel.class);/** * 实体对象 映射到表单 返回true 表示映射成功 */ FormUtls.objectToForm(this,userModel); 表单参数检查* 1.使用 @FormCheck 123456789101112131415161718192021222324252627282930313233343536//type 是 验证类型枚举 默认 是自定义验证 @FormCheck(type = CheckType.Phone) @FormInjection(name = \"phone\", message = \"电话\") EditText phoneEdit; @FormCheck @FormInjection(name = \"profession\", message = \"公司-职业\") EditText professionEdit; /** * 通过 实现 FormCheckInterface 接口的 formCheck * 自定定义 表单检查 默认要返回true * @param v * @return */ @Override public boolean formCheck(View v) &#123; switch (v.getId())&#123; case R.id.profession: if(!(professionEdit.getText()+\"\").contains(\"-\"))&#123; Toast.makeText(this,\"职业格式不正确\",Toast.LENGTH_SHORT).show(); return false; &#125; break; &#125; return true; &#125; /** * 表单检查 不合法回调 * @param v * @param message */ @Override public void formCheckNullCall(View v, String message) &#123; Toast.makeText(this,message,Toast.LENGTH_SHORT).show(); &#125; 验证类型CUSTOM,//自定义 PHONE,//手机号 EMAIL,//邮箱 CHINESE,//中文 IDCARD,//身份证 ISDATA,//“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年 AMOUNT_MONEY,//金额校验，精确到2位小数 AMOUNT,//存数字 URL,//Url PASSWORD;//密码强度 是不是6至12位字母组合 快速生成表单布局 ShFormLayoutShFormLayout 可以在使用 系统控件的基础上 实现快速生成表单布局 样式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;com.sh.zsh.code.layout.ShFormLayout &lt;!--该布局 需要在这确定 每行的高度 --&gt; app:less_form_row_height=\"50dp\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"&gt; &lt;TextView &lt;!--这里表明 这个控件 只是用于显示标题--&gt; app:less_form_group_titel=\"true\" android:text=\"基本信息\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /&gt; &lt;EditText &lt;!--该行的标题--&gt; app:less_form_title=\"姓名\" &lt;!--该行对应的字段名--&gt; app:less_form_name=\"name\" &lt;!--该行是否必填--&gt; app:less_form_must=\"true\" android:layout_height=\"wrap_content\" android:layout_width=\"match_parent\" /&gt; &lt;EditText app:less_form_title=\"电话\" &lt;!--该行的验证方式--&gt; app:less_form_check_type=\"phone\" app:less_form_name=\"phone\" android:layout_height=\"wrap_content\" android:layout_width=\"match_parent\" app:less_form_must=\"true\" /&gt; &lt;com.sh.zsh.code.layout.view.FormSpinner android:id=\"@+id/company\" app:less_form_title=\"公司\" app:less_form_name=\"company\" android:layout_height=\"wrap_content\" android:layout_width=\"match_parent\" app:less_form_must=\"true\" /&gt; &lt;com.sh.zsh.code.layout.view.FormSpinner android:id=\"@+id/department\" app:less_form_title=\"部门\" app:less_form_name=\"department\" android:layout_height=\"wrap_content\" android:layout_width=\"match_parent\" app:less_form_must=\"true\" /&gt; &lt;com.sh.zsh.code.layout.view.FormTimeView app:less_form_title=\"出生日期\" app:less_form_name=\"birthday\" android:layout_height=\"wrap_content\" android:layout_width=\"match_parent\" app:less_form_must=\"true\" /&gt; &lt;CheckBox app:less_form_title=\"男性：\" app:less_form_name=\"sex\" android:layout_height=\"wrap_content\" android:layout_width=\"match_parent\" app:less_form_must=\"true\" /&gt; &lt;LinearLayout app:less_form_group_top_layout=\"true\" android:layout_width=\"match_parent\" android:layout_height=\"150dp\" android:background=\"@color/white\" android:orientation=\"horizontal\"&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"match_parent\" android:layout_margin=\"18dp\" android:textSize=\"@dimen/form_text_size\" android:text=\"签名\" /&gt; &lt;EditText android:id=\"@+id/sign\" android:gravity=\"top\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_margin=\"16dp\" android:padding=\"5dp\" android:textSize=\"@dimen/form_text_size\" android:background=\"@drawable/bg_text_factoryaudit\" android:hint=\"多行输入\" /&gt; &lt;/LinearLayout&gt; &lt;/com.sh.zsh.code.layout.ShFormLayout&gt; 界面预览 快看，你不需要去关心 每一行的样式，高度 只需要确定这一行是 TextView 或是EditText 等控件 就可以了我们来看一下 框架都提供了 哪些表单属性 供我们使用 ShFormLayout less_form_row_height 表单每行的 高度 内部控件less_form_title 名称less_form_title_image 设置名称左侧的iconless_form_can_click 该行是否显示 右侧箭头less_form_must 该字段是否必填less_form_name 该字段对应实体类的字段名称less_form_is_null 该字段是否可以为空less_form_bottomLine 该行是否显示底部横线less_form_check_type 检查类型less_form_group_titel 该组表单的标题 （上面的例子里 基本信息 那一行）less_form_group_top_layout 改控件不 参与表单映射 和布局生成（上面的例子里签名 那个布局） FormTimeView 时间控件less_time_is_time 时间控件的格式（all，year_month_day，hours_mins，month_day_hour_min，year_month） FormSpinner 选择器 用法参考Demoless_form_spi_sel 默认选中第一项 源码地址：https://github.com/hui46226021/ShFormUtils","categories":[{"name":"Android","slug":"Android","permalink":"https://3431339973.github.io/categories/Android/"}],"tags":[{"name":"移动开发","slug":"移动开发","permalink":"https://3431339973.github.io/tags/移动开发/"},{"name":"原创","slug":"原创","permalink":"https://3431339973.github.io/tags/原创/"},{"name":"Form","slug":"Form","permalink":"https://3431339973.github.io/tags/Form/"},{"name":"框架","slug":"框架","permalink":"https://3431339973.github.io/tags/框架/"},{"name":"表单映射","slug":"表单映射","permalink":"https://3431339973.github.io/tags/表单映射/"},{"name":"自定义View","slug":"自定义View","permalink":"https://3431339973.github.io/tags/自定义View/"}]},{"title":"ShVideoDemo android 适配录制，压缩","slug":"ShVideoDemo android 适配录制，压缩","date":"2017-02-18T14:37:23.000Z","updated":"2017-10-01T12:50:37.769Z","comments":true,"path":"2017/02/18/ShVideoDemo android 适配录制，压缩/","link":"","permalink":"https://3431339973.github.io/2017/02/18/ShVideoDemo android 适配录制，压缩/","excerpt":"摘要：Android 视频录制Demo 仿微信小视频 视频压缩（FFmpeg）","text":"摘要：Android 视频录制Demo 仿微信小视频 视频压缩（FFmpeg） ShVideoDemoAndroid 视频录制Demo 防微信小视频 视频压缩（FFmpeg） #Download Download the latest JAR or grab via Maven:123456&lt;dependency&gt; &lt;groupId&gt;com.sh.shvideo&lt;/groupId&gt; &lt;artifactId&gt;shvideolibrary&lt;/artifactId&gt; &lt;version&gt;1.0.3&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt;&lt;/dependency&gt; or Gradle:1compile 'com.sh.shvideo:shvideolibrary:1.0.3' 注意:targetSdkVersion 23 及以上 要注意 6.0运行时权限 或干脆用23以下 源码地址:https://github.com/hui46226021/ShVideoDemo","categories":[{"name":"Android","slug":"Android","permalink":"https://3431339973.github.io/categories/Android/"}],"tags":[{"name":"移动开发","slug":"移动开发","permalink":"https://3431339973.github.io/tags/移动开发/"},{"name":"原创","slug":"原创","permalink":"https://3431339973.github.io/tags/原创/"},{"name":"视频压缩","slug":"视频压缩","permalink":"https://3431339973.github.io/tags/视频压缩/"},{"name":"视频录制","slug":"视频录制","permalink":"https://3431339973.github.io/tags/视频录制/"}]},{"title":"Retrofit2.0 - 网络请求库 注解 详解","slug":"Retrofit2.0","date":"2017-01-01T04:32:21.000Z","updated":"2017-10-01T12:50:24.642Z","comments":true,"path":"2017/01/01/Retrofit2.0/","link":"","permalink":"https://3431339973.github.io/2017/01/01/Retrofit2.0/","excerpt":"Retrofit基于注解和动态代理，优化了Android中的网络请求操作。","text":"Retrofit基于注解和动态代理，优化了Android中的网络请求操作。 OverView这篇笔记基于Retrofit 1.9。 从上图可见，对Retrofit的使用可以分成三部分： 1.建立POJO或者Model Class服务端返回给客户端的数据一般都是JSON格式，所以可以利用GSON或其他库把JSON直接转换成一个对象。POJO或这个Model Class就是这个对象的类。 2.定义REST API Interface定义一个Interface，声明我们需要的网络请求方法。例如：1234public interface GitHubService &#123; @GET(\"/users/&#123;user&#125;/repos\") List&lt;Repo&gt; listRepos(@Path(\"user\") String user);&#125; Repo，就是第一步中定义的POJO或者Model Class。Retrofit框架会自动把服务端返回的JSON数据，转换成Repo。Retrofit默认采用GSON库。 3.RestAdapterRestAdapter用来配置网络请求的参数，并且生成一个接口的实现。配置请求参数：1234RestAdapter restAdapter = new RestAdapter.Builder() .setEndpoint(\"https://api.github.com\") .setClient(new OkClient(new OkHttpClient())) .build(); 生成接口的实现：1GitHubService service = restAdapter.create(GitHubService.class); 以上三步完成后，调用接口函数完成与服务器的交互： List repos = service.listRepos(“octocat”); 请求方法 Retrofit框架提供了很多注解，其中HTTP注解有五个，用来修饰请求方法（还可以顺便处理URL路径）： GET POST PUT DELETE HEAD这五个注解正好涵盖了数据的增删改查方法，符合REST标准。每一个请求方法都必须要由这五个注解中的一个修饰。1@GET(\"/users/list\") 可以在注解中添加查询参数1@GET(\"/users/list?sort=desc\") URL处理 @Path - 替换参数 12@GET(\"/group/&#123;id&#125;/users\")List&lt;User&gt; groupList(@Path(\"id\") int groupId); @Query - 添加查询参数 12@GET(\"/group/&#123;id&#125;/users\")List&lt;User&gt; groupList(@Path(\"id\") int groupId, @Query(\"sort\") String sort); @QueryMap - 如果有多个查询参数，把它们放在Map中 12@GET(\"/group/&#123;id&#125;/users\")List&lt;User&gt; groupList(@Path(\"id\") int groupId, @QueryMap Map&lt;String, String&gt; options); 请求体请求体（RequestBody），一般用于POST方法传递请求参数。@Body12@POST(\"/users/new\")void createUser(@Body User user, Call&lt;User&gt; call); 参数会被指定的转换器转换成字符串或字节流提交到服务器，如果没有指定转换器，Retrofit将会默认使用RequestBody。 FORM ENCODED(表单) And MULTIPART FORM ENCODED 使用 @FormUrlEncoded 修饰请求方法，可以把表单数据提交到服务端。用 @Field 修饰key-value对。123@FormUrlEncoded@POST(\"/user/edit\")User updateUser(@Field(\"first_name\") String first, @Field(\"last_name\") String last); MULTIPART 使用 @Multipart 修饰请求方法，@Part 修饰每一个Part123@Multipart@PUT(\"/user/photo\")User updateUser(@Part(\"photo\") TypedFile photo, @Part(\"description\") TypedString description); Multipart 中的Part使用 RestAdapter 的转换器来转换，也可以实现 TypedOutput 自己处理序列化。 Multipart主要用来上传文件吗？如果是，具体操作又是如何？ 答案在这里 配制HEADER用 @Headers 设置Http请求的header。12345678910@Headers(\"Cache-Control: max-age=640000\")@GET(\"/widget/list\")void widgetList(Call&lt;List&lt;Widget&gt;&gt; call);@Headers(&#123; \"Accept: application/vnd.github.v3.full+json\", \"User-Agent: Retrofit-Sample-App\"&#125;)@GET(\"/users/&#123;username&#125;\")void getUser(@Path(\"username\") String username, Call&lt;User&gt;); Http请求头不会互相覆盖，如果存在多个请求头的名字相同，那么它们全部都会被包含在Http请求中。 动态更新HEADER 在请求方法的参数中，用 @Header 动态更新Http请求头12@GET(\"/user\")void getUser(@Header(\"Authorization\") String authorization, Call&lt;User&gt; call) 参数不能为null，否则这个header将会被删掉。 在RestAdapter中，利用RequestInterceptor动态更新Header12345678910RequestInterceptor requestInterceptor = new RequestInterceptor() &#123; @Override public void intercept(RequestFacade request) &#123; request.addHeader(\"User-Agent\", \"Retrofit-Sample-App\"); &#125;&#125;;RestAdapter restAdapter = new RestAdapter.Builder() .setEndpoint(\"https://api.github.com\") .setRequestInterceptor(requestInterceptor) .build(); 异步与同步每个请求方法都可以定义成同步或者异步。 同步 同步方法有返回值，且参数中不包含回调123456789101112131415161718192021 @GET(\"/users/&#123;user&#125;/repos\") List&lt;Repo&gt; listRepos(@Path(\"user\") String user);~~* 异步异步方法没有返回值，且最后一个参数须是Callback对象~~~java @GET(\"/users/&#123;user&#125;/repos\") void listRepos(@Path(\"user\") String user, Callback&lt;List&lt;Repo&gt;&gt; call);~~在Android中，callbacks将会在主线程中调用。在普通Java程序中，callbacks将会在执行HTTP请求方法的那个线程中调用。## 处理服务器返回结果RestAdapter中的转换器会把服务器的返回结果（一般为JSON）转换成我们在函数返回值或Callback接口中定义的Java对象。~~~java @GET(\"/users/&#123;user&#125;/repos\") List&lt;Repo&gt; listRepos(@Path(\"user\") String user); @GET(\"/users/&#123;user&#125;/repos\") void listRepos(@Path(\"user\") String user, Callback&lt;List&lt;Repo&gt;&gt; call); List,就是将要被转换成的Java对象。 直接获取返回体如果要直接获取服务器返回的HTTP返回体，在返回值或callback中直接使用 Response对象。12345@GET(\"/users/&#123;user&#125;/repos\")Response listRepos(@Path(\"user\") String user);@GET(\"/users/&#123;user&#125;/repos\")void listRepos(@Path(\"user\") String user, Callback&lt;Response&gt; call); 参考链接: 官方文档：不过是Retrofit2.0中文文档：这个是Retrofit1.9源码解析：[http://frodoking.github.io/2015/05/16/android-retrofit/](http://frodoking.github.io/2015/05/16/ 原文地址：http://www.jianshu.com/p/63723f593695","categories":[{"name":"Android","slug":"Android","permalink":"https://3431339973.github.io/categories/Android/"}],"tags":[{"name":"移动开发","slug":"移动开发","permalink":"https://3431339973.github.io/tags/移动开发/"},{"name":"转贴","slug":"转贴","permalink":"https://3431339973.github.io/tags/转贴/"},{"name":"Retrofit2.0","slug":"Retrofit2-0","permalink":"https://3431339973.github.io/tags/Retrofit2-0/"},{"name":"网络访问","slug":"网络访问","permalink":"https://3431339973.github.io/tags/网络访问/"}]},{"title":"Okhttp源码分析学习（2）5个拦截器","slug":"okhttp2","date":"2016-11-22T14:15:31.000Z","updated":"2017-10-21T11:47:05.877Z","comments":true,"path":"2016/11/22/okhttp2/","link":"","permalink":"https://3431339973.github.io/2016/11/22/okhttp2/","excerpt":"摘要:昨天分析okhttp的请求流程，今天来分析下这几个拦截器","text":"摘要:昨天分析okhttp的请求流程，今天来分析下这几个拦截器 各种拦截器 RetryAndFollowUpInterceptor直接上代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980@Override public Response intercept(Chain chain) throws IOException &#123; Request request = chain.request(); //初始化连接对象 streamAllocation = new StreamAllocation( client.connectionPool(), createAddress(request.url())); int followUpCount = 0; Response priorResponse = null; while (true) &#123; if (canceled) &#123; streamAllocation.release(); throw new IOException(\"Canceled\"); &#125; Response response = null; boolean releaseConnection = true; try &#123; //继续下一个拦截器 response = ((RealInterceptorChain) chain).proceed(request, streamAllocation, null, null); releaseConnection = false; &#125; catch (RouteException e) &#123; // The attempt to connect via a route failed. The request will not have been sent. if (!recover(e.getLastConnectException(), true, request)) throw e.getLastConnectException(); releaseConnection = false; continue; &#125; catch (IOException e) &#123; // An attempt to communicate with a server failed. The request may have been sent. if (!recover(e, false, request)) throw e; releaseConnection = false; continue; &#125; finally &#123; // We're throwing an unchecked exception. Release any resources. if (releaseConnection) &#123; streamAllocation.streamFailed(null); streamAllocation.release(); &#125; &#125; // Attach the prior response if it exists. Such responses never have a body. if (priorResponse != null) &#123; response = response.newBuilder() .priorResponse(priorResponse.newBuilder() .body(null) .build()) .build(); &#125; Request followUp = followUpRequest(response); if (followUp == null) &#123; if (!forWebSocket) &#123; streamAllocation.release(); &#125; return response; &#125; closeQuietly(response.body()); if (++followUpCount &gt; MAX_FOLLOW_UPS) &#123; streamAllocation.release(); throw new ProtocolException(\"Too many follow-up requests: \" + followUpCount); &#125; if (followUp.body() instanceof UnrepeatableRequestBody) &#123; throw new HttpRetryException(\"Cannot retry streamed HTTP body\", response.code()); &#125; if (!sameConnection(response, followUp.url())) &#123; streamAllocation.release(); streamAllocation = new StreamAllocation( client.connectionPool(), createAddress(followUp.url())); &#125; else if (streamAllocation.stream() != null) &#123; throw new IllegalStateException(\"Closing the body of \" + response + \" didn't close its backing stream. Bad interceptor?\"); &#125; request = followUp; priorResponse = response; &#125; &#125; 实例化StreamAllocation，初始化一个Socket连接对象，获取到输入／输出流（）基于Okio开启循环，执行下一个调用链（拦截器），等待返回结果（Response）如果发生错误，判断是否继续请求，否：退出检查响应是否符合要求，是：返回关闭响应结果判断是否达到最大限制数，是：退出检查是否有相同连接，是：释放，重建连接重复以上流程 BridgeInterceptor本拦截器的主要功能是：处理请求头（header），将自定义的头和协议必须的头合在一起，如果有自定义使用自定义的，没有就生成默认头123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869@Override public Response intercept(Chain chain) throws IOException &#123; Request userRequest = chain.request(); Request.Builder requestBuilder = userRequest.newBuilder(); RequestBody body = userRequest.body(); if (body != null) &#123; MediaType contentType = body.contentType(); if (contentType != null) &#123; requestBuilder.header(\"Content-Type\", contentType.toString()); &#125; long contentLength = body.contentLength(); if (contentLength != -1) &#123; requestBuilder.header(\"Content-Length\", Long.toString(contentLength)); requestBuilder.removeHeader(\"Transfer-Encoding\"); &#125; else &#123; requestBuilder.header(\"Transfer-Encoding\", \"chunked\"); requestBuilder.removeHeader(\"Content-Length\"); &#125; &#125; if (userRequest.header(\"Host\") == null) &#123; requestBuilder.header(\"Host\", hostHeader(userRequest.url(), false)); &#125; if (userRequest.header(\"Connection\") == null) &#123; requestBuilder.header(\"Connection\", \"Keep-Alive\"); &#125; // If we add an \"Accept-Encoding: gzip\" header field we're responsible for also decompressing // the transfer stream. boolean transparentGzip = false; if (userRequest.header(\"Accept-Encoding\") == null) &#123; transparentGzip = true; requestBuilder.header(\"Accept-Encoding\", \"gzip\"); &#125;// 创建Okhpptclitent时候配置的cookieJar， List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url()); if (!cookies.isEmpty()) &#123; requestBuilder.header(\"Cookie\", cookieHeader(cookies)); &#125; if (userRequest.header(\"User-Agent\") == null) &#123; requestBuilder.header(\"User-Agent\", Version.userAgent()); &#125; // 以上为请求前的头处理 下面是调用接下来的拦截器 Response networkResponse = chain.proceed(requestBuilder.build());// 以下是请求完成，拿到返回后的头处理 HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers()); Response.Builder responseBuilder = networkResponse.newBuilder() .request(userRequest); //前面解析完header后，判断服务器是否支持gzip压缩格式，如果支持将交给Okio处理 if (transparentGzip &amp;&amp; \"gzip\".equalsIgnoreCase(networkResponse.header(\"Content-Encoding\")) &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123; GzipSource responseBody = new GzipSource(networkResponse.body().source()); Headers strippedHeaders = networkResponse.headers().newBuilder() .removeAll(\"Content-Encoding\") .removeAll(\"Content-Length\") .build(); responseBuilder.headers(strippedHeaders); responseBuilder.body(new RealResponseBody(strippedHeaders, Okio.buffer(responseBody))); &#125; return responseBuilder.build(); &#125; CacheInterceptor123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081@Override public Response intercept(Chain chain) throws IOException &#123; Response cacheCandidate = cache != null ? cache.get(chain.request()) : null; long now = System.currentTimeMillis(); CacheStrategy strategy = new CacheStrategy.Factory(now, chain.request(), cacheCandidate).get(); Request networkRequest = strategy.networkRequest; Response cacheResponse = strategy.cacheResponse; if (cache != null) &#123; cache.trackResponse(strategy); &#125; if (cacheCandidate != null &amp;&amp; cacheResponse == null) &#123; closeQuietly(cacheCandidate.body()); // The cache candidate wasn't applicable. Close it. &#125; // If we're forbidden from using the network and the cache is insufficient, fail. if (networkRequest == null &amp;&amp; cacheResponse == null) &#123; return new Response.Builder() .request(chain.request()) .protocol(Protocol.HTTP_1_1) .code(504) .message(\"Unsatisfiable Request (only-if-cached)\") .body(EMPTY_BODY) .sentRequestAtMillis(-1L) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); &#125; // If we don't need the network, we're done. if (networkRequest == null) &#123; return cacheResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .build(); &#125; Response networkResponse = null; try &#123; networkResponse = chain.proceed(networkRequest); &#125; finally &#123; // If we're crashing on I/O or otherwise, don't leak the cache body. if (networkResponse == null &amp;&amp; cacheCandidate != null) &#123; closeQuietly(cacheCandidate.body()); &#125; &#125; // If we have a cache response too, then we're doing a conditional get. if (cacheResponse != null) &#123; if (validate(cacheResponse, networkResponse)) &#123; Response response = cacheResponse.newBuilder() .headers(combine(cacheResponse.headers(), networkResponse.headers())) .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); networkResponse.body().close(); // Update the cache after combining headers but before stripping the // Content-Encoding header (as performed by initContentStream()). cache.trackConditionalCacheHit(); cache.update(cacheResponse, response); return response; &#125; else &#123; closeQuietly(cacheResponse.body()); &#125; &#125; Response response = networkResponse.newBuilder() .cacheResponse(stripBody(cacheResponse)) .networkResponse(stripBody(networkResponse)) .build(); if (HttpHeaders.hasBody(response)) &#123; CacheRequest cacheRequest = maybeCache(response, networkResponse.request(), cache); response = cacheWritingResponse(cacheRequest, response); &#125; return response; &#125; 就是先走自己的缓存策略，如果又缓存就直接返回了 Response，如果没有就进入下个拦截器 ConnectInterceptor倒数第二个拦截器—连接拦截器，这才是真正的开始向服务端发起进攻 123456789101112131415161718192021222324252627282930313233package okhttp3.internal.connection;import java.io.IOException;import okhttp3.Interceptor;import okhttp3.OkHttpClient;import okhttp3.Request;import okhttp3.Response;import okhttp3.internal.http.HttpStream;import okhttp3.internal.http.RealInterceptorChain;/** Opens a connection to the target server and proceeds to the next interceptor. */public final class ConnectInterceptor implements Interceptor &#123; public final OkHttpClient client; public ConnectInterceptor(OkHttpClient client) &#123; this.client = client; &#125; @Override public Response intercept(Chain chain) throws IOException &#123; RealInterceptorChain realChain = (RealInterceptorChain) chain; Request request = realChain.request(); StreamAllocation streamAllocation = realChain.streamAllocation(); // We need the network to satisfy this request. Possibly for validating a conditional GET. boolean doExtensiveHealthChecks = !request.method().equals(\"GET\"); //实例化httpcodec，如果是http2.0实例化Http1Stream否则Http2Stream HttpStream httpStream = streamAllocation.newStream(client, doExtensiveHealthChecks); RealConnection connection = streamAllocation.connection(); return realChain.proceed(request, streamAllocation, httpStream, connection); &#125;&#125; 对没错 就这么几行代码，处的逻辑很简单，因为已经转嫁到其他的类对象上去了。前面我们提到过RealInterceptorChain构造函数有四个重要的属性（Request、StreamAllocation， HttpStream、Connection）第一个不用说一开始就必须有，第二个是在重试拦截器中实例化的，第三、第四就是在本节中腰实例化出来的。StreamAllocation 我们知道是在第一个拦截器创建。 newStream深入看一下 newStream 方法 123456789101112131415161718192021222324252627282930public HttpStream newStream(OkHttpClient client, boolean doExtensiveHealthChecks) &#123; int connectTimeout = client.connectTimeoutMillis(); int readTimeout = client.readTimeoutMillis(); int writeTimeout = client.writeTimeoutMillis(); boolean connectionRetryEnabled = client.retryOnConnectionFailure(); try &#123; //判断之前是否又连接 RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks); HttpStream resultStream; if (resultConnection.framedConnection != null) &#123; resultStream = new Http2xStream(client, this, resultConnection.framedConnection); &#125; else &#123; resultConnection.socket().setSoTimeout(readTimeout); resultConnection.source.timeout().timeout(readTimeout, MILLISECONDS); resultConnection.sink.timeout().timeout(writeTimeout, MILLISECONDS); resultStream = new Http1xStream( client, this, resultConnection.source, resultConnection.sink); &#125; synchronized (connectionPool) &#123; stream = resultStream; return resultStream; &#125; &#125; catch (IOException e) &#123; throw new RouteException(e); &#125;&#125; 这里就是获取连接 根据framedConnection 创建 HttpStream framedConnection123456789101112131415161718192021222324private RealConnection findHealthyConnection(int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled, boolean doExtensiveHealthChecks) throws IOException &#123; while (true) &#123; RealConnection candidate = findConnection(connectTimeout, readTimeout, writeTimeout, connectionRetryEnabled); // If this is a brand new connection, we can skip the extensive health checks. synchronized (connectionPool) &#123; if (candidate.successCount == 0) &#123; return candidate; &#125; &#125; // Do a (potentially slow) check to confirm that the pooled connection is still good. If it // isn't, take it out of the pool and start again. if (!candidate.isHealthy(doExtensiveHealthChecks)) &#123; noNewStreams(); continue; &#125; return candidate; &#125;&#125; 看findConnection 方法 findConnection1234567891011121314151617181920212223242526272829303132333435363738394041424344454647private RealConnection findConnection(int connectTimeout, int readTimeout, int writeTimeout, boolean connectionRetryEnabled) throws IOException &#123; Route selectedRoute; synchronized (connectionPool) &#123; if (released) throw new IllegalStateException(\"released\"); if (stream != null) throw new IllegalStateException(\"stream != null\"); if (canceled) throw new IOException(\"Canceled\"); // 使用已存在的连接 RealConnection allocatedConnection = this.connection; if (allocatedConnection != null &amp;&amp; !allocatedConnection.noNewStreams) &#123; return allocatedConnection; &#125; //从连接池里获取 // Attempt to get a connection from the pool. RealConnection pooledConnection = Internal.instance.get(connectionPool, address, this); if (pooledConnection != null) &#123; this.connection = pooledConnection; return pooledConnection; &#125; selectedRoute = route; &#125; if (selectedRoute == null) &#123; selectedRoute = routeSelector.next(); synchronized (connectionPool) &#123; route = selectedRoute; refusedStreamCount = 0; &#125; &#125; //以上都不符合，创建一个连接 RealConnection newConnection = new RealConnection(selectedRoute); acquire(newConnection); synchronized (connectionPool) &#123; //放入线程池 Internal.instance.put(connectionPool, newConnection); this.connection = newConnection; if (canceled) throw new IOException(\"Canceled\"); &#125; newConnection.connect(connectTimeout, readTimeout, writeTimeout, address.connectionSpecs(), connectionRetryEnabled); routeDatabase().connected(newConnection.route()); return newConnection; &#125; connect建立一个新连接123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public void connect(int connectTimeout, int readTimeout, int writeTimeout, List&lt;ConnectionSpec&gt; connectionSpecs, boolean connectionRetryEnabled) &#123; if (protocol != null) throw new IllegalStateException(\"already connected\"); RouteException routeException = null; ConnectionSpecSelector connectionSpecSelector = new ConnectionSpecSelector(connectionSpecs); if (route.address().sslSocketFactory() == null) &#123; if (!connectionSpecs.contains(ConnectionSpec.CLEARTEXT)) &#123; throw new RouteException(new UnknownServiceException( \"CLEARTEXT communication not enabled for client\")); &#125; String host = route.address().url().host(); if (!Platform.get().isCleartextTrafficPermitted(host)) &#123; throw new RouteException(new UnknownServiceException( \"CLEARTEXT communication to \" + host + \" not permitted by network security policy\")); &#125; &#125; //开始连接 while (protocol == null) &#123; try &#123; if (route.requiresTunnel()) &#123; // 如果要求通道模式，建立通道连接，通常不是这种 buildTunneledConnection(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector); &#125; else &#123; // 一般都走这条逻辑了，实际上很简单就是socket的连接 buildConnection(connectTimeout, readTimeout, writeTimeout, connectionSpecSelector); &#125; &#125; catch (IOException e) &#123; closeQuietly(socket); closeQuietly(rawSocket); socket = null; rawSocket = null; source = null; sink = null; handshake = null; protocol = null; if (routeException == null) &#123; routeException = new RouteException(e); &#125; else &#123; routeException.addConnectException(e); &#125; if (!connectionRetryEnabled || !connectionSpecSelector.connectionFailed(e)) &#123; throw routeException; &#125; &#125; &#125; &#125; 1234567private void buildConnection(int connectTimeout, int readTimeout, int writeTimeout, ConnectionSpecSelector connectionSpecSelector) throws IOException &#123; //建立连接 connectSocket(connectTimeout, readTimeout); //简历协议 establishProtocol(readTimeout, writeTimeout, connectionSpecSelector);&#125; 对于这两个方法 咱们一个一个看 connectSocket12345678910111213141516171819private void connectSocket(int connectTimeout, int readTimeout) throws IOException &#123; Proxy proxy = route.proxy(); Address address = route.address(); rawSocket = proxy.type() == Proxy.Type.DIRECT || proxy.type() == Proxy.Type.HTTP ? address.socketFactory().createSocket() : new Socket(proxy); rawSocket.setSoTimeout(readTimeout); try &#123; //连接Socket Platform.get().connectSocket(rawSocket, route.socketAddress(), connectTimeout); &#125; catch (ConnectException e) &#123; throw new ConnectException(\"Failed to connect to \" + route.socketAddress()); &#125; //得到 输入流 和输出流 source = Okio.buffer(Okio.source(rawSocket)); sink = Okio.buffer(Okio.sink(rawSocket)); &#125; connectSocket 方法简历了连接，得到了一个输入流和输出流，当然 可以看到 关于流这里 交给了okio来处理，关于okio 以后在说 establishProtocol123456789101112131415161718192021222324252627private void establishProtocol(int readTimeout, int writeTimeout, ConnectionSpecSelector connectionSpecSelector) throws IOException &#123; //判断是不是 https 如果是 就在上面在套一层 if (route.address().sslSocketFactory() != null) &#123; connectTls(readTimeout, writeTimeout, connectionSpecSelector); &#125; else &#123; protocol = Protocol.HTTP_1_1; socket = rawSocket; &#125; if (protocol == Protocol.SPDY_3 || protocol == Protocol.HTTP_2) &#123; socket.setSoTimeout(0); // Framed connection timeouts are set per-stream. FramedConnection framedConnection = new FramedConnection.Builder(true) .socket(socket, route.address().url().host(), source, sink) .protocol(protocol) .listener(this) .build(); framedConnection.start(); // Only assign the framed connection once the preface has been sent successfully. this.allocationLimit = framedConnection.maxConcurrentStreams(); this.framedConnection = framedConnection; &#125; else &#123; this.allocationLimit = 1; &#125;&#125; CallServerInterceptor到了 就是最后一个拦截器，这里包括了 发送请求，和返回最终的 response1234567891011121314151617181920212223242526272829303132333435363738394041424344@Override public Response intercept(Chain chain) throws IOException &#123; HttpStream httpStream = ((RealInterceptorChain) chain).httpStream(); StreamAllocation streamAllocation = ((RealInterceptorChain) chain).streamAllocation(); Request request = chain.request(); long sentRequestMillis = System.currentTimeMillis(); //写入http 头，两个httpStream具体实现不一样 不过都交给 okio来处理 httpStream.writeRequestHeaders(request); if (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != null) &#123; Sink requestBodyOut = httpStream.createRequestBody(request, request.body().contentLength()); BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut); request.body().writeTo(bufferedRequestBody); bufferedRequestBody.close(); &#125; //完成请求 httpStream.finishRequest(); //读取响应头 Response response = httpStream.readResponseHeaders() .request(request) .handshake(streamAllocation.connection().handshake()) .sentRequestAtMillis(sentRequestMillis) .receivedResponseAtMillis(System.currentTimeMillis()) .build(); //读取响应body if (!forWebSocket || response.code() != 101) &#123; response = response.newBuilder() .body(httpStream.openResponseBody(response)) .build(); &#125; if (\"close\".equalsIgnoreCase(response.request().header(\"Connection\")) || \"close\".equalsIgnoreCase(response.header(\"Connection\"))) &#123; streamAllocation.noNewStreams(); &#125; int code = response.code(); if ((code == 204 || code == 205) &amp;&amp; response.body().contentLength() &gt; 0) &#123; throw new ProtocolException( \"HTTP \" + code + \" had non-zero Content-Length: \" + response.body().contentLength()); &#125; return response; &#125; 这里就是先获取上个拦截器的连接，然后 获取到 上个拦截器的httpStream 里面不又生成的那些流吗，然后写入头，写入请求体，在读取头 读取体 ###好了，对于OKhttp就先分析这些了，写的像流水账一样","categories":[{"name":"Android","slug":"Android","permalink":"https://3431339973.github.io/categories/Android/"}],"tags":[{"name":"BridgeInterceptor","slug":"BridgeInterceptor","permalink":"https://3431339973.github.io/tags/BridgeInterceptor/"},{"name":"RetryAndFollowUpInterceptor","slug":"RetryAndFollowUpInterceptor","permalink":"https://3431339973.github.io/tags/RetryAndFollowUpInterceptor/"},{"name":"CacheInterceptor","slug":"CacheInterceptor","permalink":"https://3431339973.github.io/tags/CacheInterceptor/"},{"name":"ConnectInterceptor","slug":"ConnectInterceptor","permalink":"https://3431339973.github.io/tags/ConnectInterceptor/"},{"name":"CallServerInterceptor","slug":"CallServerInterceptor","permalink":"https://3431339973.github.io/tags/CallServerInterceptor/"}]},{"title":"Okhttp源码分析学习（1）请求流程","slug":"okhttp1","date":"2016-11-21T13:55:27.000Z","updated":"2017-10-21T13:02:57.923Z","comments":true,"path":"2016/11/21/okhttp1/","link":"","permalink":"https://3431339973.github.io/2016/11/21/okhttp1/","excerpt":"摘要:okhttp是安卓端最火热的轻量级框架,由移动支付Square公司贡献,用于替换api23以后被移除的HttpClient","text":"摘要:okhttp是安卓端最火热的轻量级框架,由移动支付Square公司贡献,用于替换api23以后被移除的HttpClient OkHttpClientOkHttpClient 看名字就这到这代表的就是http的客户端一般都会在个静态块里初始化,那就先来分析下 初始化 OkHttpClient 这里， 12345678910111213141516171819 static &#123; //设置超时 builder = new OkHttpClient.Builder() .connectTimeout(30, TimeUnit.SECONDS) .writeTimeout(30, TimeUnit.SECONDS) .readTimeout(30, TimeUnit.SECONDS) .addInterceptor(new Interceptor() &#123; @Override public Response intercept(Interceptor.Chain chain) throws IOException &#123; Request originalRequest = chain.request(); //请求拦截器 在每次 发起请求的时候 在拦截器里 可以 增加 消息头 Request authorised = originalRequest.newBuilder() .header(name, headerValue) .build(); return chain.proceed(authorised); &#125; &#125;); mOkHttpClient=builder.build();&#125; 首先构造一个 builder 1234567891011121314151617181920public Builder() &#123; dispatcher = new Dispatcher(); protocols = DEFAULT_PROTOCOLS; connectionSpecs = DEFAULT_CONNECTION_SPECS; proxySelector = ProxySelector.getDefault(); cookieJar = CookieJar.NO_COOKIES; socketFactory = SocketFactory.getDefault(); hostnameVerifier = OkHostnameVerifier.INSTANCE; certificatePinner = CertificatePinner.DEFAULT; proxyAuthenticator = Authenticator.NONE; authenticator = Authenticator.NONE; connectionPool = new ConnectionPool(); dns = Dns.SYSTEM; followSslRedirects = true; followRedirects = true; retryOnConnectionFailure = true; connectTimeout = 10_000; readTimeout = 10_000; writeTimeout = 10_000;&#125; 初始化一些值，重点新建了一个Dispatcher（分发器） 和一个 ConnectionPool（连接池） ，后面那些方法 其实就是设置初始化的这些值，最后等到一个 builder对象 调用build（）；获得当前对象 这好像没啥可说的 哈哈哈哈哈123public OkHttpClient build() &#123; return new OkHttpClient(this); &#125; Request创建完OkHttpClient 客户端，接下来初始化请求对象 Request123456789101112131415161718192021222324252627requestBuilder=new Request.Builder().url(baseUrl+url); formBodyBuilder = new FormBody.Builder();formBodyBuilder.add(name,value); public Builder() &#123; this.method = \"GET\"; this.headers = new Headers.Builder(); &#125; public static final class Builder &#123; private final List&lt;String&gt; names = new ArrayList&lt;&gt;(); private final List&lt;String&gt; values = new ArrayList&lt;&gt;(); public Builder add(String name, String value) &#123; names.add(HttpUrl.canonicalize(name, FORM_ENCODE_SET, false, false, true, true)); values.add(HttpUrl.canonicalize(value, FORM_ENCODE_SET, false, false, true, true)); return this; &#125; public Builder addEncoded(String name, String value) &#123; names.add(HttpUrl.canonicalize(name, FORM_ENCODE_SET, true, false, true, true)); values.add(HttpUrl.canonicalize(value, FORM_ENCODE_SET, true, false, true, true)); return this; &#125; public FormBody build() &#123; return new FormBody(names, values); &#125; 构建了 request 和formbody 这里其实可以设置参数 同步发送请求 mOkHttpClient.newCall(request).execute(); 123Request request = requestBuilder.post(formBodyBuilder.build()).build(); Response response = mOkHttpClient.newCall(request).execute(); Request 的build就不看了啊直接看发送请求的方法通过newCall 可以看到 这里new 了一个RealCall 然后调用了 在他的构造方法里创建了一个 RetryAndFollowUpInterceptor （重试连接拦截器） 他的execute(）方法，那看一下execute(） 方法 Dispatcher123456789101112131415@Override public Response execute() throws IOException &#123; synchronized (this) &#123; //这里又个判断 没有Call智能执行一次 如果第二次进来会报错 if (executed) throw new IllegalStateException(\"Already Executed\"); executed = true; &#125; try &#123; client.dispatcher().executed(this); Response result = getResponseWithInterceptorChain(); if (result == null) throw new IOException(\"Canceled\"); return result; &#125; finally &#123; client.dispatcher().finished(this); &#125;&#125; 可以看到 关键的又3句client.dispatcher().executed(this);getResponseWithInterceptorChain(); client.dispatcher().finished(this);咱们一句一句看啊dispatcher 咱们之前说了 是在OkHttpClient 初始化的时候创建的，看名字 他肯定是个分发器，分发什么，咱们分析的是个网络请求框架，肯定分发请求没，点进去executed 方法看看。 1234/** Used by &#123;@code Call#execute&#125; to signal it is in-flight. */synchronized void executed(RealCall call) &#123; runningSyncCalls.add(call);&#125; 这是往一个同步的队列里放了一个回调对象 看看这队列是啥，这个类里面没那么多属性就一起看看吧. 1234567891011121314151617public final class Dispatcher &#123; private int maxRequests = 64; private int maxRequestsPerHost = 5; private Runnable idleCallback; /** Executes calls. Created lazily. */ private ExecutorService executorService; /** Ready async calls in the order they'll be run. */ private final Deque&lt;AsyncCall&gt; readyAsyncCalls = new ArrayDeque&lt;&gt;(); /** Running asynchronous calls. Includes canceled calls that haven't finished yet. */ private final Deque&lt;AsyncCall&gt; runningAsyncCalls = new ArrayDeque&lt;&gt;(); /** Running synchronous calls. Includes canceled calls that haven't finished yet. */ private final Deque&lt;RealCall&gt; runningSyncCalls = new ArrayDeque&lt;&gt;(); 一看ExecutorService 就知道 这里肯定用到了线程池，在看看3个队列 两个异步一个同步的 ，现在猜测线程池可能是 异步请求用的咱们先不看，现在怎们明确了 如果同步请求 我们是吧请求回调放到了一队列里处理。 再看getResponseWithInterceptorChain 方法，重点来了 getResponseWithInterceptorChain123456789101112131415161718private Response getResponseWithInterceptorChain() throws IOException &#123; // Build a full stack of interceptors. List&lt;Interceptor&gt; interceptors = new ArrayList&lt;&gt;(); interceptors.addAll(client.interceptors()); interceptors.add(retryAndFollowUpInterceptor); interceptors.add(new BridgeInterceptor(client.cookieJar())); interceptors.add(new CacheInterceptor(client.internalCache())); interceptors.add(new ConnectInterceptor(client)); if (!retryAndFollowUpInterceptor.isForWebSocket()) &#123; interceptors.addAll(client.networkInterceptors()); &#125; interceptors.add(new CallServerInterceptor( retryAndFollowUpInterceptor.isForWebSocket())); Interceptor.Chain chain = new RealInterceptorChain( interceptors, null, null, null, 0, originalRequest); return chain.proceed(originalRequest);&#125; 先获取咱们之前自己配置的拦截器，如果没配置 咱们先忽略，然后又继续添加拦截器retryAndFollowUpInterceptor是在 RealCall 创建的时候 创建的 然后 又创建了BridgeInterceptor 看参数 应该根cookie有关，然后是CacheInterceptor 一看就是缓存相关的，然后是ConnectInterceptor 连接相关 networkInterceptors 先忽略，最后又放了个 CallServerInterceptor 拦截器，这么多拦截器组装成了一个 list,接下来新建了一个 RealInterceptorChain（拦截器链）对象 ，并调用了 他的proceed 方法， 1234567891011121314151617181920212223242526272829303132333435363738394041@Override public Response proceed(Request request) throws IOException &#123; return proceed(request, streamAllocation, httpStream, connection); &#125; public Response proceed(Request request, StreamAllocation streamAllocation, HttpStream httpStream, Connection connection) throws IOException &#123; if (index &gt;= interceptors.size()) throw new AssertionError(); calls++; // If we already have a stream, confirm that the incoming request will use it. if (this.httpStream != null &amp;&amp; !sameConnection(request.url())) &#123; throw new IllegalStateException(\"network interceptor \" + interceptors.get(index - 1) + \" must retain the same host and port\"); &#125; // If we already have a stream, confirm that this is the only call to chain.proceed(). if (this.httpStream != null &amp;&amp; calls &gt; 1) &#123; throw new IllegalStateException(\"network interceptor \" + interceptors.get(index - 1) + \" must call proceed() exactly once\"); &#125; // Call the next interceptor in the chain. RealInterceptorChain next = new RealInterceptorChain( interceptors, streamAllocation, httpStream, connection, index + 1, request); Interceptor interceptor = interceptors.get(index); Response response = interceptor.intercept(next); // Confirm that the next interceptor made its required call to chain.proceed(). if (httpStream != null &amp;&amp; index + 1 &lt; interceptors.size() &amp;&amp; next.calls != 1) &#123; throw new IllegalStateException(\"network interceptor \" + interceptor + \" must call proceed() exactly once\"); &#125; // Confirm that the intercepted response isn't null. if (response == null) &#123; throw new NullPointerException(\"interceptor \" + interceptor + \" returned null\"); &#125; return response; &#125; 看到 这个方法里面 又创建了一个 RealInterceptorChain ，然后调用了 拦截器的intercept 拦截器，返回了一个Response对象， 咱们随便点开一个框架里的拦截器，看一下 他的interceptor 方法，例如BridgeInterceptor 我们看到 这个方法里面调用了刚才 传入的 RealInterceptorChain 的proceed 方法，嗯？这不又回到了RealInterceptorChain 的proceed 方法。配合这个RealInterceptorChain 在 创建的时候 传入了一个index+1 我感觉，这里不简单，在看看其他的，都调用了proceed方法 ，在看看 我们自定义的拦截器，也是在 return了RealInterceptorChain 的proceed，原来是这样啊，这叫啥，递归吗。通过这种递归的方式，依次的先调用了我们自己的拦截器 ，然后又调用了框架里写好的这几个拦截器。关于这些拦截器.单独开一个博客在说，继续往下看 getResponseWithInterceptorChain后调用了client.dispatcher().finished(this);而且是在finally 里面 client.dispatcher().finished(this)； 这一看名字就知道 是请求完成的意思 1234567891011121314private &lt;T&gt; void finished(Deque&lt;T&gt; calls, T call, boolean promoteCalls) &#123; int runningCallsCount; Runnable idleCallback; synchronized (this) &#123; if (!calls.remove(call)) throw new AssertionError(\"Call wasn't in-flight!\"); if (promoteCalls) promoteCalls(); runningCallsCount = runningCallsCount(); idleCallback = this.idleCallback; &#125; if (runningCallsCount == 0 &amp;&amp; idleCallback != null) &#123; idleCallback.run(); &#125;&#125; 其实就是删除 队列里的Call; 发送异步请求 发送异步请求根 同步前面差不多 差距是 调用了dispatcher().enqueue方法 1234567@Override public void enqueue(Callback responseCallback) &#123; synchronized (this) &#123; if (executed) throw new IllegalStateException(\"Already Executed\"); executed = true; &#125; client.dispatcher().enqueue(new AsyncCall(responseCallback)); &#125; client.dispatcher().enqueue(new AsyncCall(responseCallback)); 12345678synchronized void enqueue(AsyncCall call) &#123; if (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123; runningAsyncCalls.add(call); executorService().execute(call); &#125; else &#123; readyAsyncCalls.add(call); &#125; &#125; 这里判断了一下 如果 默认当前最大的Requests的请求不超过64，并且访问当前host的请求不超过5个 （maxRequests 和maxRequestsPerHost 可以修改），就把call放到当前运行的队列，并且执行线程池，否者放到准备队列里去。 AsyncCall AsyncCall 实现了 NamedRunnable 其实就是Runnable 只不过给当前线程起了名字 12345678910111213141516171819202122/** * Runnable implementation which always sets its thread name. */public abstract class NamedRunnable implements Runnable &#123; protected final String name; public NamedRunnable(String format, Object... args) &#123; this.name = Util.format(format, args); &#125; @Override public final void run() &#123; String oldName = Thread.currentThread().getName(); Thread.currentThread().setName(name); try &#123; execute(); &#125; finally &#123; Thread.currentThread().setName(oldName); &#125; &#125; protected abstract void execute();&#125; 可以看到 在run函数里 调用了 execute 12345678910111213141516171819202122232425@Override protected void execute() &#123; boolean signalledCallback = false; try &#123; Response response = getResponseWithInterceptorChain(); if (retryAndFollowUpInterceptor.isCanceled()) &#123; signalledCallback = true; responseCallback.onFailure(RealCall.this, new IOException(\"Canceled\")); &#125; else &#123; signalledCallback = true; //返回response responseCallback.onResponse(RealCall.this, response); &#125; &#125; catch (IOException e) &#123; if (signalledCallback) &#123; // Do not signal the callback twice! Platform.get().log(INFO, \"Callback failure for \" + toLoggableString(), e); &#125; else &#123; responseCallback.onFailure(RealCall.this, e); &#125; &#125; finally &#123; //移除队列里的 回调 client.dispatcher().finished(this); &#125;&#125; 呵呵 一点开 我就看到了 getResponseWithInterceptorChain，后面我也不打算看了 无非就是 调用回调方法 返回response，然后移除队列里的 Call. 整体流程我们就分析晚，如果没事，明天分下下 那几个拦截器，BridgeInterceptor，CacheInterceptor，ConnectInterceptor，CallServerInterceptor。","categories":[{"name":"Android","slug":"Android","permalink":"https://3431339973.github.io/categories/Android/"}],"tags":[{"name":"Android","slug":"Android","permalink":"https://3431339973.github.io/tags/Android/"},{"name":"Okhttp","slug":"Okhttp","permalink":"https://3431339973.github.io/tags/Okhttp/"},{"name":"源码解析","slug":"源码解析","permalink":"https://3431339973.github.io/tags/源码解析/"}]},{"title":"腾讯 IM 封装成Library","slug":"腾讯IM封装 ShIMLibrary","date":"2016-09-18T14:37:23.000Z","updated":"2017-10-01T12:47:02.213Z","comments":true,"path":"2016/09/18/腾讯IM封装 ShIMLibrary/","link":"","permalink":"https://3431339973.github.io/2016/09/18/腾讯IM封装 ShIMLibrary/","excerpt":"把腾讯 IM 封装成Library","text":"把腾讯 IM 封装成Library IM_Demo把腾讯 IM 封装成Library依照Demo主项目 先到腾讯IM 管理平台创建应用 传送门 1.导入JrImLibrary 2.复制 主项目下im 下面的三个类 3.在Application 中初始化IM模块 4.替换string.xml 下面的 sdk_appid 和 account_type 5.还有部分功能 没有实现 例如 上传图片，和搜索用户（考虑在主项目里实现） 6.服务器端 签名生成 JAVA 代码 [下载地址] (https://github.com/hui46226021/ShIMLibrary/raw/master/java_native.rar) 源码地址:https://github.com/hui46226021/ShIMLibrary","categories":[{"name":"Android","slug":"Android","permalink":"https://3431339973.github.io/categories/Android/"}],"tags":[{"name":"移动开发","slug":"移动开发","permalink":"https://3431339973.github.io/tags/移动开发/"},{"name":"原创","slug":"原创","permalink":"https://3431339973.github.io/tags/原创/"},{"name":"即时通讯","slug":"即时通讯","permalink":"https://3431339973.github.io/tags/即时通讯/"},{"name":"腾讯IM","slug":"腾讯IM","permalink":"https://3431339973.github.io/tags/腾讯IM/"}]},{"title":"Android JSON解析工具ShJsonUtils","slug":"JSON解析","date":"2016-07-20T13:37:23.000Z","updated":"2017-10-02T16:51:17.170Z","comments":true,"path":"2016/07/20/JSON解析/","link":"","permalink":"https://3431339973.github.io/2016/07/20/JSON解析/","excerpt":"摘要:封装了一个 json解析的库","text":"摘要:封装了一个 json解析的库 ShJsonUtilsandroid json解析框架Download the latest JAR or grab via Maven:123456&lt;dependency&gt; &lt;groupId&gt;com.sh.zsh.code&lt;/groupId&gt; &lt;artifactId&gt;shjson&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt;&lt;/dependency&gt; or Gradle:1compile 'com.sh.zsh.code:shjson:1.2.3' #使用方法123456789JSONUtil jsonUtil = new JSONUtil(jsonStr);//二维数组List&lt;People&gt; peoples =jsonUtil.getList(People.class,\"people\",Look.class);//三维数组List&lt;People&gt; peoples =jsonUtil.getList(People.class,\"people\",Look.class,En.class);List&lt;People&gt; peoples2 =jsonUtil.getList(People.class,\"data.people\");String animal = jsonUtil.getObject(String.class,\"data.animal\");Look look = jsonUtil.getObject(Look.class,\"data.look\"); 创建 JSONUtil 对象，传入json字符串 通过getObject方法 获取 实体对象 ，层级用.隔开 通过getList方法 获取 数组对象 ，层级用.隔开 源码地址：https://github.com/hui46226021/ShJsonUtils","categories":[{"name":"Android","slug":"Android","permalink":"https://3431339973.github.io/categories/Android/"}],"tags":[{"name":"移动开发","slug":"移动开发","permalink":"https://3431339973.github.io/tags/移动开发/"},{"name":"原创","slug":"原创","permalink":"https://3431339973.github.io/tags/原创/"},{"name":"JSON解析","slug":"JSON解析","permalink":"https://3431339973.github.io/tags/JSON解析/"}]},{"title":"Android 仿微信 相册多图选择器","slug":"Android 仿微信 相册多图选择器","date":"2016-07-01T14:37:23.000Z","updated":"2017-10-01T12:47:44.779Z","comments":true,"path":"2016/07/01/Android 仿微信 相册多图选择器/","link":"","permalink":"https://3431339973.github.io/2016/07/01/Android 仿微信 相册多图选择器/","excerpt":"摘要:公司需要多图选择并上传，自己实现了一个并 封装成 Library，方便以后使用","text":"摘要:公司需要多图选择并上传，自己实现了一个并 封装成 Library，方便以后使用 下载方式123456&lt;dependency&gt; &lt;groupId&gt;com.sh.zsh.code&lt;/groupId&gt; &lt;artifactId&gt;shphotoselectorlibrary&lt;/artifactId&gt; &lt;version&gt;2.0.9&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt;&lt;/dependency&gt; or Gradle:1compile 'com.sh.zsh.code:shphotoselectorlibrary:2.0.9' 该项目依赖 Glide:3.7.0 如果有冲突 可以 修改主项目里的依赖 或者 直接导入Library 跳转到 图片选择器页面123456789101112public static final int IMGSACTIVITY_REQUEST = 10001; public void chise(View v) &#123; Intent intent = new Intent(); //可选择图片的最大数量 intent.putExtra(PhotoActivity.IMAGE_COUNT,9); //顶部Toolbar栏背景颜色 intent.putExtra(PhotoActivity.BAR_COLORS,R.color.colorPrimary); intent.setClass(this,PhotoActivity.class); startActivityForResult(intent,IMGSACTIVITY_REQUEST); &#125; 在Activity的回调里获取到 所有选择的图片地址123456789101112131415@Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; if (requestCode == IMGSACTIVITY_REQUEST &amp;&amp; resultCode == RESULT_OK) &#123; Bundle bundle = data.getExtras(); if (bundle != null) &#123; if (bundle.getStringArrayList(\"files\") != null) &#123; listfile = bundle.getStringArrayList(\"files\"); listView.setVisibility(View.VISIBLE); ArrayAdapter&lt;String&gt; arryAdapter = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_list_item_1, listfile); listView.setAdapter(arryAdapter); &#125; &#125; &#125; &#125; 效果 源码地址：https://github.com/hui46226021/ShPhotoSelector","categories":[{"name":"Android","slug":"Android","permalink":"https://3431339973.github.io/categories/Android/"}],"tags":[{"name":"相册","slug":"相册","permalink":"https://3431339973.github.io/tags/相册/"},{"name":"微信","slug":"微信","permalink":"https://3431339973.github.io/tags/微信/"},{"name":"移动开发","slug":"移动开发","permalink":"https://3431339973.github.io/tags/移动开发/"},{"name":"原创","slug":"原创","permalink":"https://3431339973.github.io/tags/原创/"},{"name":"多图选择","slug":"多图选择","permalink":"https://3431339973.github.io/tags/多图选择/"}]},{"title":"ShVideoPlay android视频播放器","slug":"ShVideoPlay android视频播放器","date":"2016-05-18T14:37:23.000Z","updated":"2017-10-01T12:50:41.888Z","comments":true,"path":"2016/05/18/ShVideoPlay android视频播放器/","link":"","permalink":"https://3431339973.github.io/2016/05/18/ShVideoPlay android视频播放器/","excerpt":"摘要：Android 视频播放器","text":"摘要：Android 视频播放器 ShVideoPlayandroid 视频播放封装Download the latest JAR or grab via Maven:123456&lt;dependency&gt; &lt;groupId&gt;com.sh.zsh.code&lt;/groupId&gt; &lt;artifactId&gt;shvideoplayer&lt;/artifactId&gt; &lt;version&gt;1.0.2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt;&lt;/dependency&gt; or Gradle:1compile 'com.sh.zsh.code:shvideoplayer:1.0.2' 源码地址:https://github.com/hui46226021/ShVideoPlay","categories":[{"name":"Android","slug":"Android","permalink":"https://3431339973.github.io/categories/Android/"}],"tags":[{"name":"移动开发","slug":"移动开发","permalink":"https://3431339973.github.io/tags/移动开发/"},{"name":"原创","slug":"原创","permalink":"https://3431339973.github.io/tags/原创/"},{"name":"视频播放","slug":"视频播放","permalink":"https://3431339973.github.io/tags/视频播放/"}]},{"title":"Android Library项目发布到JCenter最简单的配置方法","slug":"JCenter","date":"2016-05-15T04:32:21.000Z","updated":"2017-10-02T16:30:16.186Z","comments":true,"path":"2016/05/15/JCenter/","link":"","permalink":"https://3431339973.github.io/2016/05/15/JCenter/","excerpt":"为了方便 需要把jar发布到Maven服务器网上的步骤看起来实在太麻烦，gituhb上偶然间看到的一个项目，经过实际验证确实可行。github连接：https://github.com/xiaopansky/android-library-publish-to-jcenter 这是一个帮助Android开发者将aar发布到jcenter的项目，这个项目已经将需要写的脚本封装好了，我们只需要配置相关属性即可在5分钟之内发布我们的项目到JCenter 先看一下上传过程图解","text":"为了方便 需要把jar发布到Maven服务器网上的步骤看起来实在太麻烦，gituhb上偶然间看到的一个项目，经过实际验证确实可行。github连接：https://github.com/xiaopansky/android-library-publish-to-jcenter 这是一个帮助Android开发者将aar发布到jcenter的项目，这个项目已经将需要写的脚本封装好了，我们只需要配置相关属性即可在5分钟之内发布我们的项目到JCenter 先看一下上传过程图解 步骤1. 注册Bintray账号 ([传送门(https://bintray.com))Bintray是jcenter的托管商，因此你必须注册一个Bintray账号，注册完账号后记下你的用户名以及API Key。 登陆后在首页右上角点击用户名进入个人主页，然后点击用户名下面的Edit进入个人信息编辑页面，接下来点击页面左边列表的最后一项API Key 如图所示点击最右边箭头指示的复制按钮即可复制你的API Key 注册得时候要注意 这里有两个坑有两个注册 入口 要选上面得那个 否者最后会创建不了项目 报HTTP/1.1 404 Not Found 得错误 1 注册时，不少邮箱地址还不支持，要注意。 2 创建仓库时，如果使用Bintray-release,名字就填成maven,因为他的wiki:repoName: The repository name. Set to ‘maven’ by default.(有错误请指出) 这里写图片描述 Finally，坑了我一天之后，终于BUILD SUCCESSFUL了 检查Android插件版本 首先你要检查你的Android插件的版本，因为1.1.0版本有一个BUG会导致生成javadoc失败，所以你只需升级到最新即可。目前最新版本是1.3.0，在项目根目录下的build.gradle文件中修改版本号即可，如下: 复制代码123456789101112131415161718// Top-level build file where you can add configuration options common to all sub-projects/modules.buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:1.3.0' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125;&#125;allprojects &#123; repositories &#123; jcenter() &#125;&#125; 如果你在看到这篇文章的时候有更新的版本的话，直接改为最新的版本即可。 添加所需插件 在项目根目录下build.gradle文件中的dependencies节点中追加如下代码：12classpath 'com.github.dcendents:android-maven-gradle-plugin:1.3'classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.0' android-maven-gradle-plugin插件是用来打包Maven所需文件的 gradle-bintray-plugin插件是用来将生成的Maven所需文件上传到Bintray的 完成后如下所示： 123456789101112131415161718192021// Top-level build file where you can add configuration options common to all sub-projects/modules.buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:1.3.0' classpath 'com.github.dcendents:android-maven-gradle-plugin:1.3' classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.0' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125;&#125;allprojects &#123; repositories &#123; jcenter() &#125;&#125; 配置项目信息 下载project.properties文件并放到你的library module目录下 project.properties文件的原始内容如下： 1234567891011#projectproject.name=project.groupId=project.artifactId=project.packaging=aarproject.siteUrl=project.gitUrl=#javadocjavadoc.name= 详解： project.name：项目名称 project.groupId：项目组ID，通常情况下如果你的包名为com.example.test，那么项目组ID就是com.example project.artifactId：项目ID，通常情况下如果你的包名为com.example.test，那么项目ID就是test project.packaging：包类型，Android库是aar project.siteUrl：项目官方网站的地址，没有的话就用Github上的地址，例如：https://github.com/xiaopansky/Sketch project.gitUrl：项目的Git地址，例如：https://github.com/xiaopansky/Sketch.git javadoc.name：生成的javadoc打开后主页显示的名称，通常跟项目名称一样即可完成配置后如下所示： 1234567891011#projectproject.name=Sketchproject.groupId=me.xiaopanproject.artifactId=sketchproject.packaging=aarproject.siteUrl=https://github.com/xiaopansky/Sketchproject.gitUrl=https://github.com/xiaopansky/Sketch.git#javadocjavadoc.name=Sketch 配置Bintray账号以及开发者信息 下载local.properties文件并放到你的library module目录下 local.properties文件的原始内容如下： 12345678#bintraybintray.user=bintray.apikey=#developerdeveloper.id=developer.name=developer.email= 详解： bintray.user：你的Bintray的用户名 bintray.apikey：你的的Bintray的API Key developer.id：通常是你在开源社区的昵称 developer.name：你的姓名 developer.email：你的邮箱完成配置后如下所示： 123456789#bintraybintray.user=xiaopanskybintray.apikey=*****************************#developerdeveloper.id=xiaopandeveloper.name=********developer.email=sky@xiaopan.me *号显示的为个人信息不反方便透露，还请见谅 注意要将local.proerties文件加入忽略列表，以免被提交到Github或其他网站泄露个人信息 配置bintrayUpload.gradle 方法1：直接使用远程bintrayUpload.gradle文件 修改你的library module的build.gradle文件，在最后加上apply from: “https://raw.githubusercontent.com/xiaopansky/android-library-publish-to-jcenter/master/bintrayUpload.gradle&quot;，如下所示： 1234567891011121314151617181920212223apply plugin: 'com.android.library'android &#123; compileSdkVersion 22 buildToolsVersion \"22.0.0\" defaultConfig &#123; minSdkVersion 7 targetSdkVersion 22 versionCode 100 versionName \"1.0.0\" &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125;&#125;apply from: \"https://raw.githubusercontent.com/xiaopansky/android-library-publish-to-jcenter/master/bintrayUpload.gradle\" 方法2：下载后使用本地bintrayUpload.gradle文件 首先下载bintrayUpload.gradle文件并放到你的library module目录下 然后修改你的library module的build.gradle文件，在最后加上apply from: “bintrayUpload.gradle”，如下所示： 1234567891011121314151617181920212223apply plugin: 'com.android.library'android &#123; compileSdkVersion 22 buildToolsVersion \"22.0.0\" defaultConfig &#123; minSdkVersion 7 targetSdkVersion 22 versionCode 100 versionName \"1.0.0\" &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125;&#125;apply from: \"bintrayUpload.gradle\" 推荐大家使用第一种方案，简单快捷，至此配置工作已全部结束 执行命令打包并上传到Bintray 打开终端进入项目目录下， 执行 gradlew install 先编译一下 再执行gradlew bintrayUpload命令即可 另外，如果你的本地已经配置了Gradle了，那么执行gradle bintrayUpload命令也可以。gradlew是Gradle的一层封装，如果你本地没有安装Gradle gradlew就会自动下载Gradle 请求提交你的项目到jcenter 前面所有步骤走完之后实际上只是上传了你的项目到Bintray而已，并没有被包含在jcenter中，要想提交到jcenter中还需要Bintray的审核。 登入Bintray网站，进入个人中心，在右侧的Owned Repositories区域点击Maven的图标，进入你的Maven项目列表。 如果已经上传成功了，在这里就能看到你的项目，进入项目详情，在右下角的Linked To区域点击Add to JCenter，然后在Comments输入框里随便填写下信息，最后点Send提交请求即可 一般情况下审核需要4到5个小时，耐心等待就行了，审核通过后会给你发邮件通知你，并且以后更新项目就不需要再审核了。 一句话导入你的项目 当审核通过后，别人就可以一句话导入你的项目了，例如：1compile 'me.xiaopan:sketch:2.0.0' 额外补充： 保持你的library module的名字同artifactId一样 因为在Bintray上你的项目的maven-metadata.xml文件的路径是gruopId+”/“+module名称。 例如你的groupId是com.example，artifactId是test，但module名称是library。 这时候项目文件是在com.example.test目录下的，但maven-metadata.xml文件却是在com.example.library目录下的。 这样一来如果你有多个项目groupId一样，artifactId不一样，但module名称都是library的话，可能就会冲突。 目前为止我还没有找到更好的解决办法，就只能让module名称和artifactId保持一致，如果你们谁有更好的办法，欢迎留言交流。 参考文章 Android拓展系列(12)–使用Gradle发布aar项目到JCenter仓库使用Gradle发布Android开源项目到JCenterAndroid 项目打包到 JCenter 的坑 常见问题 Error:Cause: org/gradle/api/publication/maven/internal/DefaultMavenFactory：当你使用的Gradle版本是2.4以上，Android插件版本是1.3.0以上的时候就会出现这个问题，这时候你只需将android-maven-gradle-plugin插件版本改为classpath ‘com.github.dcendents:android-maven-gradle-plugin:1.3’即可You are using JDK version ‘java version “1.7.0_71”’. Some versions of JDK 1.7 (e.g. 1.7.0_10) may cause class loading errors in Gradle.Please update to a newer version (e.g. 1.7.0_67)：当你使用的Gradle版本是2.4以上，Andriod插件版本是1.2.3的时候就会出现这个问题，同样的你只需要将android-maven-gradle-plugin插件版本改为classpath ‘com.github.dcendents:android-maven-gradle-plugin:1.3’即可 以上文章转载：https://github.com/xiaopansky/android-library-publish-to-jcenter 关于jcenter和Maven Central的理解和gradle是如何从仓库上获取一个library 如果你想在Android Studio中引入一个library到你的项目，你只需添加如下的一行代码到模块的build.gradle文件中。123dependencies &#123; compile 'com.inthecheesefactory.thecheeselibrary:fb-like:0.9.3'&#125; 就是如此简单的一行代码，你就可以使用这个library了。 酷呆了。不过你可能很好奇Android Studio是从哪里得到这个library的。这篇文章将详细讲解这是怎么回事，包括如何把你的库发布出去分享给世界各地的其他开发者，这样不仅可以让世界更美好，还可以耍一次酷。 Android studio 是从哪里得到库的？先从这个简单的问题开始，我相信不是每个人都完全明白Android studio 是从哪里得到这些library的。莫非就是Android studio 从google搜索然后下载了一个合适的给我们？ 呵 呵，没那么复杂。Android Studio是从build.gradle里面定义的Maven 仓库服务器上下载library的。Apache Maven是Apache开发的一个工具，提供了用于贡献library的文件服务器。总的来说，只有两个标准的Android library文件服务 器：jcenter 和 Maven Central。 jcenterjcenter是一个由 bintray.com维护的Maven仓库 。你可以在这里看到整个仓库的内容。 我们在项目的build.gradle 文件中如下定义仓库，就能使用jcenter了：12345allprojects &#123; repositories &#123; jcenter() &#125;&#125; Maven CentralMaven Central 则是由sonatype.org维护的Maven仓库。你可以在这里看到整个仓库。 注：不管是jcenter还是Maven Central ，两者都是Maven仓库 我们在项目的build.gradle 文件中如下定义仓库，就能使用Maven Central了：12345allprojects &#123; repositories &#123; mavenCentral() &#125;&#125; 注意，虽然jcenter和Maven Central 都是标准的 android library仓库，但是它们维护在完全不同的服务器上，由不同的人提供内容，两者之间毫无关系。在jcenter上有的可能 Maven Central 上没有，反之亦然。 除了两个标准的服务器之外，如果我们使用的library的作者是把该library放在自己的服务器上，我们还可以自己定义特有的Maven仓库服务器。Twitter的Fabric.io 就是这种情况，它们在https://maven.fabric.io/public上维护了一个自己的Maven仓库。如果你想使用Fabric.io的library，你必须自己如下定义仓库的url。123repositories &#123; maven &#123; url 'https://maven.fabric.io/public' &#125;&#125; 然后在里面使用相同的方法获取一个library。 dependencies { compile ‘com.crashlytics.sdk.android:crashlytics:2.2.4@aar’}但是将library上传到标准的服务器与自建服务器，哪种方法更好呢？当然是前者。如果将我们的library公开，其他开发者除了一行定义依赖名的代码之外不需要定义任何东西。因此这篇文章中，我们将只关注对开发者更友好的jcenter 和 Maven Central 。 实际上可以在Android Studio上使用的除了Maven 仓库之外还有另外一种仓库：Ivy 仓库 。但是根据我的经验来看，我还没看到任何人用过它，包括我，因此本文就直接忽略了。 理解jcenter和Maven Central为何有两个标准的仓库？ 事实上两个仓库都具有相同的使命：提供Java或者Android library服务。上传到哪个（或者都上传）取决于开发者。 起初，Android Studio 选择Maven Central作为默认仓库。如果你使用老版本的Android Studio创建一个新项目，mavenCentral()会自动的定义在build.gradle中。 但 是Maven Central的最大问题是对开发者不够友好。上传library异常困难。上传上去的开发者都是某种程度的极客。同时还因为诸如安全方面的其他原 因，Android Studio团队决定把默认的仓库替换成jcenter。正如你看到的，一旦使用最新版本的Android Studio创建一个项目，jcenter()自动被定义，而不是mavenCentral()。 有许多将Maven Central替换成jcenter的理由，下面是几个主要的原因。 jcenter通过CDN发送library，开发者可以享受到更快的下载体验。 jcenter是全世界最大的Java仓库，因此在Maven Central 上有的，在jcenter上也极有可能有。换句话说jcenter是Maven Central的超集。 上传library到仓库很简单，不需要像在 Maven Central上做很多复杂的事情。 友好的用户界面 如果你想把library上传到 Maven Central ，你可以在bintray网站上直接点击一个按钮就能实现。 基于上面的原因以及我自己的经验，可以说替换到jcenter是明智之举。 所以我们这篇文章将把重心放在jcenter，反正如果你能成功把library放在jcenter，转到 Maven Central 是非常容易的事情。 gradle是如何从仓库上获取一个library的？在讨论如何上传library到jcenter之前，我们先看看gradle是如何从仓库获取library的。比如我们在 build.gradle输入如下代码的时候，这些库是如果奇迹般下载到我们的项目中的。1compile 'com.inthecheesefactory.thecheeselibrary:fb-like:0.9.3' 一般来说，我们需要知道library的字符串形式，包含3部分 GROUP_ID:ARTIFACT_ID:VERSION上面的例子中，GROUP_ID是com.inthecheesefactory.thecheeselibrary ，ARTIFACT_ID是fb-like，VERSION是0.9.3。 GROUP_ID 定义了library的group。有可能在同样的上下文中存在多个不同功能的library。如果library具有相同的group，那么它们将共享 一个GROUP_ID。通常我们以开发者包名紧跟着library的group名称来命名，比如com.squareup.picasso。然后 ARTIFACT_ID中是library的真实名称。至于VERSION，就是版本号而已，虽然可以是任意文字，但是我建议设置为x.y.z的形式，如 果喜欢还可以加上beta这样的后缀。 下面是Square library的一个例子。你可以看到每个都可以很容易的分辨出library和开发者的名称。 1234567dependencies &#123; compile 'com.squareup:otto:1.3.7' compile 'com.squareup.picasso:picasso:2.5.2' compile 'com.squareup.okhttp:okhttp:2.4.0' compile 'com.squareup.retrofit:retrofit:1.9.0'&#125; 那么在添加了上面的依赖之后会发生什么呢？简单。Gradle会询问Maven仓库服务器这个library是否存在，如果是，gradle会获得 请求library的路径，一般这个路径都是这样的形式：GROUP_ID/ARTIFACT_ID/VERSION_ID。比如可以在http://jcenter.bintray.com/com/squareup/otto/1.3.7 和 https://oss.sonatype.org/content/repositories/releases/com/squareup/otto/1.3.7/ 下获得com.squareup:otto:1.3.7的library文件。 然后Android Studio 将下载这些文件到我们的电脑上，与我们的项目一起编译。整个过程就是这么简单，一点都不复杂。 我 相信你应该清楚的知道从仓库上下载的library只是存储在仓库服务器上的jar 或者aar文件而已。有点类似于自己去下载这些文件，拷贝然后和项目 一起编译。但是使用gradle依赖管理的最大好处是你除了添加几行文字之外啥也不做。library一下子就可以在项目中使用了。 了解aar文件 等等，我刚才说了仓库中存储的有两种类型的library：jar 和 aar。jar文件大家都知道，但是什么是aar文件呢？ aar文件时在jar文件之上开发的。之所以有它是因为有些Android Library需要植入一些安卓特有的文件，比如AndroidManifest.xml，资源文件，Assets或者JNI。这些都不是jar文件的标准。 因此aar文件就时发明出来包含所有这些东西的。总的来说它和jar一样只是普通的zip文件，不过具有不同的文件结构。jar文件以classes.jar的名字被嵌入到aar文件中。其余的文件罗列如下： /AndroidManifest.xml (mandatory) /classes.jar (mandatory) /res/ (mandatory) /R.txt (mandatory) /assets/ (optional) /libs/*.jar (optional) /jni//*.so (optional) /proguard.txt (optional) /lint.jar (optional) 可以看到.aar文件是专门为安卓设计的。 以上转载：http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0623/3097.html 后记Gradle 2.4之后已经可以使用JitPack发布项目，这个用起来甚至比上述方法还要简单的多，感兴趣的可以了解一下。 JitPack官网：https://jitpack.io/相当方便","categories":[{"name":"Maven","slug":"Maven","permalink":"https://3431339973.github.io/categories/Maven/"}],"tags":[{"name":"移动开发","slug":"移动开发","permalink":"https://3431339973.github.io/tags/移动开发/"},{"name":"转贴","slug":"转贴","permalink":"https://3431339973.github.io/tags/转贴/"},{"name":"Maven","slug":"Maven","permalink":"https://3431339973.github.io/tags/Maven/"},{"name":"JCenter","slug":"JCenter","permalink":"https://3431339973.github.io/tags/JCenter/"}]},{"title":"关于一个Activity的视图加载","slug":"201604231","date":"2016-04-23T14:42:27.000Z","updated":"2017-10-04T15:09:37.017Z","comments":true,"path":"2016/04/23/201604231/","link":"","permalink":"https://3431339973.github.io/2016/04/23/201604231/","excerpt":"摘要:我们了解到activity是如何启动的，启动后下一步就应该是渲染activity的视图了，我们都知道一个activity张上面样子 取决于我们在onCreat方法了调用了setContentView，那我们来分析下他吧","text":"摘要:我们了解到activity是如何启动的，启动后下一步就应该是渲染activity的视图了，我们都知道一个activity张上面样子 取决于我们在onCreat方法了调用了setContentView，那我们来分析下他吧 setContentViewactivity里重载了很多个setContentView方法，我们只分析一个就行 12345678public void setContentView(View view) &#123; getWindow().setContentView(view); initWindowDecorActionBar();&#125;public Window getWindow() &#123; return mWindow;&#125; 可以看到 其实是调用了mWindow的setContentView 方法，window我们都知道，他是一个屏幕的最低层，那我们点进去接着往下看123456789101112public abstract class Window &#123;/** Flag for the \"options panel\" feature. This is enabled by default. */public static final int FEATURE_OPTIONS_PANEL = 0;/** Flag for the \"no title\" feature, turning off the title at the top * of the screen. */public static final int FEATURE_NO_TITLE = 1;/** Flag for the progress indicator feature */public static final int FEATURE_PROGRESS = 2;/** Flag for having an icon on the left side of th........ 咦，这window原来是个抽象类，那他到底是个什么类型，我们在回到activity看看他是如何初始化的。123456789101112131415161718192021final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, IVoiceInteractor voiceInteractor) &#123; attachBaseContext(context); mFragments.attachActivity(this, mContainer, null); //这里初始化了 window mWindow = PolicyManager.makeNewWindow(this); mWindow.setCallback(this); mWindow.setOnWindowDismissedCallback(this); mWindow.getLayoutInflater().setPrivateFactory(this); if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123; mWindow.setSoftInputMode(info.softInputMode); &#125; if (info.uiOptions != 0) &#123; mWindow.setUiOptions(info.uiOptions); &#125; Window是什么?该方法在ActivityThread的performLaunchActivity方法被调用，就是创建一个activity的方法。 这回找到了 mWindow 是如何初始化的，但是还是看不出他什么个什么 实例化对象，而且又出来一个新东西 PolicyManager.makeNewWindow(this);的PolicyManager 是个什么玩意？我没开一探究竟 \\frameworks\\base\\core\\java\\com\\android\\internal\\policy\\PolicyManager 123456789101112131415161718192021222324252627282930313233343536373839404142434445public final class PolicyManager &#123; //会通过这个 反射创建 IPolicy实例 private static final String POLICY_IMPL_CLASS_NAME = \"com.android.internal.policy.impl.Policy\"; private static final IPolicy sPolicy; static &#123; // Pull in the actual implementation of the policy at run-time try &#123; Class policyClass = Class.forName(POLICY_IMPL_CLASS_NAME); sPolicy = (IPolicy)policyClass.newInstance(); &#125; catch (ClassNotFoundException ex) &#123; throw new RuntimeException( POLICY_IMPL_CLASS_NAME + \" could not be loaded\", ex); &#125; catch (InstantiationException ex) &#123; throw new RuntimeException( POLICY_IMPL_CLASS_NAME + \" could not be instantiated\", ex); &#125; catch (IllegalAccessException ex) &#123; throw new RuntimeException( POLICY_IMPL_CLASS_NAME + \" could not be instantiated\", ex); &#125; &#125; // Cannot instantiate this class private PolicyManager() &#123;&#125; // The static methods to spawn new policy-specific objects public static Window makeNewWindow(Context context) &#123; return sPolicy.makeNewWindow(context); &#125; public static LayoutInflater makeNewLayoutInflater(Context context) &#123; return sPolicy.makeNewLayoutInflater(context); &#125; public static WindowManagerPolicy makeNewWindowManager() &#123; return sPolicy.makeNewWindowManager(); &#125; public static FallbackEventHandler makeNewFallbackEventHandler(Context context) &#123; return sPolicy.makeNewFallbackEventHandler(context); &#125;&#125; 嗯，这个类就这么几行代码 里面有个关键的东西sPolicy 继续走（注意：前方高能你将进入水下的冰山了）根据上面的 POLICY_IMPL_CLASS_NAME 获取到了Policy 我没来看一下他 12345678910111213141516171819202122232425262728293031323334353637383940public class Policy implements IPolicy &#123;private static final String TAG = \"PhonePolicy\";private static final String[] preload_classes = &#123; \"com.android.internal.policy.impl.PhoneLayoutInflater\", \"com.android.internal.policy.impl.PhoneWindow\", \"com.android.internal.policy.impl.PhoneWindow$1\", \"com.android.internal.policy.impl.PhoneWindow$DialogMenuCallback\", \"com.android.internal.policy.impl.PhoneWindow$DecorView\", \"com.android.internal.policy.impl.PhoneWindow$PanelFeatureState\", \"com.android.internal.policy.impl.PhoneWindow$PanelFeatureState$SavedState\",&#125;;static &#123; // For performance reasons, preload some policy specific classes when // the policy gets loaded. for (String s : preload_classes) &#123; try &#123; Class.forName(s); &#125; catch (ClassNotFoundException ex) &#123; Log.e(TAG, \"Could not preload class for phone policy: \" + s); &#125; &#125;&#125;//返回了 Windowpublic Window makeNewWindow(Context context) &#123; return new PhoneWindow(context);&#125;public LayoutInflater makeNewLayoutInflater(Context context) &#123; return new PhoneLayoutInflater(context);&#125;public WindowManagerPolicy makeNewWindowManager() &#123; return new PhoneWindowManager();&#125;public FallbackEventHandler makeNewFallbackEventHandler(Context context) &#123; return new PhoneFallbackEventHandler(context);&#125; 代码也不多 但是可以看到 makeNewWindow 里干了什么，他new 了一个 PhoneWindow 还有 makeNewWindowManager 里new 了一个PhoneWindowManager这下我们知道 activity里的getWindow 到底获取到了个 什么东西. 继续setContentView（windows的方法）刚才在看activity的时候已经知道 其setContentView方法 其实调用的window的setContentView方法 ，现在我们也知道了这个 window其实是一个 PhoneWindow,来上代码12345678910111213141516171819202122232425262728293031323334353637private DecorView mDecor; private ViewGroup mContentParent;private ViewGroup mContentRoot;@Overridepublic void setContentView(View view) &#123; setContentView(view, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));&#125;@Overridepublic void setContentView(View view, ViewGroup.LayoutParams params) &#123; // Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window // decor, when theme attributes and the like are crystalized. Do not check the feature // before this happens. //判断 mContentParent 没有则创建 if (mContentParent == null) &#123; installDecor(); &#125; else if (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; mContentParent.removeAllViews(); &#125; if (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123; view.setLayoutParams(params); final Scene newScene = new Scene(mContentParent, view); transitionTo(newScene); &#125; else &#123; //将传进来的view添加到 mContentParent mContentParent.addView(view, params); &#125; final Callback cb = getCallback(); if (cb != null &amp;&amp; !isDestroyed()) &#123; cb.onContentChanged(); &#125;&#125; 其实这里就干了两件事 判断 mContentParent 没有则创建 然后把传进来的view添加到 mContentParent 我们再来看看 installDecor 方法 123456789101112131415161718 private void installDecor() &#123; if (mDecor == null) &#123; //创建 DecorView mDecor = generateDecor(); mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS); mDecor.setIsRootNamespace(true); if (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != 0) &#123; mDecor.postOnAnimation(mInvalidatePanelMenuRunnable); &#125; &#125; if (mContentParent == null) &#123; //通过 DecorView 得到mContentParent mContentParent = generateLayout(mDecor); 。。。。。。。其他赋值操作 &#125;&#125; 继续看 generateDecor 和generateLayout 函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445//generateDecor 很简单 就是 new 了个DecorView protected DecorView generateDecor() &#123; return new DecorView(getContext(), -1);&#125; protected ViewGroup generateLayout(DecorView decor) &#123; // Apply data from current theme. TypedArray a = getWindowStyle(); if (false) &#123; System.out.println(\"From style:\"); String s = \"Attrs:\"; for (int i = 0; i &lt; R.styleable.Window.length; i++) &#123; s = s + \" \" + Integer.toHexString(R.styleable.Window[i]) + \"=\" + a.getString(i); &#125; System.out.println(s); &#125; mIsFloating = a.getBoolean(R.styleable.Window_windowIsFloating, false); int flagsToUpdate = (FLAG_LAYOUT_IN_SCREEN|FLAG_LAYOUT_INSET_DECOR) &amp; (~getForcedWindowFlags()); if (mIsFloating) &#123; setLayout(WRAP_CONTENT, WRAP_CONTENT); setFlags(0, flagsToUpdate); &#125; else &#123;.....一堆 赋值操作 mDecor.startChanging(); //标题栏 View in = mLayoutInflater.inflate(layoutResource, null); decor.addView(in, new ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT)); mContentRoot = (ViewGroup) in; //contentParent 由findViewById 返回 ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT); if (contentParent == null) &#123; throw new RuntimeException(\"Window couldn't find content container view\"); &#125;....... return contentParent;&#125; generateDecor 很简单 就是 new 了个DecorView ，而DecorView 实际上就是个 Framelayout.generateLayout 函数很长 差不多300多行 我们只挑重点的看 主要是给DecorView 添加了标题栏 通过findViewById 获取到 contentParent ，这个findViewById 其实是调用了DecorView的这个findViewById如图 总结 setContentView 其实是调用window的setContentView window 是通过PolicyManager 获取到的PhoneWindow对象 window 的setContentView 创建了DecorView （Framelayout） window 的setContentView 创建了DecorView 通过DecorView 创建了contentParent 把setContentView传过来的View add到contentParent 上 关于contentParent 的addView(view, params)方法下回再说吧，又该睡了","categories":[{"name":"Android","slug":"Android","permalink":"https://3431339973.github.io/categories/Android/"}],"tags":[{"name":"移动开发","slug":"移动开发","permalink":"https://3431339973.github.io/tags/移动开发/"},{"name":"Android","slug":"Android","permalink":"https://3431339973.github.io/tags/Android/"},{"name":"Surface","slug":"Surface","permalink":"https://3431339973.github.io/tags/Surface/"}]},{"title":"关于一个Activity的启动","slug":"201604221","date":"2016-04-22T15:37:23.000Z","updated":"2017-10-03T15:42:00.750Z","comments":true,"path":"2016/04/22/201604221/","link":"","permalink":"https://3431339973.github.io/2016/04/22/201604221/","excerpt":"摘要:写了两年android 每天都接触activity,activity的生命周期记得滚怪烂熟，那一个activity到底是怎么展示到屏幕上的那，最近打算认真看看这里面的故事。","text":"摘要:写了两年android 每天都接触activity,activity的生命周期记得滚怪烂熟，那一个activity到底是怎么展示到屏幕上的那，最近打算认真看看这里面的故事。 Surface不论是使用Skia绘制二维图像，还是使用OpenGl绘制三维图像，最终Application都要和Surface交互，Surface就像个画布，儿APP就在画布上作画。 创建一个ActivityActivityThread代码路径 frameworks\\base\\core\\java\\android\\app\\ActivityThread怎么创建一个Activity?如果了解android系统的启动过程， 应该知道 在zygote 在相应 ActivityManagerService 请求后 会创建一个子进程,这个进程就启动 ActivityThread 的main方法 在ActivityThread 里有个处理消息的方法 handleLaunchActivity 看名字 也应该知道 他是 处理 启动 Activity用的，他在 一个Handle 里被调用 或者 被 handleRelaunchActivity（重启）被调用，其实handleRelaunchActivity也是 在Handle 里被调用，这个Handle还调用了很多 例如handlePauseActivity，handleStopActivity，handleWindowVisibility123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229public void handleMessage(Message msg) &#123; if (DEBUG_MESSAGES) Slog.v(TAG, \"&gt;&gt;&gt; handling: \" + codeToString(msg.what)); switch (msg.what) &#123; case LAUNCH_ACTIVITY: &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityStart\"); final ActivityClientRecord r = (ActivityClientRecord) msg.obj; r.packageInfo = getPackageInfoNoCheck( r.activityInfo.applicationInfo, r.compatInfo); handleLaunchActivity(r, null); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125; break; case RELAUNCH_ACTIVITY: &#123; Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityRestart\"); ActivityClientRecord r = (ActivityClientRecord)msg.obj; handleRelaunchActivity(r); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); &#125; break; case PAUSE_ACTIVITY: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityPause\"); handlePauseActivity((IBinder)msg.obj, false, (msg.arg1&amp;1) != 0, msg.arg2, (msg.arg1&amp;2) != 0); maybeSnapshot(); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case PAUSE_ACTIVITY_FINISHING: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityPause\"); handlePauseActivity((IBinder)msg.obj, true, (msg.arg1&amp;1) != 0, msg.arg2, (msg.arg1&amp;1) != 0); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case STOP_ACTIVITY_SHOW: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityStop\"); handleStopActivity((IBinder)msg.obj, true, msg.arg2); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case STOP_ACTIVITY_HIDE: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityStop\"); handleStopActivity((IBinder)msg.obj, false, msg.arg2); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case SHOW_WINDOW: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityShowWindow\"); handleWindowVisibility((IBinder)msg.obj, true); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case HIDE_WINDOW: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityHideWindow\"); handleWindowVisibility((IBinder)msg.obj, false); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case RESUME_ACTIVITY: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityResume\"); handleResumeActivity((IBinder) msg.obj, true, msg.arg1 != 0, true); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case SEND_RESULT: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityDeliverResult\"); handleSendResult((ResultData)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case DESTROY_ACTIVITY: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityDestroy\"); handleDestroyActivity((IBinder)msg.obj, msg.arg1 != 0, msg.arg2, false); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case BIND_APPLICATION: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"bindApplication\"); AppBindData data = (AppBindData)msg.obj; handleBindApplication(data); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case EXIT_APPLICATION: if (mInitialApplication != null) &#123; mInitialApplication.onTerminate(); &#125; Looper.myLooper().quit(); break; case NEW_INTENT: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityNewIntent\"); handleNewIntent((NewIntentData)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case RECEIVER: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"broadcastReceiveComp\"); handleReceiver((ReceiverData)msg.obj); maybeSnapshot(); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case CREATE_SERVICE: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"serviceCreate\"); handleCreateService((CreateServiceData)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case BIND_SERVICE: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"serviceBind\"); handleBindService((BindServiceData)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case UNBIND_SERVICE: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"serviceUnbind\"); handleUnbindService((BindServiceData)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case SERVICE_ARGS: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"serviceStart\"); handleServiceArgs((ServiceArgsData)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case STOP_SERVICE: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"serviceStop\"); handleStopService((IBinder)msg.obj); maybeSnapshot(); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case CONFIGURATION_CHANGED: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"configChanged\"); mCurDefaultDisplayDpi = ((Configuration)msg.obj).densityDpi; handleConfigurationChanged((Configuration)msg.obj, null); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case CLEAN_UP_CONTEXT: ContextCleanupInfo cci = (ContextCleanupInfo)msg.obj; cci.context.performFinalCleanup(cci.who, cci.what); break; case GC_WHEN_IDLE: scheduleGcIdler(); break; case DUMP_SERVICE: handleDumpService((DumpComponentInfo)msg.obj); break; case LOW_MEMORY: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"lowMemory\"); handleLowMemory(); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case ACTIVITY_CONFIGURATION_CHANGED: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"activityConfigChanged\"); handleActivityConfigurationChanged((IBinder)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case PROFILER_CONTROL: handleProfilerControl(msg.arg1 != 0, (ProfilerInfo)msg.obj, msg.arg2); break; case CREATE_BACKUP_AGENT: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"backupCreateAgent\"); handleCreateBackupAgent((CreateBackupAgentData)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case DESTROY_BACKUP_AGENT: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"backupDestroyAgent\"); handleDestroyBackupAgent((CreateBackupAgentData)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case SUICIDE: Process.killProcess(Process.myPid()); break; case REMOVE_PROVIDER: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"providerRemove\"); completeRemoveProvider((ProviderRefCount)msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case ENABLE_JIT: ensureJitEnabled(); break; case DISPATCH_PACKAGE_BROADCAST: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"broadcastPackage\"); handleDispatchPackageBroadcast(msg.arg1, (String[])msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case SCHEDULE_CRASH: throw new RemoteServiceException((String)msg.obj); case DUMP_HEAP: handleDumpHeap(msg.arg1 != 0, (DumpHeapData)msg.obj); break; case DUMP_ACTIVITY: handleDumpActivity((DumpComponentInfo)msg.obj); break; case DUMP_PROVIDER: handleDumpProvider((DumpComponentInfo)msg.obj); break; case SLEEPING: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"sleeping\"); handleSleeping((IBinder)msg.obj, msg.arg1 != 0); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case SET_CORE_SETTINGS: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"setCoreSettings\"); handleSetCoreSettings((Bundle) msg.obj); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case UPDATE_PACKAGE_COMPATIBILITY_INFO: handleUpdatePackageCompatibilityInfo((UpdateCompatibilityData)msg.obj); break; case TRIM_MEMORY: Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"trimMemory\"); handleTrimMemory(msg.arg1); Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER); break; case UNSTABLE_PROVIDER_DIED: handleUnstableProviderDied((IBinder)msg.obj, false); break; case REQUEST_ASSIST_CONTEXT_EXTRAS: handleRequestAssistContextExtras((RequestAssistContextExtras)msg.obj); break; case TRANSLUCENT_CONVERSION_COMPLETE: handleTranslucentConversionComplete((IBinder)msg.obj, msg.arg1 == 1); break; case INSTALL_PROVIDER: handleInstallProvider((ProviderInfo) msg.obj); break; case ON_NEW_ACTIVITY_OPTIONS: Pair&lt;IBinder, ActivityOptions&gt; pair = (Pair&lt;IBinder, ActivityOptions&gt;) msg.obj; onNewActivityOptions(pair.first, pair.second); break; case CANCEL_VISIBLE_BEHIND: handleCancelVisibleBehind((IBinder) msg.obj); break; case BACKGROUND_VISIBLE_BEHIND_CHANGED: handleOnBackgroundVisibleBehindChanged((IBinder) msg.obj, msg.arg1 &gt; 0); break; case ENTER_ANIMATION_COMPLETE: handleEnterAnimationComplete((IBinder) msg.obj); break; &#125; if (DEBUG_MESSAGES) Slog.v(TAG, \"&lt;&lt;&lt; done: \" + codeToString(msg.what)); &#125; 贴了这么多代码 ，发现 其实这里也并不重要，知识接受到消息后根据不同的消息 来处理不同的请求。不过咱们要讨论的是Activity的启动，所以重点还是要看一下 handleLaunchActivity 方法，先上代码1234567891011121314151617181920212223242526272829private void handleLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; // If we are getting ready to gc after going to the background, well // we are back active so skip it. unscheduleGcIdler(); mSomeActivitiesChanged = true; if (r.profilerInfo != null) &#123; mProfiler.setProfiler(r.profilerInfo); mProfiler.startProfiling(); &#125; // Make sure we are running with the most recent config. handleConfigurationChanged(null, null); if (localLOGV) Slog.v( TAG, \"Handling launch of \" + r); // 第一步 这里返回了一个 activity对象 Activity a = performLaunchActivity(r, customIntent); if (a != null) &#123; r.createdConfig = new Configuration(mConfiguration); Bundle oldState = r.state; //如果不为空 就调用了handleResumeActivity 方法 handleResumeActivity(r.token, false, r.isForward, !r.activity.mFinished &amp;&amp; !r.startsNotResumed); 。。。。。。。。。。。。。。。 &#125; &#125;&#125; 在handleLaunchActivity 里做了两件大事 通过 performLaunchActivity 获取到了 一个 Activity 对象 就调用了handleResumeActivity 方法先分析下 performLaunchActivity 方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) &#123; // System.out.println(\"##### [\" + System.currentTimeMillis() + \"] ActivityThread.performLaunchActivity(\" + r + \")\"); ActivityInfo aInfo = r.activityInfo; if (r.packageInfo == null) &#123; r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo, Context.CONTEXT_INCLUDE_CODE); &#125; ComponentName component = r.intent.getComponent(); if (component == null) &#123; component = r.intent.resolveActivity( mInitialApplication.getPackageManager()); r.intent.setComponent(component); &#125; if (r.activityInfo.targetActivity != null) &#123; component = new ComponentName(r.activityInfo.packageName, r.activityInfo.targetActivity); &#125; //上部分 主要完成了一些准备工作 //下面开始 创建activity Activity activity = null; try &#123; java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); //通过 Intent 带过来的activity名字 和 类加载器 创建出了activity对象 activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) &#123; r.state.setClassLoader(cl); &#125; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(activity, e)) &#123; throw new RuntimeException( \"Unable to instantiate activity \" + component + \": \" + e.toString(), e); &#125; &#125; //接下来就是 设置activity的一些 属性的操作 例如某些状态 ，内部引用什么的 ，加载主题什么的 try &#123; Application app = r.packageInfo.makeApplication(false, mInstrumentation); if (localLOGV) Slog.v(TAG, \"Performing launch of \" + r); if (localLOGV) Slog.v( TAG, r + \": app=\" + app + \", appName=\" + app.getPackageName() + \", pkg=\" + r.packageInfo.getPackageName() + \", comp=\" + r.intent.getComponent().toShortString() + \", dir=\" + r.packageInfo.getAppDir()); if (activity != null) &#123; Context appContext = createBaseContextForActivity(r, activity); CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); if (DEBUG_CONFIGURATION) Slog.v(TAG, \"Launching activity \" + r.activityInfo.name + \" with config \" + config); activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.voiceInteractor); if (customIntent != null) &#123; activity.mIntent = customIntent; &#125; r.lastNonConfigurationInstances = null; activity.mStartedActivity = false; int theme = r.activityInfo.getThemeResource(); if (theme != 0) &#123; activity.setTheme(theme); &#125; activity.mCalled = false; //这里执行完 会调用 Activity 的OnCreate 方法 if (r.isPersistable()) &#123; mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnCreate(activity, r.state); &#125; if (!activity.mCalled) &#123; throw new SuperNotCalledException( \"Activity \" + r.intent.getComponent().toShortString() + \" did not call through to super.onCreate()\"); &#125; r.activity = activity; r.stopped = true; if (!r.activity.mFinished) &#123; activity.performStart(); r.stopped = false; &#125; if (!r.activity.mFinished) &#123; if (r.isPersistable()) &#123; if (r.state != null || r.persistentState != null) &#123; mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state, r.persistentState); &#125; &#125; else if (r.state != null) &#123; mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state); &#125; &#125; if (!r.activity.mFinished) &#123; activity.mCalled = false; if (r.isPersistable()) &#123; mInstrumentation.callActivityOnPostCreate(activity, r.state, r.persistentState); &#125; else &#123; mInstrumentation.callActivityOnPostCreate(activity, r.state); &#125; if (!activity.mCalled) &#123; throw new SuperNotCalledException( \"Activity \" + r.intent.getComponent().toShortString() + \" did not call through to super.onPostCreate()\"); &#125; &#125; &#125; r.paused = true; mActivities.put(r.token, r); &#125; catch (SuperNotCalledException e) &#123; throw e; &#125; catch (Exception e) &#123; if (!mInstrumentation.onException(activity, e)) &#123; throw new RuntimeException( \"Unable to start activity \" + component + \": \" + e.toString(), e); &#125; &#125; return activity; &#125; 总结一下 performLaunchActivity 通过intent 带过来的名字 通过反射 创建了activity对象 （**到墙上 ^_^*） 完成了 activity的一些属性赋值 通过mInstrumentation.callActivityOnCreate 调用了 activity的OnCreate 方法 就这样 activity 创建了 并且调用了其OnCreate方法，那么在OnCreate 方法里都干了什么，作为一个android开发者，你心里没电逼数吗？好吧，往下看 我们来分析下 handleResumeActivity 方法，不给我说你忘了，上面可刚刚说完 handleLaunchActivity 干的第二件大事就是 日了这家伙。 来来 关门放代码：123456789101112131415161718192021222324final void handleResumeActivity(IBinder token, boolean clearHide, boolean isForward, boolean reallyResume) &#123; // If we are getting ready to gc after going to the background, well // we are back active so skip it. 。。。。。。。。。。 if (r.window == null &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123; //通过activity获取到window对象 r.window = r.activity.getWindow(); //获取了DecorView View decor = r.window.getDecorView(); decor.setVisibility(View.INVISIBLE); //获取视图管理 ViewManager wm = a.getWindowManager(); WindowManager.LayoutParams l = r.window.getAttributes(); a.mDecor = decor; l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION; l.softInputMode |= forwardBit; //将DecorView 弄到了这里面 if (a.mVisibleFromClient) &#123; a.mWindowAdded = true; wm.addView(decor, l); &#125; 。。。。。。。。。。。。。。 &#125; 我们可以看到 window DecorView 方法 那他们是什么时候创建的呢，这些都是跟视图有关的东西，视图好想是在 activity的onCreat里 调用setContentView才有的，靠那还得回去 看activity的setContentView,哎，反正现在activity不都启动了吗。视图渲染就明天再说吧，洗洗睡了","categories":[{"name":"Android","slug":"Android","permalink":"https://3431339973.github.io/categories/Android/"}],"tags":[{"name":"移动开发","slug":"移动开发","permalink":"https://3431339973.github.io/tags/移动开发/"},{"name":"Android","slug":"Android","permalink":"https://3431339973.github.io/tags/Android/"},{"name":"Surface","slug":"Surface","permalink":"https://3431339973.github.io/tags/Surface/"}]},{"title":"Android系统启动流程","slug":"Android系统启动流程","date":"2016-04-21T14:37:23.000Z","updated":"2017-10-02T16:29:18.379Z","comments":true,"path":"2016/04/21/Android系统启动流程/","link":"","permalink":"https://3431339973.github.io/2016/04/21/Android系统启动流程/","excerpt":"摘要:梳理一下android系统的启动流程，从init进程 到java层面","text":"摘要:梳理一下android系统的启动流程，从init进程 到java层面 init是一个进程，做完android系统启动的第一个进程，同时也是linux内核启动的第一个进程，init进程在启动过程中起到了重要的责任。 init进程的工作 1.解析配置文件 在init进程中会解析两个配置文件，一个是init.rc, 另一个是 与硬件平台相关的 配置 2.解析Service 3.启动zygote 关于 zygotezygote本身是个Native程序。原名app_process ,该名字 在Android.mk中指定，运行在 该进程又将自己的 名字改成zygote，zygote 启动AppRuntime.在AppRuntime 中主要完成了3步 1.创建虚拟机 startVm 2.注册JNI函数 startReg 3.调用com.android.internal.os.Zygotelnit的main函数，正式让系统进入了java语言的世界 在Zygotelnit 的main函数中 1.建立IPC通信服务端 2.调用registerZygoteSocket ,通过这个函数他可以相应子孙后代的请求，预加载类和资源（预加载相当多的类 1000多个 想想 android启动为啥慢） 3.启动system_server 分裂出一个子进程（承担一部分责任，建立与Binder的链接，调用init1 和inti2来启动一些系统服务） 4.zygote完成创世纪调用下runSelectLoopMode 便睡了","categories":[{"name":"Android","slug":"Android","permalink":"https://3431339973.github.io/categories/Android/"}],"tags":[{"name":"移动开发","slug":"移动开发","permalink":"https://3431339973.github.io/tags/移动开发/"},{"name":"Android","slug":"Android","permalink":"https://3431339973.github.io/tags/Android/"},{"name":"系统","slug":"系统","permalink":"https://3431339973.github.io/tags/系统/"}]},{"title":"Android 动态加载技术  DexClassLoader和PathClassLoader","slug":"android动态加载","date":"2016-03-22T10:55:23.000Z","updated":"2017-10-02T16:24:29.160Z","comments":true,"path":"2016/03/22/android动态加载/","link":"","permalink":"https://3431339973.github.io/2016/03/22/android动态加载/","excerpt":"摘要:android的插件开发，例如主题APK AAPK去加载BAPK的资源，重点就是 在程序运行的时候，加载一些程序自身原本不存在的可执行文件并运行这些文件里的代码逻辑。设计的知识点主要是 andrond的动态加载技术，在这之前可以先了解下关于JAVA的类加载方面的知识传送门","text":"摘要:android的插件开发，例如主题APK AAPK去加载BAPK的资源，重点就是 在程序运行的时候，加载一些程序自身原本不存在的可执行文件并运行这些文件里的代码逻辑。设计的知识点主要是 andrond的动态加载技术，在这之前可以先了解下关于JAVA的类加载方面的知识传送门 Dalvik虚拟机如同其他Java虚拟机一样，在运行程序时首先需要将对应的类加载到内存中。而在Java标准的虚拟机中，类加载可以从class文件中读取，也可以是其他形式的二进制流，因此，我们常常利用这一点，在程序运行时手动加载Class，从而达到代码动态加载执行的目的，动态调用外部的Dex文件则是完全没有问题的。在APK文件中往往有一个或者多个Dex文件，我们写的每一句代码都会被编译到这些文件里面，Android应用运行的时候就是通过执行这些Dex文件完成应用的功能的。虽然一个APK一旦构建出来，我们是无法更换里面的Dex文件的，但是我们可以通过加载外部的Dex文件来实现动态加载，这个外部文件可以放在外部存储，或者从网络下载。 Android动态加载的大致过程无论上面的哪种动态加载，其实基本原理都是在程序运行时加载一些外部的可执行的文件，然后调用这些文件的某个方法执行业务逻辑。需要说明的是，因为文件是可执行的（so库或者dex包，也就是一种动态链接库），出于安全问题，Android并不允许直接加载手机外部存储这类noexec（不可执行）存储路径上的可执行文件。 对于这些外部的可执行文件，在Android应用中调用它们前，都要先把他们拷贝到data/packagename/内部储存文件路径，确保库不会被第三方应用恶意修改或拦截，然后再将他们加载到当前的运行环境并调用需要的方法执行相应的逻辑，从而实现动态调用。 动态加载的大致过程就是： 把可执行文件（dex/jar/apk）拷贝到应用APP内部存储； 加载可执行文件； 调用具体的方法执行业务逻辑； 遇到问题然而Dalvik虚拟机毕竟不算是标准的Java虚拟机，因此在类加载机制上，它们有相同的地方，也有不同之处。我们必须区别对待例如，在使用标准Java虚拟机时，我们经常自定义继承自ClassLoader的类加载器。然后通过defineClass方法来从一个二进制流中加载Class。然而，这在Android里是行不通的，大家就没必要走弯路了。参看源码我们知道，Android中ClassLoader的defineClass方法具体是调用VMClassLoader的defineClass本地静态方法。而这个本地方法除了抛出一个“UnsupportedOperationException”之外，什么都没做，甚至连返回值都为空 DexClassLoader 和 PathClassLoader在Android中，ClassLoader是一个抽象类，实际开发过程中，我们一般是使用其具体的子类DexClassLoader、PathClassLoader这些类加载器来加载类的，它们的不同之处是： DexClassLoader可以加载jar/apk/dex，可以从SD卡中加载未安装的apk； PathClassLoader只能加载系统中已经安装过的apk； 加载类的过程上面还只是创建了类加载器的实例，其中创建了一个DexFile实例，用来保存dex文件，我们猜想这个实例就是用来加载类的。 Android中，ClassLoader用loadClass方法来加载我们需要的类 12345678910111213141516171819202122232425public Class&lt;?&gt; loadClass(String className) throws ClassNotFoundException &#123; return loadClass(className, false); &#125; protected Class&lt;?&gt; loadClass(String className, boolean resolve) throws ClassNotFoundException &#123; Class&lt;?&gt; clazz = findLoadedClass(className); if (clazz == null) &#123; ClassNotFoundException suppressed = null; try &#123; clazz = parent.loadClass(className, false); &#125; catch (ClassNotFoundException e) &#123; suppressed = e; &#125; if (clazz == null) &#123; try &#123; clazz = findClass(className); &#125; catch (ClassNotFoundException e) &#123; e.addSuppressed(suppressed); throw e; &#125; &#125; &#125; return clazz; &#125; loadClass方法调用了findClass方法，而BaseDexClassLoader重载了这个方法，得到BaseDexClassLoader看看 12345678@Override protected Class&lt;?&gt; findClass(String name) throws ClassNotFoundException &#123; Class clazz = pathList.findClass(name); if (clazz == null) &#123; throw new ClassNotFoundException(name); &#125; return clazz; &#125; 结果还是调用了DexPathList的findClass 123456789101112public Class findClass(String name) &#123; for (Element element : dexElements) &#123; DexFile dex = element.dexFile; if (dex != null) &#123; Class clazz = dex.loadClassBinaryName(name, definingContext); if (clazz != null) &#123; return clazz; &#125; &#125; &#125; return null; &#125; 这里遍历了之前所有的DexFile实例，其实也就是遍历了所有加载过的dex文件，再调用loadClassBinaryName方法一个个尝试能不能加载想要的类，真是简单粗暴 1234public Class loadClassBinaryName(String name, ClassLoader loader) &#123; return defineClass(name, loader, mCookie);&#125;private native static Class defineClass(String name, ClassLoader loader, int cookie); 自定义ClassLoader平时进行动态加载开发的时候，使用DexClassLoader就够了。但我们也可以创建自己的类去继承ClassLoader，需要注意的是loadClass方法并不是final类型的，所以我们可以重载loadClass方法并改写类的加载逻辑。 通过前面我们分析知道，ClassLoader双亲代理的实现很大一部分就是在loadClass方法里，我们可以通过重写loadClass方法避开双亲代理的框架，这样一来就可以在重新加载已经加载过的类，也可以在加载类的时候注入一些代码。这是一种Hack的开发方式，采用这种开发方式的程序稳定性可能比较差，但是却可以实现一些“黑科技”的功能。","categories":[{"name":"Android","slug":"Android","permalink":"https://3431339973.github.io/categories/Android/"}],"tags":[{"name":"Dalvik","slug":"Dalvik","permalink":"https://3431339973.github.io/tags/Dalvik/"}]},{"title":"关于JVM类加载器","slug":"关于JAVA类加载器","date":"2016-03-21T12:37:23.000Z","updated":"2017-10-02T16:24:31.049Z","comments":true,"path":"2016/03/21/关于JAVA类加载器/","link":"","permalink":"https://3431339973.github.io/2016/03/21/关于JAVA类加载器/","excerpt":"摘要:最近需要弄android的 插件开发，那就先从JAVA的类加载器开始吧","text":"摘要:最近需要弄android的 插件开发，那就先从JAVA的类加载器开始吧 首先来了解一下字节码和class文件的区别：我们知道，新建一个java对象的时候，JVM要将这个对象对应的字节码加载到内存中，这个字节码的原始信息存放在classpath(就是我们新建Java工程的bin目录下)指定的目录下的.class文件,类加载需要将.class文件导入到硬盘中，经过一些处理之后变成字节码在加载到内存中。 顾名思义，类加载器（class loader）用来加载 Java 类到 Java 虚拟机中。一般来说，Java 虚拟机使用 Java 类的方式如下：Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。类加载器负责读取 Java 字节代码，并转换成 java.lang.Class类的一个实例。每个这样的实例用来表示一个 Java 类。通过此实例的 newInstance()方法就可以创建出该类的一个对象。实际的情况可能更加复杂，比如 Java 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。基本上所有的类加载器都是 java.lang.ClassLoader类的一个实例 类的加载过程来自 http://blog.csdn.net/gjanyanlig/article/details/6818655/JVM将类加载过程分为三个步骤：装载（Load），链接（Link）和初始化(Initialize)链接又分为三个步骤，如下图所示： 1) 装载：查找并加载类的二进制数据；2)链接：验证：确保被加载类的正确性；准备：为类的静态变量分配内存，并将其初始化为默认值；解析：把类中的符号引用转换为直接引用；3)初始化：为类的静态变量赋予正确的初始值； 那为什么我要有验证这一步骤呢？首先如果由编译器生成的class文件，它肯定是符合JVM字节码格式的，但是万一有高手自己写一个class文件，让JVM加载并运行，用于恶意用途，就不妙了，因此这个class文件要先过验证这一关，不符合的话不会让它继续执行的，也是为了安全考虑吧。 准备阶段和初始化阶段看似有点牟盾，其实是不牟盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。 类的初始化 类什么时候才被初始化：1）创建类的实例，也就是new一个对象2）访问某个类或接口的静态变量，或者对该静态变量赋值3）调用类的静态方法4）反射（Class.forName(“com.lyj.load”)）5）初始化一个类的子类（会首先初始化子类的父类）6）JVM启动时标明的启动类，即文件名和类名相同的那个类只有这6中情况才会导致类的类的初始化。 类的初始化步骤：1）如果这个类还没有被加载和链接，那先进行加载和链接 2）假如这个类存在直接父类，并且这个类还没有被初始化（注意：在一个类加载器中，类只能初始化一次），那就初始化直接的父类（不适用于接口） 3)加入类中存在初始化语句（如static变量和static块），那就依次执行这些初始化语句。 3.类的加载 类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个这个类的java.lang.Class对象，用来封装类在方法区类的对象。看下面2图 类的加载的最终产品是位于堆区中的Class对象 Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口 加载类的方式有以下几种： 1）从本地系统直接加载2）通过网络下载.class文件3）从zip，jar等归档文件中加载.class文件4）从专有数据库中提取.class文件5）将Java源文件动态编译为.class文件（服务器） Java虚拟机中类加载器：java虚拟机中主要又3个系统类加载器，BootStrap,ExtClassLoader,AppClassLoader，同时也可以安装多个 其他的加载器 BootStrap,使用C/C++代码写的，是第一个类加载器，已经封装到JVM内核中了，而ExtClassLoader和AppClassLoader是Java类，其他的类加载器也都是JAVA写的。 看一下类加载器的属性结构图： Java虚拟机中的所有类加载器采用具有父子关系的树形结构进行组织，在实例化每个类加载器对象的时候，需要为其指定一个父级类加载器对象或者默认采用系统类加载器为其父级类加载类加载器的委托机制：当Java虚拟机要加载第一个类的时候，到底派出哪个类加载器去加载呢？(1). 首先当前线程的类加载器去加载线程中的第一个类(当前线程的类加载器：Thread类中有一个get/setContextClassLoader(ClassLoader cl);方法，可以获取/指定本线程中的类加载器)(2). 如果类A中引用了类B,Java虚拟机将使用加载类A的类加载器来加载类B(3). 还可以直接调用ClassLoader.loadClass(String className)方法来指定某个类加载器去加载某个类每个类加载器加载类时，又先委托给其上级类加载器当所有祖宗类加载器没有加载到类，回到发起者类加载器，还加载不了，则会抛出ClassNotFoundException,不是再去找发起者类加载器的儿子，因为没有getChild()方法。例如：如上图所示： MyClassLoader-&gt;AppClassLoader-&gt;Ext-&gt;ClassLoader-&gt;BootStrap.自定定义的MyClassLoader1首先会先委托给AppClassLoader,AppClassLoader会委托给ExtClassLoader,ExtClassLoader会委托给BootStrap，这时候BootStrap就去加载，如果加载成功，就结束了。如果加载失败，就交给ExtClassLoader去加载，如果ExtClassLoader加载成功了，就结束了，如果加载失败就交给AppClassLoader加载，如果加载成功，就结束了，如果加载失败，就交给自定义的MyClassLoader1类加载器加载，如果加载失败，就报ClassNotFoundException异常，结束。","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://3431339973.github.io/categories/JAVA/"}],"tags":[{"name":"AppClassLoader","slug":"AppClassLoader","permalink":"https://3431339973.github.io/tags/AppClassLoader/"},{"name":"JVN","slug":"JVN","permalink":"https://3431339973.github.io/tags/JVN/"}]},{"title":"andfix 增量升级更新 热补丁修复","slug":"andfix","date":"2016-03-17T14:37:23.000Z","updated":"2017-10-01T12:47:06.109Z","comments":true,"path":"2016/03/17/andfix/","link":"","permalink":"https://3431339973.github.io/2016/03/17/andfix/","excerpt":"摘要:最近想着Android有没有什么热补丁更新技术的实现，于是上网搜索。接着实现了这一功能后，记录一下，免得自己忘了，可能文章会有出错的地方，望指出，呵呵","text":"摘要:最近想着Android有没有什么热补丁更新技术的实现，于是上网搜索。接着实现了这一功能后，记录一下，免得自己忘了，可能文章会有出错的地方，望指出，呵呵 搜索发现有这3种方式可以实现（至于其他的方式，暂不清楚）1.dexposed github https://github.com/alibaba/dexposed 2.andfix github https://github.com/alibaba/AndFix 3.bsdiff http://blog.csdn.net/lazyer_dog/article/details/47173013 dexposed和andfix是alibaba的开源项目，都是apk增量更新的实现框架，目前dexposed的兼容性较差，只有2.3，4.0~4.4兼容，其他Android版本不兼容或未测试，详细可以去dexposed的github项目主页查看，而andfix则兼容2.3~6.0，所以就拿这个项目来实现增量更新吧。至于bsdiff，只是阅览了一下，还没研究过。 首先 Git clone github https://github.com/alibaba/AndFix，将andfix项目下载下来，Android studio可以在build.gradle里导入andfix， compile ‘com.alipay.euler:andfix:0.3.1@aar’但是我是使用module的方式添加andfix，这样可以直接查看编辑源码，而且直接gradle导入的话还有个问题，后面再说。 andfix项目里有sample，导入也行，自己新建也行，我是自己新建项目，接着导入andfix作为module，demo里就两个类，mainactivity和myapplication andfix里有些文件夹不用导入的，例如tools，doc等，记得新建jniLibs文件夹，libs里的so文件移到jniLibs里。~~~javapublic class MainApplication extends Application { private static final String TAG = “euler”; private static final String APATCH_PATH = &quot;/out.apatch&quot;; private static final String DIR = &quot;apatch&quot;;//补丁文件夹 /** * patch manager */ private PatchManager mPatchManager; @Override public void onCreate() { super.onCreate(); // initialize mPatchManager = new PatchManager(this); mPatchManager.init(&quot;1.0&quot;); Log.d(TAG, &quot;inited.&quot;); // load patch mPatchManager.loadPatch(); // Log.d(TAG, “apatch loaded.”); // add patch at runtime try { // .apatch file path String patchFileString = Environment.getExternalStorageDirectory() .getAbsolutePath() + APATCH_PATH; mPatchManager.addPatch(patchFileString); Log.d(TAG, &quot;apatch:&quot; + patchFileString + &quot; added.&quot;); //这里我加了个方法，复制加载补丁成功后，删除sdcard的补丁，避免每次进入程序都重新加载一次 File f = new File(this.getFilesDir(), DIR + APATCH_PATH); if (f.exists()) { boolean result = new File(patchFileString).delete(); if (!result) Log.e(TAG, patchFileString + &quot; delete fail&quot;); } } catch (IOException e) { Log.e(TAG, &quot;&quot;, e); } } public class MainActivity extends Activity { private static final String TAG = “euler”; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); toast(); } @Override protected void onDestroy() { super.onDestroy(); android.os.Process.killProcess(android.os.Process.myPid()); } //旧方法，1.apk private void toast() { Toast.makeText(this, &quot;old&quot;, Toast.LENGTH_SHORT).show(); }} 刚刚说的直接在gradle里导入andfix会有个问题，是在原来的项目中，加载一次补丁后，out.apatch文件会copy到getFilesDir目录下的/apatch文件夹中，在下次补丁更新时，会检测补丁是否已经添加在apatch文件夹下，已存在就不会复制加载sdcard的out.apatch。 原来的addpath方法 public void addPatch(String path) throws IOException { File src = new File(path); File dest = new File(mPatchDir, src.getName()); if(!src.exists()){ throw new FileNotFoundException(path); } if (dest.exists()) { Log.d(TAG, “patch [“ + path + “] has be loaded.”); return; } FileUtil.copyFile(src, dest);// copy to patch’s directory Patch patch = addPatch(dest); if (patch != null) { loadPatch(patch); }} 修改后，判断apatch下的out.apatch存在即删除掉，重新复制加载sdcard下的out.apatch public void addPatch(String path) throws IOException { File src = new File(path); File dest = new File(mPatchDir, src.getName()); if (!src.exists()) { throw new FileNotFoundException(path); } if (dest.exists()) { Log.d(TAG, “patch [“ + src.getName() + “] has be loaded.”); boolean deleteResult = dest.delete(); if (deleteResult) Log.e(TAG, “patch [“ + dest.getPath() + “] has be delete.”); else { Log.e(TAG, “patch [“ + dest.getPath() + “] delete error”); return; } } FileUtil.copyFile(src, dest);// copy to patch’s directory Patch patch = addPatch(dest); if (patch != null) { loadPatch(patch); }} 还有源码混淆 -optimizationpasses 5 # 指定代码的压缩级别-dontusemixedcaseclassnames # 是否使用大小写混合-dontskipnonpubliclibraryclasses # 是否混淆第三方jar-dontpreverify # 混淆时是否做预校验-verbose # 混淆时是否记录日志-optimizations !code/simplification/arithmetic,!field/,!class/merging/ # 混淆时所采用的算法 重要，別忘了這些，不混淆andfix包，不混淆native方法-dontwarn android.annotation-dontwarn com.alipay.euler.-keep class com.alipay.euler. {;}-keep class extends java.lang.annotation.Annotation-keepclasseswithmembernames class * { native ;} 接着打包1.apk， 然后修改mainactivity的toast()，打包2.apk //修改Toast內容，2.apkprivate void toast() { Toast.makeText(this, “new”, Toast.LENGTH_SHORT).show();} cmd输入命令，具体参数看usage 如无错误，编译后会生成一个apatch文件，改名成out.apatch 安装打开1.apk 关闭app，将out.apatch放sdcard根目录后，重新打开app，toast方法改变了 ps： 这里只是简单的测试了一下，没有复杂的功能，而且andfix不支持布局资源等的修改。 github主页的issues反应说Android4.0.4，以及5.0以上版本会crash，不过我使用了两个虚拟机，genymotion的4.2和5.0虚拟机，没有错误，其他请自测 使用了apk加固时（360加固，百度加固等等），发现在加固前要先apkpatch制作补丁，不能使用加固后的apk制作，否则补丁无法使用，但是在加固前制作的补丁可以很容易的被反编译出源码 demo下载 http://download.csdn.net/detail/ityangjun/9177377","categories":[{"name":"Android","slug":"Android","permalink":"https://3431339973.github.io/categories/Android/"}],"tags":[{"name":"移动开发","slug":"移动开发","permalink":"https://3431339973.github.io/tags/移动开发/"},{"name":"转载","slug":"转载","permalink":"https://3431339973.github.io/tags/转载/"},{"name":"增量升级","slug":"增量升级","permalink":"https://3431339973.github.io/tags/增量升级/"},{"name":"热补丁修复","slug":"热补丁修复","permalink":"https://3431339973.github.io/tags/热补丁修复/"},{"name":"andfix","slug":"andfix","permalink":"https://3431339973.github.io/tags/andfix/"}]},{"title":"Android是怎么把点击屏幕，或者是实体按键 的事件分发到对应的View上的","slug":"201601141","date":"2016-01-14T05:55:12.000Z","updated":"2017-10-05T09:00:15.339Z","comments":true,"path":"2016/01/14/201601141/","link":"","permalink":"https://3431339973.github.io/2016/01/14/201601141/","excerpt":"摘要:学习了下android的屏幕点击原理，（并不是应用层的事件分发）流程很复杂，简单的梳理了一下，日后再做详细研究","text":"摘要:学习了下android的屏幕点击原理，（并不是应用层的事件分发）流程很复杂，简单的梳理了一下，日后再做详细研究 系统启动后，会有个WindowManagerSeverice（WMS）,WindowManagerSeverice通过IWindow(aidl)跟视图中的viewRoot（后期ViewRootImpl） 关联。 当用户点击屏幕后WMS 接受到屏幕发来的消息（通过Binder） WMS找到屏幕顶端进程的IWindow并调用dispatchKey方法 IWindow 可以找到持有他Bn端的viewRoot viewRoot在根据坐标 找到内部的view 进行事件处理","categories":[{"name":"Android","slug":"Android","permalink":"https://3431339973.github.io/categories/Android/"}],"tags":[{"name":"移动开发","slug":"移动开发","permalink":"https://3431339973.github.io/tags/移动开发/"},{"name":"Android","slug":"Android","permalink":"https://3431339973.github.io/tags/Android/"},{"name":"事件","slug":"事件","permalink":"https://3431339973.github.io/tags/事件/"}]},{"title":"Android 应用的安装和卸载PackageManagerService","slug":"201601121","date":"2016-01-12T13:55:27.000Z","updated":"2017-10-05T10:49:57.191Z","comments":true,"path":"2016/01/12/201601121/","link":"","permalink":"https://3431339973.github.io/2016/01/12/201601121/","excerpt":"摘要:android系统的应用安装包是APK格式，这个APK格式如何安装到android设备的呢？","text":"摘要:android系统的应用安装包是APK格式，这个APK格式如何安装到android设备的呢？ PackageManagerServiceAndroid 系统的应用管理主要通过PackageManagerService来完成PackageManagerService 启动时会扫描所有的APK文件 和JAR包 把他们的信息读出来保存到内存中，这样系统就能很快的找到各个应用和组件的信息在android 5.0 以前 ，PackageManagerService会监听安装了应用的目录，一旦目录发生了变化，他讲重新扫描目录，完成自动安装，但是在5.0后 PackageManagerService 不会在监听，这是因为5.0后的目录结构发生了变化。5.0以前/data/app或者/system/app 下面直接存放的是应用APK，而5.0后存放的是应用名称的目录，目录下才是APK 还有个lib的目录 存放的so Android应用两大类 系统应用系统应用是设备内置的应用，通常情况下不能删除，存放在/system/app目录下，4.4以后 又出现了一个/system/priv-app/。两者的区别在于 app下存放的是普通的系统级应用 如 电话，相机等，而priv-app下存放的是 偏底层的系统应用如 系统页面，系统设置 等等 普通应用普通应用是 用户安装的应用 在/data/app 目录下，同时可以安装的sd卡上 ##安装应用 1：复制文件调用PackageManager的installPackage()方法来开始安装过程，第一阶段就是把应用复制到/data/app目录下 12345678910111213141516171819202122232425262728293031323334@Overridepublic void installPackage(String originPath, IPackageInstallObserver2 observer, int installFlags, String installerPackageName, VerificationParams verificationParams, String packageAbiOverride) &#123; //传入了当前用户 installPackageAsUser(originPath, observer, installFlags, installerPackageName, verificationParams, packageAbiOverride, UserHandle.getCallingUserId());&#125;@Overridepublic void installPackageAsUser(String originPath, IPackageInstallObserver2 observer, int installFlags, String installerPackageName, VerificationParams verificationParams, String packageAbiOverride, int userId) &#123; //检查调用进程权限 mContext.enforceCallingOrSelfPermission(android.Manifest.permission.INSTALL_PACKAGES, null); //检查进程的用户是否有权限安装 final int callingUid = Binder.getCallingUid(); enforceCrossUserPermission(callingUid, userId, true, true, \"installPackageAsUser\"); //检查制定用户是否被限制安装 if (isUserRestricted(userId, UserManager.DISALLOW_INSTALL_APPS)) &#123; try &#123; if (observer != null) &#123; observer.onPackageInstalled(\"\", INSTALL_FAILED_USER_RESTRICTED, null, null); &#125; &#125; catch (RemoteException re) &#123; &#125; 。。。。。。。。。。。。。 。。。。。。。。。。。。。 //发送消息 final Message msg = mHandler.obtainMessage(INIT_COPY); msg.obj = new InstallParams(origin, observer, installFlags, installerPackageName, verificationParams, user, packageAbiOverride); mHandler.sendMessage(msg);&#125; installPackage() 方法里先是做了一些检查工作，例如检查进程的用户是否有权限安装，最后向PackageHandler 发送了下次，然后执行安装，执行安装其实就是调用 HandlerParams的startCopy方法，看名字也知道 要开始复制了。 123456789101112131415161718192021222324252627282930313233343536373839404142434445private abstract class HandlerParams &#123; private static final int MAX_RETRIES = 4; /** * Number of times startCopy() has been attempted and had a non-fatal * error. */ private int mRetries = 0; /** User handle for the user requesting the information or installation. */ private final UserHandle mUser; HandlerParams(UserHandle user) &#123; mUser = user; &#125; UserHandle getUser() &#123; return mUser; &#125; final boolean startCopy() &#123; boolean res; try &#123; if (DEBUG_INSTALL) Slog.i(TAG, \"startCopy \" + mUser + \": \" + this); //如果重试查过4次 就发送通知 if (++mRetries &gt; MAX_RETRIES) &#123; Slog.w(TAG, \"Failed to invoke remote methods on default container service. Giving up\"); mHandler.sendEmptyMessage(MCS_GIVE_UP); handleServiceError(); return false; &#125; else &#123; //执行复制 handleStartCopy(); res = true; &#125; &#125; catch (RemoteException e) &#123; if (DEBUG_INSTALL) Slog.i(TAG, \"Posting install MCS_RECONNECT\"); mHandler.sendEmptyMessage(MCS_RECONNECT); res = false; &#125; //执行装载 handleReturnCode(); return res; &#125; HandlerParams 是个抽象类，他的handleStartCopy 方法 和handleReturnCode 在InstallParams 里实现。由于代码较长具体代码不贴了又兴趣的，可以研究下 ，到了这里apk的复制算是完成了，然后进行下一步 ###:2：装载应用在上一步 最后调用了 handleReturnCode 方法 1234567891011121314151617181920212223242526272829303132333435363738394041424344 @Override void handleReturnCode() &#123; // If mArgs is null, then MCS couldn't be reached. When it // reconnects, it will try again to install. At that point, this // will succeed. if (mArgs != null) &#123; processPendingInstall(mArgs, mRet); &#125; &#125;private void processPendingInstall(final InstallArgs args, final int currentStatus) &#123; // Queue up an async operation since the package installation may take a little while. mHandler.post(new Runnable() &#123; public void run() &#123; //防止重复调用 mHandler.removeCallbacks(this); // Result object to be returned PackageInstalledInfo res = new PackageInstalledInfo(); res.returnCode = currentStatus; res.uid = -1; res.pkg = null; res.removedInfo = new PackageRemovedInfo(); if (res.returnCode == PackageManager.INSTALL_SUCCEEDED) &#123; //如果安装成功了 args.doPreInstall(res.returnCode); synchronized (mInstallLock) &#123; //装载APP installPackageLI(args, res); &#125; args.doPostInstall(res.returnCode, res.uid); &#125; 。。。。。。。。 if (!doRestore) &#123; // No restore possible, or the Backup Manager was mysteriously not // available -- just fire the post-install work request directly. if (DEBUG_INSTALL) Log.v(TAG, \"No restore - queue post-install for \" + token); //发送完成消息 Message msg = mHandler.obtainMessage(POST_INSTALL, token, 0); mHandler.sendMessage(msg); &#125; &#125; &#125;);&#125; 在这个方法里主要调用了 installPackageLI 方法 来装载APPinstallPackageLI 也比较长 主要就是 解析的apk文件创建了 判断是老应用还是新应用 如果是新应用就调用installNewPackageLI来创建各种目录 跟文件 其实安装过程中还需要往PackageManagerService 里写入很多 缓存数据等等 这里就不分析了 卸载应用PackageManagerService 的卸载方法是 deletePackage() 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061@Overridepublic void deletePackage(final String packageName, final IPackageDeleteObserver2 observer, final int userId, final int flags) &#123; mContext.enforceCallingOrSelfPermission( android.Manifest.permission.DELETE_PACKAGES, null); final int uid = Binder.getCallingUid(); if (UserHandle.getUserId(uid) != userId) &#123; mContext.enforceCallingPermission( android.Manifest.permission.INTERACT_ACROSS_USERS_FULL, \"deletePackage for user \" + userId); &#125; if (isUserRestricted(userId, UserManager.DISALLOW_UNINSTALL_APPS)) &#123; try &#123; observer.onPackageDeleted(packageName, PackageManager.DELETE_FAILED_USER_RESTRICTED, null); &#125; catch (RemoteException re) &#123; &#125; return; &#125; boolean uninstallBlocked = false; if ((flags &amp; PackageManager.DELETE_ALL_USERS) != 0) &#123; int[] users = sUserManager.getUserIds(); for (int i = 0; i &lt; users.length; ++i) &#123; if (getBlockUninstallForUser(packageName, users[i])) &#123; uninstallBlocked = true; break; &#125; &#125; &#125; else &#123; uninstallBlocked = getBlockUninstallForUser(packageName, userId); &#125; if (uninstallBlocked) &#123; try &#123; observer.onPackageDeleted(packageName, PackageManager.DELETE_FAILED_OWNER_BLOCKED, null); &#125; catch (RemoteException re) &#123; &#125; return; &#125; if (DEBUG_REMOVE) &#123; Slog.d(TAG, \"deletePackageAsUser: pkg=\" + packageName + \" user=\" + userId); &#125; // Queue up an async operation since the package deletion may take a little while. mHandler.post(new Runnable() &#123; public void run() &#123; mHandler.removeCallbacks(this); final int returnCode = deletePackageX(packageName, userId, flags); if (observer != null) &#123; try &#123; observer.onPackageDeleted(packageName, returnCode, null); &#125; catch (RemoteException e) &#123; Log.i(TAG, \"Observer no longer exists.\"); &#125; //end catch &#125; //end if &#125; //end run &#125;);&#125; 其实就是删除安装时 生成的apk 和目录 ，同时也删除了 PackageManagerService 里的信息","categories":[{"name":"Android","slug":"Android","permalink":"https://3431339973.github.io/categories/Android/"}],"tags":[{"name":"移动开发","slug":"移动开发","permalink":"https://3431339973.github.io/tags/移动开发/"},{"name":"Android","slug":"Android","permalink":"https://3431339973.github.io/tags/Android/"},{"name":"PackageManagerService","slug":"PackageManagerService","permalink":"https://3431339973.github.io/tags/PackageManagerService/"}]},{"title":"整理 iOS 9 适配中出现的坑","slug":"整理 iOS 9 适配中出现的坑","date":"2015-12-18T08:17:33.000Z","updated":"2017-10-01T12:46:58.339Z","comments":true,"path":"2015/12/18/整理 iOS 9 适配中出现的坑/","link":"","permalink":"https://3431339973.github.io/2015/12/18/整理 iOS 9 适配中出现的坑/","excerpt":"摘要: 整理 iOS 9 适配中出现的坑","text":"摘要: 整理 iOS 9 适配中出现的坑 http://www.cocoachina.com/ios/20151012/13715.html#0-tsina-1-57205-397232819ff9a47a7b7e80a40613cfe1","categories":[{"name":"IOS","slug":"IOS","permalink":"https://3431339973.github.io/categories/IOS/"}],"tags":[{"name":"session共享","slug":"session共享","permalink":"https://3431339973.github.io/tags/session共享/"},{"name":"分布式","slug":"分布式","permalink":"https://3431339973.github.io/tags/分布式/"},{"name":"IOS 9","slug":"IOS-9","permalink":"https://3431339973.github.io/tags/IOS-9/"}]},{"title":"单个ViewControl适配不同ios版本xib文件实现","slug":"20151207","date":"2015-12-07T08:17:33.000Z","updated":"2017-10-01T12:46:19.311Z","comments":true,"path":"2015/12/07/20151207/","link":"","permalink":"https://3431339973.github.io/2015/12/07/20151207/","excerpt":"摘要: IOS 适配不同的界面xib","text":"摘要: IOS 适配不同的界面xib 方法如下： 在跳转本界面时，在代码里面实现如下： 1234567891011float systemVersion = [[[UIDevice currentDevice] systemVersion] floatValue];if (systemVersion &gt;= 7.0)&#123; AboutUSView *aboutUSView= [[[AboutUSView alloc] initWithNibName:@\"AboutUSView1\" bundle:nil] autorelease]; [self.navigationController pushViewController:aboutUSView animated:TRUE];&#125;else&#123; AboutUSView *aboutUSView= [[[AboutUSView alloc] initWithNibName:@\"AboutUSView\" bundle:nil] autorelease]; [self.navigationController pushViewController:aboutUSView animated:TRUE];&#125;","categories":[{"name":"IOS","slug":"IOS","permalink":"https://3431339973.github.io/categories/IOS/"}],"tags":[{"name":"IOS","slug":"IOS","permalink":"https://3431339973.github.io/tags/IOS/"},{"name":"xib","slug":"xib","permalink":"https://3431339973.github.io/tags/xib/"},{"name":"屏幕适配","slug":"屏幕适配","permalink":"https://3431339973.github.io/tags/屏幕适配/"}]},{"title":"一个Demo学会用Android兼容包新控件","slug":"20151112","date":"2015-11-23T11:42:23.000Z","updated":"2017-10-01T12:46:06.994Z","comments":true,"path":"2015/11/23/20151112/","link":"","permalink":"https://3431339973.github.io/2015/11/23/20151112/","excerpt":"摘要:伟大的Google为Android推出了一系列的兼容包，最新的就是Design Support Library了，这里我们结合v7和v4中的几个控件，来主要学习Design Support Library中的几个新控件！一个Demo学会用它们！","text":"摘要:伟大的Google为Android推出了一系列的兼容包，最新的就是Design Support Library了，这里我们结合v7和v4中的几个控件，来主要学习Design Support Library中的几个新控件！一个Demo学会用它们！ 效果动图GIF： 学习内容通过本实例可以学习到以下内容： Drawerlayout和NavigationView实现优雅的Google范儿侧边栏； 新控件CoordinatorLayout、AppBarLayout、Toolbar、FloatingActionButton的用法，以及Toolbar的渐变隐藏动画效果； 官方Tabs组件TabLayout和ViewPager结合实现主界面内容区域； SwipeRefreshLayout和RecyclerView结合实现下拉刷新，以及RecyclerView的数据适配器RecyclerView.Adapter的用法，还有RecyclerView中item的点击事件的实现方法； 卡片式CardView的用法； 类似Toast的新控件Snackbar的用法。布局文件 学习Android解释再多代码都没有用，因为解释过了还是不会用。因此，我们这里将布局文件XML源码贴出来供学习，放心，所有知识点都已经注释在源码中。 styles.xml源码12345678910111213141516&lt;resources&gt; &lt;style name=\"AppTheme\" parent=\"MyThemeBlue\"&gt;&lt;/style&gt; &lt;!-- 蓝色为主色调 --&gt; &lt;style name=\"MyThemeBlue\" parent=\"Theme.AppCompat.Light.NoActionBar\"&gt; &lt;!--选中状态icon的颜色和字体颜色--&gt; &lt;item name=\"colorPrimary\"&gt;@color/main_blue_light&lt;/item&gt; &lt;item name=\"colorPrimaryDark\"&gt;@color/main_blue_dark&lt;/item&gt; &lt;item name=\"colorAccent\"&gt;@color/main_blue_light&lt;/item&gt; &lt;!--正常状态下字体颜色和icon颜色--&gt; &lt;item name=\"android:textColorPrimary\"&gt;@color/main_white&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; colorPrimary、colorPrimaryDark、colorAccent、textColorPrimary的含义，请看博文 《Android L+ Theme 与 Toolbar 实例》 。 主布局activity_my.xml源码（重点）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;android.support.v4.widget.DrawerLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:id=\"@+id/id_drawerlayout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;!-- 第一个位置 --&gt; &lt;!-- 你的主界面内容，必须放置在Drawerlayout中的第一个位置 根据自己的需要来放置控件， 例如：LinearLayout布局或者RelativeLayout布局； 也可以是单个控件， 如 TextView等 --&gt; &lt;include layout=\"@layout/content_main\" /&gt; &lt;!-- 第二个位置 --&gt; &lt;!-- 用来放Drawerlayout中的内容， 这里使用NavigationView来实现类似Google pLay中的侧滑栏效果， 必须在build.gradle中添加compile 'com.android.support:design:22.2.0'； 另外，如果不需要NavigationView效果， 也可以放置一个普通布局文件就是一个普通的侧滑栏了。 --&gt; &lt;!-- 注意： 如果使用NavigationView（其他控件也是一样）的特有属性，需要加上命名空间： xmlns:app=\"http://schemas.android.com/apk/res-auto\"； 另外，一定要添加android:layout_gravity=\"left\"属性。 --&gt; &lt;!-- 属性解析： app:headerLayout： NavigationView中头部的head部分的布局，是自己实现的； app:menu： 指定Nav中的Menu布局，就是自己写Menu中的按钮，要放在res/menu/文件夹下； app:itemTextColor： 用来设置Nav中，menu item的颜色选择器。 还有一些属性： 和itemTextColor用法一样，指定一个颜色选择器，实现不同的颜色效果。 app:itemIconTint: app:itemBackground: --&gt; &lt;android.support.design.widget.NavigationView android:id=\"@+id/id_navigationview\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:itemTextColor=\"@color/selector_nav_menu_textcolor\" android:layout_gravity=\"left\" /&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; content_main.xml源码（重点）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!-- CoordinatorLayout是这次新添加的一个增强型的FrameLayout，通过它可以实现很多东西： 例如： 1.界面向上滚动逐渐隐藏Toolbar； 2.在其中可以放置浮动的View，就像Floating Action Button。--&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:id=\"@+id/id_coordinatorlayout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"true\"&gt; &lt;!-- AppBarLayout跟它的名字一样，把容器类的组件全部作为AppBar。 将AppBarLayout放在CoordinatorLayout中，就可以实现滚动效果。 本例中，TabLayout在界面滚动时，随着Toolbar的逐渐隐藏，将占据Toolbar的位置， 达到节省屏幕空间，界面动画效果的目的。 --&gt; &lt;android.support.design.widget.AppBarLayout android:id=\"@+id/id_appbarlayout\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"&gt; &lt;!-- 属性解析： app:theme：指定Toolbar的样式，包括ActionbarToggle和popupMenu的指示图标颜色 app:popupTheme：指定popupMenu溢出后的样式 app:title: 指定Toolbar中主Title的内容 --&gt; &lt;!-- app:layout_scrollFlags的意思是： 设置的layout_scrollFlags有如下几种选项： scroll: 所有想滚动出屏幕的view都需要设置这个flag- 没有设置这个flag的view将被固定在屏幕顶部。 enterAlways: 这个flag让任意向下的滚动都会导致该view变为可见，启用快速“返回模式”。 enterAlwaysCollapsed: 当你的视图已经设置minHeight属性又使用此标志时，你的视图只能以最小高度进入，只有当滚动视图到达顶部时才扩大到完整高度。 exitUntilCollapsed: 当视图会在滚动时，它一直滚动到设置的minHeight时完全隐藏。 需要注意的是，后面两种模式基本只有在CollapsingToolbarLayout才有用， 而前面两种模式基本是需要一起使用的，也就是说，这些flag的使用场景，基本已经固定了。 --&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/id_toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:background=\"?attr/colorPrimary\" app:layout_scrollFlags=\"scroll|enterAlways\" app:popupTheme=\"@style/ThemeOverlay.AppCompat.Light\" app:theme=\"@style/ThemeOverlay.AppCompat.ActionBar\" app:title=\"@string/toolbar_title\" /&gt; &lt;!-- Tabs选项卡，和ViewPager搭配使用可以增大界面的内容展示量，实现各种个性化分类内容展示而不互相干扰！ Google在Design support library中提供官方的Tab组件，它就是TabLayout。 相比Github上面开源的第三方库，这个更加简单易用。 有以下常用属性： app:tabGravity=\"fill\" 表示TabLayout中的Tabs要占满屏幕的width； app:tabSelectedTextColor：Tab被选中字体的颜色； app:tabTextColor：Tab未被选中字体的颜色； app:tabIndicatorColor：Tab指示器下标的颜色； --&gt; &lt;android.support.design.widget.TabLayout android:id=\"@+id/id_tablayout\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" app:tabGravity=\"fill\" app:tabIndicatorColor=\"@color/main_white\" /&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;!-- 我们常用的ViewPager，不多说了。你会发现多了一个 app:layout_behavior 属性，没错， 如果你使用CoordinatorLayout来实现Toolbar滚动渐变消失动画效果，那就必须在它下面的那个控件中加入这个属性， 并且下面的这个控件必须是可滚动的。 当设置了layout_behavior的控件滑动时，就会触发设置了layout_scrollFlags的控件发生状态的改变。 --&gt; &lt;android.support.v4.view.ViewPager android:id=\"@+id/id_viewpager\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\" /&gt; &lt;!-- 这是一个浮动按钮。由于FloatingActionButton是重写ImageView的， 所有FloatingActionButton拥有ImageView的一切属性。 属性介绍： app:backgroundTint : FAB的背景色。 app:elevation ：FAB的阴影效果。 app:rippleColor ：设置涟漪的颜色，默认是由背景色生成的暗色调，可以自己指定。 app:pressedTranslationZ ：FAB动画效果，在它被按下的时候阴影就会增大。 --&gt; &lt;android.support.design.widget.FloatingActionButton android:id=\"@+id/id_floatingactionbutton\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"bottom|end\" android:src=\"@mipmap/ic_action_plusone\" app:backgroundTint=\"@color/main_blue_light\" app:elevation=\"6dp\" app:pressedTranslationZ=\"12dp\" app:rippleColor=\"@color/main_blue_dark\" /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; frag_main.xml源码（Fragment的布局）1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!--SwipeRefreshLayout是伟大的Google在v4包中给出的下拉刷新组件。--&gt;&lt;android.support.v4.widget.SwipeRefreshLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:id=\"@+id/id_swiperefreshlayout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\"&gt; &lt;!-- 使用RecyclerView需要在build.gradle中添加 compile 'com.android.support:recyclerview-v7:22.2.0' --&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/id_recyclerview\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /&gt;&lt;/android.support.v4.widget.SwipeRefreshLayout&gt; item_main.xml源码（RecyclerView中item）123456789101112131415161718192021222324252627282930313233343536&lt;!-- CardView就是一个卡片样式的FrameLayout。 参数介绍： app:cardBackgroundColor : 背景颜色 app:cardCornerRadius ： 设置圆角。 app:cardElevation ： 阴影。 app:cardMaxElevation ： 最大阴影。 app:cardPreventCornerOverlap ： 在v20和之前的版本中添加内边距， 这个属性是为了防止卡片内容和边角的重叠。 app:cardUseCompatPadding ： 设置内边距，v21+的版本和之前的版本仍旧具有一样的计算方式--&gt;&lt;android.support.v7.widget.CardView xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:id=\"@+id/id_cardview\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center\" app:cardBackgroundColor=\"@color/main_blue_light\" app:cardCornerRadius=\"4dp\" app:cardElevation=\"5dp\" app:cardMaxElevation=\"10dp\" app:cardPreventCornerOverlap=\"true\" app:cardUseCompatPadding=\"true\"&gt; &lt;TextView android:id=\"@+id/id_textview\" android:layout_width=\"200dp\" android:layout_height=\"200dp\" android:layout_gravity=\"center\" android:gravity=\"center\" android:textColor=\"@color/main_white\" android:textSize=\"30sp\" /&gt;&lt;/android.support.v7.widget.CardView&gt; menu_nav.xml的源码（NavagationView中菜单）123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;group android:checkableBehavior=\"single\"&gt; &lt;item android:id=\"@+id/nav_menu_home\" android:icon=\"@mipmap/ic_home_white_48dp\" android:title=\"主页\" /&gt; &lt;item android:id=\"@+id/nav_menu_categories\" android:icon=\"@mipmap/ic_sort_by_alpha_white_48dp\" android:title=\"分类\" /&gt; &lt;item android:id=\"@+id/nav_menu_feedback\" android:icon=\"@mipmap/ic_message_white_48dp\" android:title=\"反馈\" /&gt; &lt;item android:id=\"@+id/nav_menu_setting\" android:icon=\"@mipmap/ic_settings_white_48dp\" android:title=\"设置\" /&gt; &lt;/group&gt;&lt;/menu&gt; header_nav.xml源码（NavagationView的head）12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"220dp\" android:background=\"@drawable/ic_user_background\" android:gravity=\"center\" android:orientation=\"vertical\"&gt; &lt;!-- 一个显示圆形头像的自定义ImageView --&gt; &lt;com.sunjiajia.androidnewwidgetsdemo.view.RoundedImageView android:id=\"@+id/id_header_face\" android:layout_width=\"110dp\" android:layout_height=\"110dp\" android:scaleType=\"fitXY\" android:src=\"@drawable/author\" /&gt; &lt;TextView android:id=\"@+id/id_header_authorname\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/header_author_name\" android:textColor=\"@android:color/black\" android:textSize=\"16sp\" /&gt; &lt;TextView android:id=\"@+id/id_header_url\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/header_author_url\" android:textColor=\"@android:color/black\" android:textSize=\"18sp\" /&gt;&lt;/LinearLayout&gt; Java代码Java代码写法比较简单，这里只给出RecyclerView.Adapter的写法（包括item点击事件）。 RecyclerView.Adapter写法源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package com.sunjiajia.androidnewwidgetsdemo.adapter;import android.content.Context;import android.support.v7.widget.RecyclerView;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import com.sunjiajia.androidnewwidgetsdemo.R;import java.util.ArrayList;import java.util.List;/** * Created by Monkey on 2015/6/29. */public class MyRecyclerViewAdapter extends RecyclerView.Adapter&lt;MyRecyclerViewHolder&gt; &#123; // 点击事件接口 public interface OnItemClickListener &#123; void onItemClick(View view, int position); void onItemLongClick(View view, int position); &#125; public OnItemClickListener mOnItemClickListener; public void setOnItemClickListener(OnItemClickListener listener) &#123; this.mOnItemClickListener = listener; &#125; public Context mContext; public List&lt;String&gt; mDatas; public LayoutInflater mLayoutInflater; public MyRecyclerViewAdapter(Context mContext) &#123; this.mContext = mContext; mLayoutInflater = LayoutInflater.from(mContext); // 这里是模拟数据。 mDatas = new ArrayList&lt;&gt;(); for (int i = 'A'; i &lt;= 'z'; i++) &#123; mDatas.add((char) i + \"\"); &#125; &#125; /** * 创建ViewHolder */ @Override public MyRecyclerViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View mView = mLayoutInflater.inflate(R.layout.item_main, parent, false); MyRecyclerViewHolder mViewHolder = new MyRecyclerViewHolder(mView); return mViewHolder; &#125; /** * 绑定ViewHoler，给item中的控件设置数据 */ @Override public void onBindViewHolder(final MyRecyclerViewHolder holder, final int position) &#123; //点击事件在这里实现，主要是利用RecyclerView中填充的布局控件可以被点击这个原理 if (mOnItemClickListener != null) &#123; holder.itemView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; mOnItemClickListener.onItemClick(holder.itemView, position); &#125; &#125;); // 长点击事件 holder.itemView.setOnLongClickListener(new View.OnLongClickListener() &#123; @Override public boolean onLongClick(View v) &#123; mOnItemClickListener.onItemLongClick(holder.itemView, position); return true; &#125; &#125;); &#125; holder.mTextView.setText(mDatas.get(position)); &#125; @Override public int getItemCount() &#123; return mDatas.size(); &#125;&#125; MyRecyclerViewHolder.java源码1234567891011121314151617181920package com.sunjiajia.androidnewwidgetsdemo.adapter;import android.support.v7.widget.RecyclerView;import android.view.View;import android.widget.TextView;import com.sunjiajia.androidnewwidgetsdemo.R;/** * Created by Monkey on 2015/6/29. */public class MyRecyclerViewHolder extends RecyclerView.ViewHolder &#123; public TextView mTextView; public MyRecyclerViewHolder(View itemView) &#123; super(itemView); mTextView = (TextView) itemView.findViewById(R.id.id_textview); &#125;&#125; 结语在源码中学习Android，是有种身临其境的感觉的。 整个Demo的源码我放在了GitHub上，谢谢star一下~在看源码过程中如果发现什么问题，请在留言，看到一定回复。 源码地址：AndroidNewWidgetsDemo 原文地址：http://sunjiajia.com/2015/07/02/android-new-widgets-demo/","categories":[{"name":"Android","slug":"Android","permalink":"https://3431339973.github.io/categories/Android/"}],"tags":[{"name":"移动开发","slug":"移动开发","permalink":"https://3431339973.github.io/tags/移动开发/"},{"name":"转载","slug":"转载","permalink":"https://3431339973.github.io/tags/转载/"},{"name":"support v7 新控件","slug":"support-v7-新控件","permalink":"https://3431339973.github.io/tags/support-v7-新控件/"}]},{"title":"Android-PickerView 时间控件，选择权","slug":"Android-PickerView","date":"2015-10-17T14:37:23.000Z","updated":"2017-10-02T16:32:13.991Z","comments":true,"path":"2015/10/17/Android-PickerView/","link":"","permalink":"https://3431339973.github.io/2015/10/17/Android-PickerView/","excerpt":"在 saiwu-bigkoo 大神以上修改 便于自己使用","text":"在 saiwu-bigkoo 大神以上修改 便于自己使用 PickerView (2.x系列)精仿iOS的PickerView控件，有时间选择和选项选择并支持一二三级联动效果——TimePickerView 时间选择器，支持年月日时分，年月日，年月，时分等格式——OptionsPickerView 选项选择器，支持一，二，三级选项选择，并且可以设置是否联动 2.x是全新的3D效果，比1.x版本更加贴近iOS的效果，从外观细节上也得到了改善。api兼容1.x版本，只需要把依赖的版本号升级即可，几乎不用修改代码即可完成升级。 ####使用maven 依赖123456&lt;dependency&gt; &lt;groupId&gt;com.sh.zsh.code&lt;/groupId&gt; &lt;artifactId&gt;pickerview&lt;/artifactId&gt; &lt;version&gt;2.1.2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt;&lt;/dependency&gt; ####使用gradle 依赖:12 compile 'com.sh.zsh.code:pickerview:2.1.2'//这个是支持农历的分支 compile 'com.bigkoo:pickerview:lunar.1.0' Demo 图片 demo代码请看戳这里 更新说明v2.1.2 增加设置选中item方法。 v2.1.1 修复dismiss时候点击背景会重复dismiss动画问题。 v2.1.0 去掉反射获取字符串，改为通过继承IPickerViewData。 解决多个PickerView同时存在时取消不了弹窗问题。 v2.0.9 解决属性和其他第三方库冲突问题。 v2.0.8 修复＃41 未选中项有错乱数据问题。 加入pickerview_customTextSize 和 pickerview_textsize 到 xml 中 来控制自定义文字大小 v2.0.7 修复设置初始化position ，第三级数据不对的BUG。 v2.0.6 修复不循环模式下点击超出范围问题，修复后点击空白的地方，只能滚到最顶或最底，不会滚出数据范围。 v2.0.5 修复不循环模式下底部超出范围问题 v2.0.4 修复不循环模式下顶部超出范围问题 wheel view文字颜色通过xml配置 v2.0.3 修复时间选择的时候部分数字选不到直接跳到下一个数字的问题 v2.0.2 修复不循环模式下点击空白item处出现数组越界问题 修复循环模式下只有一条数据的时候只显示三条而不是填充满高度问题 v2.0.1 去掉popupWindow，改用View，类名也对应修改为TimePickerView和 OptionsPickerView 加入遮罩效果 v2.0.0 不需修改任何代码就可以兼容1.x 外观大整改 支持反射获取getPickerViewText()来获取要展示数据，以前只能传String的对象，现在可以传任意对象只要有getPickerViewText()函数即可显示对应的字符串，如果没有getPickerViewText()函数则使用对象toString作为显示 加入setTitle -－－－－－－－－－－－－－－－－－－－－华丽丽的分割线－－－－－－－－－－－－－－－－－－－－－－－－－－ PickerView1.x (我已经把1.0.3版本分到v1.x的分支去了，停止维护1.x的分支)####使用gradle 依赖:1compile 'com.bigkoo:pickerview:1.0.3' Demo 图片（招行信用卡的“掌上生活”里面条件选择器他们用的就是我这个库，大家可以当实际项目参考） Thanks WheelView androidWheelView 源码地址:https://github.com/hui46226021/Android-PickerView","categories":[{"name":"Android","slug":"Android","permalink":"https://3431339973.github.io/categories/Android/"}],"tags":[{"name":"移动开发","slug":"移动开发","permalink":"https://3431339973.github.io/tags/移动开发/"},{"name":"原创","slug":"原创","permalink":"https://3431339973.github.io/tags/原创/"},{"name":"自定义view","slug":"自定义view","permalink":"https://3431339973.github.io/tags/自定义view/"}]},{"title":"Android分包MultiDex原理详解","slug":"Android分包MultiDex原理详解","date":"2015-09-17T14:37:23.000Z","updated":"2017-10-01T12:47:17.117Z","comments":true,"path":"2015/09/17/Android分包MultiDex原理详解/","link":"","permalink":"https://3431339973.github.io/2015/09/17/Android分包MultiDex原理详解/","excerpt":"摘要:windowIsTranslucent 和windowAnimationStyle冲突","text":"摘要:windowIsTranslucent 和windowAnimationStyle冲突 MultiDex的产生背景当Android系统安装一个应用的时候，有一步是对Dex进行优化，这个过程有一个专门的工具来处理，叫DexOpt。DexOpt的执行过程是在第一次加载Dex文件的时候执行的。这个过程会生成一个ODEX文件，即Optimised Dex。执行ODex的效率会比直接执行Dex文件的效率要高很多。 但是在早期的Android系统中，DexOpt有一个问题，DexOpt会把每一个类的方法id检索起来，存在一个链表结构里面。但是这个链表的长度是用一个short类型来保存的，导致了方法id的数目不能够超过65536个。当一个项目足够大的时候，显然这个方法数的上限是不够的。尽管在新版本的Android系统中，DexOpt修复了这个问题，但是我们仍然需要对低版本的Android系统做兼容。 为了解决方法数超限的问题，需要将该dex文件拆成两个或多个，为此谷歌官方推出了multidex兼容包，配合AndroidStudio实现了一个APK包含多个dex的功能。 MultiDex的简要原理我们以APK中有两个dex文件为例，第二个dex文件为classes2.dex。 兼容包在Applicaion实例化之后，会检查系统版本是否支持 multidex，classes2.dex是否需要安装。 如果需要安装则会从APK中解压出classes2.dex并将其拷贝到应用的沙盒目录下。 通过反射将classes2.dex注入到当前的classloader中。 下面引入一下官方的文档。 https://developer.android.com/tools/building/multidex.html#about 笔者，针对官方文档的翻译如下： 构建超过65K方法的App 随着Android设备的慢慢发展，App的大小会变得越来越大。当我们在开发App的时候由于报的大小和引用库的原因，我们在编译我们项目的时候通常会遇到下面一个错误：1Conversion to Dalvik format failed: Unable to execute dex: method ID not in [0, 0xffff]: 65536 当然，也有一些系统设备会出现以下log信息，不过反馈的是同一个问题：1trouble writing output:Too many field references: 131000; max is 65536.You may try using --multi-dex option. 这两个错误条件显示一个共同的数字：65536。这个数字，它表示的是你在一个dex包中的函数方法超过了65535个。 如果你已经构建了一个Android App时，并收到了这个错误，那么恭喜你，你有很多代码！ 下面我们就具体说说，如何解决这个问题。 关于65K方法限制我们知道Android中的可执行伟剑都存储在dex文件中，其中包含已编译的代码来运行你的应用程序。Dalvik虚拟机对可执行dex文件的规格是有方法限制的，即一个单一的dex文件的方法总数最多为65536。 其中包括： 引用的Android Framework方法 library的方法 我们自己书写代码的方法。 为了突破这个方法数的限制，我们就提出了一个方案——生成多个dex文件。这个多个dex文件的方案，我们又称为multidex方案配置。 Multidex支持Android 5.0之前的版本Android5.0版本的平台之前，Android使用的是Dalvik Runtime执行的程序代码。默认情况下，限制应用到一个单一的classes.dex。 Dalvik字节码文件每APK。为了绕过这个限制，你可以使用multidex支持库，成为你的应用程序的主要部分和DEX文件进行管理，获得额外的dex文件，它们包含的代码。 Multidex支持Android 5.0及更高版本Android 5.0和更高的Runtime 如art，本身就支持从应用的APK文件加载多个DEX文件。art支持预编译的应用程序在安装时扫描类（..）。Dex文件编译成一个单一的Android设备上执行.oat文件。 避免65K限制当你确定使用multidex的分包策略的时候，请你先确定自己的代码中都是优秀的。你还需要做以下几步： 去掉一些未使用的import和library 使用ProGuard去掉一些未使用的代码 用Gradle配置使用MultidexAndroid 的 Gradle插件在 Android Build Tool 21.1开始就支持使用multidex了。 设置你的应用程序开发项目中使用multidex配置，要求你做出一些修改您的应用程序开发项目。： 修改Gradle的配置，支持multidex 修改你的manifest。让其支持multidexapplication类 修改Gradle的build如下：123456789101112131415android &#123; compileSdkVersion 21 buildToolsVersion \"21.1.0\" defaultConfig &#123; ... minSdkVersion 14 targetSdkVersion 21 ... // Enabling multidex support. multiDexEnabled true &#125; ...&#125;dependencies &#123; compile ‘com.android.support:multidex:1.0.0‘&#125; Tips: 你可以在Gradle配置文件中的 multiDexEnabled 在 defaultConfig、buildType、productFlavor选项设置。 在manifest文件中，添加MultidexApplication Class的引用，如下所示：1234567&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.example.android.multidex.myapplication\"&gt; &lt;application ... android:name=\"android.support.multidex.MultiDexApplication\"&gt; ... &lt;/application&gt;&lt;/manifest&gt; 当然，如果你重写了 Application，就对自定义Application的继承方式做一个修改。 Multidex的方式的局限性虽然我们开起来multidex是一个极好的东西，但是multidex还是存在自己的局限性，我们在开发测试之前要清楚局限性是什么： 如果二DEX文件太大，安装分割dex文件是一个复杂的过程，可能会导致应用程序无响应（ANR）的错误。在这种情况下，你应该尽量的减小dex文件的大小和删除无用的逻辑，而不是完全依赖于multidex。 在Android 4.0设备（API Level 14）之前，由于Dalvik linearalloc bug（问题22586），multidex很可能是无法运行的。如果希望运行在Level 14之前的Android系统版本，请先确保完整的测试和使用。 应用程序使用了multiedex配置的，会造成使用比较大的内存。当然，可能还会引起dalvik虚拟机的崩溃(issue 78035)。 对于应用程序比较复杂的，存在较多的library的项目。multidex可能会造成不同依赖项目间的dex文件函数相互调用，找不到方法。 优化multidex开发和构建一个multidex的配置，对系统apk的构建、签名、打包复杂性大大的增加。这就意味着，你每一次的构建过程都是相当耗时的。 为了加快我们的开发速度，加快构建的过程，我们可以在Gradle productFlavors新建出来一个 development flavor 和 production flavor 来满足我们不同构建需求。 下面是一个列子演示我们如何设置这些flavors在Gradle build文件中:1234567891011121314151617181920212223android &#123; productFlavors &#123; // Define separate dev and prod product flavors. dev &#123; // dev utilizes minSDKVersion = 21 to allow the Android gradle plugin // to pre-dex each module and produce an APK that can be tested on // Android Lollipop without time consuming dex merging processes. minSdkVersion 21 &#125; prod &#123; // The actual minSdkVersion for the application. minSdkVersion 14 &#125; &#125; ... buildTypes &#123; release &#123; runProguard true proguardFiles getDefaultProguardFile(‘proguard-android.txt‘), ‘proguard-rules.pro‘ &#125; &#125;&#125;dependencies &#123; compile ‘com.android.support:multidex:1.0.0‘&#125; 在你完成了伤处的配置修改之后，你配置productFlavor 和 buildType来使用 ，devDebug 变种app。使用这些变种app，可以设置proguard disable、multidex enable方便我们测试。 这些配置需要针对Android Gradle插件做如下操作： 在分包前，编译应用程序中的每一个module包括依赖项目，这个步骤称为 pre-dexing。 include每一个dex文件 最重要的是，对于主dex文件，不会做切分。以保证计算速度。 这样设置既能够保证我们的最终报是一个使用了multidex模式的，而又不影响我们平时开发的测试效率。 在Android Studio中使用变种App使用multidex工具构建变种App是非常方便的。在Android Studio允许我们选择这种变种构建方式的接口。 使用Android Studio构建 “devDebug”构建变种app需要完成两步： 打开变种编辑窗口，选择favorites选项。 点击编译不同的变种，如下图所示 原文地址：http://www.mamicode.com/info-detail-1031299.html","categories":[{"name":"Android","slug":"Android","permalink":"https://3431339973.github.io/categories/Android/"}],"tags":[{"name":"移动开发","slug":"移动开发","permalink":"https://3431339973.github.io/tags/移动开发/"},{"name":"原创","slug":"原创","permalink":"https://3431339973.github.io/tags/原创/"},{"name":"MultiDex","slug":"MultiDex","permalink":"https://3431339973.github.io/tags/MultiDex/"},{"name":"65535","slug":"65535","permalink":"https://3431339973.github.io/tags/65535/"}]},{"title":"谈谈Android ROOT 原理","slug":"谈谈AndroidRoot原理","date":"2015-08-21T13:17:28.000Z","updated":"2017-10-02T11:41:09.337Z","comments":true,"path":"2015/08/21/谈谈AndroidRoot原理/","link":"","permalink":"https://3431339973.github.io/2015/08/21/谈谈AndroidRoot原理/","excerpt":"摘要:经常有人问，你手机root了吗，那么root了到底是什么意思，root了之后能赶上吗？","text":"摘要:经常有人问，你手机root了吗，那么root了到底是什么意思，root了之后能赶上吗？ ROOT 是什么？在操作系统里，一般有两种用户，管理员 和普通用户，两者最大的区别在于 用户对系统的操作权限有高有低。管理员权限 对系统有着毁天灭地的能力，熟悉windows的人都知道 一般有个Administrator（管理员）用户，而在Linux系统里（包括Android）这个管理用户的统一名字 叫ROOT 怎么切换到ROOT用户熟悉Linux的同学都知道 一般情况下，Linux下root用户默认是没有密码 可以 用su root 命令 切换到 root用户。 但是在android中 没有su命令。但是我们可以通过adb 把su文件放到/system/bin/下面这样 我们就可以执行su命令了 1adb push su /system/bin 当我们在root的过程中，还会给系统装一个程序，用来作为运行提示，由用户来决定，是否给予最高权限。这个程序的名字叫做Superuser.apk。当某些程序执行su指令想取得系统最高权限的时候，Superuser就会自动启动，拦截该动作并作出询问，当用户认为该程序可以安全使用的时候，那么我们就选择允许，否则，可以禁止该程序继续取得最高权限 我们将这个APK放到system/app 1adb push su /system/bin 这还没完 ，我们还需要让 su 文件可以让任何用户都能执行，所系需要设置他的访问权限 1adb shell chmod 4755 /system/bin/su 总结：手机ROOT 实际上就是干了3件事 1：把su文件放到/system/bin/下面 2：把Superuser.apk放到/system/app/下面 3：修改su文件的访问权限 一切都是那么完美，就差干了，但是 我们是不是想简单了 ROOT 真的这么容易吗如果是eng 版本的android系统（先理解成开发版吧） 那么完成这3部我们就大工告成了，但是现实就是这么苟且，我们的手机不是eng版而是user版，最大的问题在于 user版system/bin只有只读权限。 我们需要ROOT权限才能 把 su文件push到system/bin目录下，然后获取ROOT权限 却需要把su文件，这里就出现了一个 逻辑的死循环。还有些系统 会在启动的时候 就删除su文件。哈哈哈 这就搞不下去了。那怎么办，只有去找每个厂商发布系统的漏洞了。深入理解Root机制 来源 http://blog.csdn.net/chaihuasong/article/details/8463212/其流程是： Su 被用户调用 Su 创建了一个socket监听 Su 向Superuser发送了一个广播，说是有一个程序要请求root Su 等待socket 数据接收。有超时处理。 Superuser 界面收到广播后，弹出一个对话框，询问用户 Superuser 向传来的数据中的socket写回用户应答结果。 Su 根据socket得到的结果处理应该不应该继续执行 完成提权管理superuser.apk这个程序是root成功后，专门用来管理root权限使用的，防止被恶意程序滥用。 源码地址： http://superuser.googlecode.com/svn/trunk 我们有两点疑问： superuser是怎么知道谁想用root权限？ superuser是如何把用户的选择告诉su程序的？ 即superuser和su程序是如何通讯的，他们俩位于不通的时空，一个在java虚拟中，一个在linux的真实进程中。 superuser共有两个activity: SuperuserActivity和 SuperuserRequestActivity，其中SuperuserActivity主要是用来管理白名单的，就是记住哪个程序已经被允许使用root权限了，省的每次用时都问用户。 SuperuserRequestActivity 就是用来询问用户目前有个程序想使用root权限，是否允许，是否一直允许，即放入白名单。 这个白名单比较关键，是一个sqlite数据库文件，位置： /data/data/com.koushikdutta.superuser/databases/superuser.sqlite 上文说过，root的本质就是往 /system/bin/下放一个su文件，不检查调用者权限的su文件。普通程序可以调用该su来运行root权限的命令。superuser.apk中就自带了一个这样的su程序。一开始superuser会检测/system/bin/su是否存在: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475File su = new File(\"/system/bin/su\"); // 检测su文件是否存在,如果不存在则直接返回 if (!su.exists()) &#123; Toast toast = Toast.makeText(this, \"Unable to find /system/bin/su.\", Toast.LENGTH_LONG); toast.show(); return; &#125; //如果大小一样，则认为su文件正确，直接返回了事。 if (su.length() == suStream.available()) &#123; suStream.close(); return; // &#125; // 如果检测到/system/bin/su文件存在，但是不对头，则把自带的su先写到\"/data/data/com.koushikdutta.superuser/su\" //再写到/system/bin/su。 byte[] bytes = new byte[suStream.available()]; DataInputStream dis = new DataInputStream(suStream); dis.readFully(bytes); FileOutputStream suOutStream = new FileOutputStream(\"/data/data/com.koushikdutta.superuser/su\"); suOutStream.write(bytes); suOutStream.close(); Process process = Runtime.getRuntime().exec(\"su\"); DataOutputStream os = new DataOutputStream(process.getOutputStream()); os.writeBytes(\"mount -oremount,rw /dev/block/mtdblock3 /system\\n\"); os.writeBytes(\"busybox cp /data/data/com.koushikdutta.superuser/su /system/bin/su\\n\"); os.writeBytes(\"busybox chown 0:0 /system/bin/su\\n\"); os.writeBytes(\"chmod 4755 /system/bin/su\\n\"); os.writeBytes(\"exit\\n\"); os.flush(); ~~~ 有进程使用root权限，superuser是怎么知道的呢，关键是句：~~~c++sprintf(sysCmd, \"am start -a android.intent.action.MAIN -n com.koushikdutta.superuser/com.koushikdutta.superuser.SuperuserRequestActivity --ei uid %d --ei pid %d &gt; /dev/null\", g_puid, ppid); if (system(sysCmd)) return executionFailure(\"am.\"); 原理是am命令，am的用法： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465usage: am [subcommand] [options] start an Activity: am start [-D] [-W] &lt;INTENT&gt; -D: enable debugging -W: wait for launch to complete start a Service: am startservice &lt;INTENT&gt; send a broadcast Intent: am broadcast &lt;INTENT&gt; start an Instrumentation: am instrument [flags] &lt;COMPONENT&gt; -r: print raw results (otherwise decode REPORT_KEY_STREAMRESULT) -e &lt;NAME&gt; &lt;VALUE&gt;: set argument &lt;NAME&gt; to &lt;VALUE&gt; -p &lt;FILE&gt;: write profiling data to &lt;FILE&gt; -w: wait for instrumentation to finish before returning start profiling: am profile &lt;PROCESS&gt; start &lt;FILE&gt; stop profiling: am profile &lt;PROCESS&gt; stop &lt;INTENT&gt; specifications include these flags: [-a &lt;ACTION&gt;] [-d &lt;DATA_URI&gt;] [-t &lt;MIME_TYPE&gt;] [-c &lt;CATEGORY&gt; [-c &lt;CATEGORY&gt;] ...] [-e|--es &lt;EXTRA_KEY&gt; &lt;EXTRA_STRING_VALUE&gt; ...] [--esn &lt;EXTRA_KEY&gt; ...] [--ez &lt;EXTRA_KEY&gt; &lt;EXTRA_BOOLEAN_VALUE&gt; ...] [-e|--ei &lt;EXTRA_KEY&gt; &lt;EXTRA_INT_VALUE&gt; ...] [-n &lt;COMPONENT&gt;] [-f &lt;FLAGS&gt;] [--grant-read-uri-permission] [--grant-write-uri-permission] [--debug-log-resolution] [--activity-brought-to-front] [--activity-clear-top] [--activity-clear-when-task-reset] [--activity-exclude-from-recents] [--activity-launched-from-history] [--activity-multiple-task] [--activity-no-animation] [--activity-no-history] [--activity-no-user-action] [--activity-previous-is-top] [--activity-reorder-to-front] [--activity-reset-task-if-needed] [--activity-single-top] [--receiver-registered-only] [--receiver-replace-pending] [&lt;URI&gt;]&lt;span style=\"font-family:Calibri;font-size:14px;\"&gt; &lt;/span&gt; 还有个疑点，就是su怎么知道用户是允许root权限还是反对呢？原来是上面提到的白名单起来作用，superuser把用户的选择放入： /data/data/com.koushikdutta.superuser/databases/superuser.sqlite 数据库中，然后su进程再去读该数据库来判断是否允许。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647static int checkWhitelist() &#123; sqlite3 *db; int rc = sqlite3_open_v2(DBPATH, &amp;db, SQLITE_OPEN_READWRITE, NULL); if (!rc) &#123; char *errorMessage; char query[1024]; sprintf(query, \"select * from whitelist where _id=%d limit 1;\", g_puid); struct whitelistCallInfo callInfo; callInfo.count = 0; callInfo.db = db; rc = sqlite3_exec(db, query, whitelistCallback, &amp;callInfo, &amp;errorMessage); if (rc != SQLITE_OK) &#123; sqlite3_close(db); return 0; &#125; sqlite3_close(db); return callInfo.count; &#125; sqlite3_close(db); return 0; &#125; 以上就是关于ROOT 的一部知识","categories":[{"name":"Android","slug":"Android","permalink":"https://3431339973.github.io/categories/Android/"}],"tags":[{"name":"移动开发","slug":"移动开发","permalink":"https://3431339973.github.io/tags/移动开发/"},{"name":"Android","slug":"Android","permalink":"https://3431339973.github.io/tags/Android/"},{"name":"系统","slug":"系统","permalink":"https://3431339973.github.io/tags/系统/"},{"name":"ROOT","slug":"ROOT","permalink":"https://3431339973.github.io/tags/ROOT/"}]},{"title":"Android开发--Intent-filter属性详解","slug":"Intent-filter属性详解","date":"2015-08-17T14:37:23.000Z","updated":"2017-10-01T12:49:26.761Z","comments":true,"path":"2015/08/17/Intent-filter属性详解/","link":"","permalink":"https://3431339973.github.io/2015/08/17/Intent-filter属性详解/","excerpt":"摘要: 一直没有对 Intent-filter 做过多的了解 可能之前 做的项目比较弱 没有被其他程序调用过 这次正好有机会学习了 记录下","text":"摘要: 一直没有对 Intent-filter 做过多的了解 可能之前 做的项目比较弱 没有被其他程序调用过 这次正好有机会学习了 记录下 如果一个 Intent 请求在一片数据上执行一个动作， Android 如何知道哪个应用程序（和组件）能用来响应这个请求呢？ Intent Filter就是 用来注册 Activity 、 Service 和 Broadcast Receiver 具有能在某种数据上执行一个动作的能力。使用 Intent Filter ，应用程序组件告诉 Android ，它们能为其它程序的组件的动作请求提供服务，包括同一个程序的组件、本地的或第三方的应用程序。 为了注册一个应用程序组件为 Intent 处理者，在组件的 manifest 节点添加一个 intent-filter 标签。 在 Intent Filter 节点里使用下面的标签（关联属性），你能指定组件支持的动作、种类和数据： 1．动作测试元素中可以包括子元素，比如：view source print ? &lt; intent-filter &gt; &lt; action android:name=”com.example.project.SHOW_CURRENT” /&gt; &lt; action android:name=”com.example.project.SHOW_RECENT” /&gt; &lt; action android:name=”com.example.project.SHOW_PENDING” /&gt; &lt;/ intent-filter &gt;一条元素至少应该包含一个，否则任何Intent请求都不能和该匹配。如果Intent请求的Action和中个某一条匹配，那么该Intent就通过了这条的动作测试。如果Intent请求或中没有说明具体的Action类型，那么会出现下面两种情况。(1) 如果中没有包含任何Action类型，那么无论什么Intent请求都无法和这条匹配；(2) 反之，如果Intent请求中没有设定Action类型，那么只要中包含有Action类型，这个Intent请求就将顺利地通过的行为测试。 2．类别测试元素可以包含子元素，比如：view source print ? &lt; intent-filter . . . &gt; &lt; category android:name=”android.Intent.Category.DEFAULT” /&gt; &lt; category android:name=”android.Intent.Category.BROWSABLE” /&gt; &lt;/ intent-filter &gt;只有当Intent请求中所有的Category与组件中某一个IntentFilter的完全匹配时，才会让该 Intent请求通过测试，IntentFilter中多余的声明并不会导致匹配失败。一个没有指定任何类别测试的 IntentFilter仅仅只会匹配没有设置类别的Intent请求。 3．数据测试数据在中的描述如下：view source print ? &lt; intent-filter . . . &gt; &lt; data android:type=”video/mpeg” android:scheme=”http” . . . /&gt; &lt; data android:type=”audio/mpeg” android:scheme=”http” . . . /&gt; &lt;/ intent-filter &gt;元素指定了希望接受的Intent请求的数据URI和数据类型，URI被分成三部分来进行匹配：scheme、 authority和path。其中，用setData()设定的Inteat请求的URI数据类型和scheme必须与IntentFilter中所指定的一致。若IntentFilter中还指定了authority或path，它们也需要相匹配才会通过测试。 action使用 android:name 特性来指定对响应的动作名。动作名必须是独一无二的字符串，所以，一个好的习惯是使用基于 Java 包的命名方式的命名系统。 category使用 Android:category 属性用来指定在什么样的环境下动作才被响应。每个 Intent Filter 标签可以包含多个 category 标签。你可以指定自定义的种类或使用 Android 提供的标准值，如下所示： ALTERNATIVE你将在这章的后面所看到的，一个 Intent Filter 的用途是使用动作来帮忙填入上下文菜单。 ALTERNATIVE 种类指定，在某种数据类型的项目上可以替代默认执行的动作。例如，一个联系人的默认动作时浏览它，替代的可能是去编辑或删除它。 SELECTED_ALTERNATIVE与 ALTERNATIVE 类似，但 ALTERNATIVE 总是使用下面所述的 Intent 解析来指向单一的动作。SELECTED_ALTERNATIVE在需要一个可能性列表时使用。 BROWSABLE指定在浏览器中的动作。当 Intent 在浏览器中被引发，都会被指定成 BROWSABLE 种类。 DEFAULT设置这个种类来让组件成为 Intent Filter 中定义的 data 的默认动作。这对使用显式 Intent 启动的 Activity 来说也是必要的。 GADGET通过设置 GADGET 种类，你可以指定这个 Activity 可以嵌入到其他的 Activity 来允许。 HOMEHOME Activity 是设备启动（登陆屏幕）时显示的第一个 Activity 。通过指定 Intent Filter 为 HOME 种类而不指定动作的话，你正在将其设为本地 home 画面的替代。 LAUNCHER使用这个种类来让一个 Activity 作为应用程序的启动项。 datadata 标签允许你指定组件能作用的数据的匹配；如果你的组件能处理多个的话，你可以包含多个条件。你可以使用下面属性的任意组合来指定组件支持的数据： android:host指定一个有效的主机名（例如， com.google ）。 android:mimetype允许你设定组件能处理的数据类型。例如，能匹配任何 Android 游标。 android:path有效地 URI 路径值（例如， /transport/boats/ ）。 android:port特定主机上的有效端口。 android:scheme需要一个特殊的图示（例如， content 或 http ）。 接下来的代码片段显示了如何配置 Activity 的 Intent Filter ，使其以在特定数据下的默认的或可替代的动作的身份来执行 SHOW_DAMAGE动作.1234567891011121314151617181920212223242526272829 &lt;activity android:name=\".EarthquakeDamageViewer\" android:label=\"View Damage\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"com.paad.earthquake.intent.action.SHOW_DAMAGE\"&gt; &lt;/action&gt; &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt; &lt;category android:name=\"android.intent.category.ALTERNATIVE_SELECTED\" /&gt; &lt;data android:mimeType=\"vnd.earthquake.cursor.item/*\"/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=\".EarthquakeDamageViewer\" android:label=\"View Damage\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"com.paad.earthquake.intent.action.SHOW_DAMAGE\"&gt; &lt;/action&gt; &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt; 原文地址：http://blog.csdn.net/wuwenxiang91322/article/details/7671593","categories":[{"name":"Android","slug":"Android","permalink":"https://3431339973.github.io/categories/Android/"}],"tags":[{"name":"移动开发","slug":"移动开发","permalink":"https://3431339973.github.io/tags/移动开发/"},{"name":"Intent-filter","slug":"Intent-filter","permalink":"https://3431339973.github.io/tags/Intent-filter/"},{"name":"转载","slug":"转载","permalink":"https://3431339973.github.io/tags/转载/"}]},{"title":"windowIsTranslucent 和windowAnimationStyle冲突","slug":"windowIsTranslucent 和windowAnimationStyle冲突","date":"2015-06-17T14:37:23.000Z","updated":"2017-10-02T16:26:53.658Z","comments":true,"path":"2015/06/17/windowIsTranslucent 和windowAnimationStyle冲突/","link":"","permalink":"https://3431339973.github.io/2015/06/17/windowIsTranslucent 和windowAnimationStyle冲突/","excerpt":"摘要:windowIsTranslucent 和windowAnimationStyle冲突","text":"摘要:windowIsTranslucent 和windowAnimationStyle冲突 今天在写 android仿IOS 侧滑销毁的时候 需要把activity的背景设置成透明 在滑出的时候漏出 栈下面一层的activity 在AppTheme里面 设置了windowIsTranslucent 属性123456&lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.NoActionBar\"&gt; &lt;item name=\"colorPrimary\"&gt;#333333&lt;/item&gt; &lt;item name=\"colorPrimaryDark\"&gt;#333333&lt;/item&gt; &lt;item name=\"android:windowAnimationStyle\"&gt;@style/MyActivitySiwtchAnimation&lt;/item&gt; &lt;item name=\"android:windowBackground\"&gt;@color/transparent&lt;/item&gt; &lt;item name=\"android:windowIsTranslucent\"&gt;true&lt;/item&gt; &lt;/style&gt; 这里之前设置过 activity 切换动画接下来 问题来了 设置windowIsTranslucent 后android:windowAnimationStyle 失效了，不好使了 差了写资料 已解决 再次记录下123456789101112&lt;style name=\"MyActivitySiwtchAnimation\" parent=\"@android:style/Animation.Translucent\"&gt; &lt;!--创建效果--&gt; &lt;!--&lt;item name=\"@android:activityOpenEnterAnimation\"&gt;@anim/out_from_right&lt;/item&gt;--&gt; &lt;!--&amp;lt;!&amp;ndash;上一个被覆盖效果&amp;ndash;&amp;gt;--&gt; &lt;!--&lt;item name=\"@android:activityOpenExitAnimation\"&gt;@anim/out_middle&lt;/item&gt;--&gt; &lt;!--&amp;lt;!&amp;ndash;推出效果&amp;ndash;&amp;gt;--&gt; &lt;!--&lt;item name=\"@android:activityCloseExitAnimation\"&gt;@anim/out_toleft&lt;/item&gt;--&gt; &lt;!--&amp;lt;!&amp;ndash;上一个还原效果&amp;ndash;&amp;gt;--&gt; &lt;!--&lt;item name=\"@android:activityCloseEnterAnimation\"&gt;@anim/out_middle2&lt;/item&gt;--&gt; &lt;item name=\"android:windowEnterAnimation\"&gt;@anim/out_from_right&lt;/item&gt; &lt;item name=\"android:windowExitAnimation\"&gt;@anim/out_toleft&lt;/item&gt; &lt;/style&gt; 1.让 android:windowAnimationStyle 继承 @android :style/Animation.Translucent此方法 在退出actvity时候动画有效 创建的时候无效 212&lt;item name=\"android:windowEnterAnimation\"&gt;@anim/out_from_right&lt;/item&gt; &lt;item name=\"android:windowExitAnimation\"&gt;@anim/out_toleft&lt;/item&gt; 此方法有效。不过本人是坑爹的锤子手机 在activity切换的时候 自带 一个由下到上的动画 目前的状态是 创建activity是重屏幕右下角出现 ，在其他手机上 还可以 方法二：绝对完美解决取消1&lt;item name=\"android:windowAnimationStyle\"&gt;@style/MyActivitySiwtchAnimation&lt;/item&gt; 改在 activity 和 fragment的基类里 重写1234567891011121314151617181920212223242526272829/** * 重写 activity切换方法 消除系统自带动画 * @param intent */ @Override public void startActivity(Intent intent) &#123; super.startActivity(intent); overridePendingTransition(R.anim.out_from_right,android.R.anim.slide_out_right); &#125; @Override public void finish() &#123; super.finish(); overridePendingTransition(R.anim.out_from_right,android.R.anim.slide_out_right); &#125; @Override public void startActivityForResult(Intent intent, int requestCode, @Nullable Bundle options) &#123; super.startActivityForResult(intent, requestCode, options); overridePendingTransition(R.anim.out_from_right,android.R.anim.slide_out_right); &#125; @Override public void startActivityForResult(Intent intent, int requestCode) &#123; super.startActivityForResult(intent, requestCode); overridePendingTransition(R.anim.out_from_right,android.R.anim.slide_out_right); &#125; 实现 切换动画 这里收集了一些系统动画 //实现淡入浅出的效果1overridePendingTransition(android.R.anim.fade_in,android.R.anim.fade_out); // 由左向右滑入的效果1overridePendingTransition(android.R.anim.slide_in_left,android.R.anim.slide_out_right);","categories":[{"name":"Android","slug":"Android","permalink":"https://3431339973.github.io/categories/Android/"}],"tags":[{"name":"移动开发","slug":"移动开发","permalink":"https://3431339973.github.io/tags/移动开发/"},{"name":"原创","slug":"原创","permalink":"https://3431339973.github.io/tags/原创/"},{"name":"windowIsTranslucent","slug":"windowIsTranslucent","permalink":"https://3431339973.github.io/tags/windowIsTranslucent/"}]},{"title":"Android动画 详解(二 帧动画 属性动画 )","slug":"Android动画 详解(二 帧动画 属性动画 )","date":"2015-05-17T14:37:23.000Z","updated":"2017-10-01T12:47:24.409Z","comments":true,"path":"2015/05/17/Android动画 详解(二 帧动画 属性动画 )/","link":"","permalink":"https://3431339973.github.io/2015/05/17/Android动画 详解(二 帧动画 属性动画 )/","excerpt":"","text":"一 帧动画介绍帧动画 就类似于 电影那种一张图一张图的切换 XML代码先通过XML配置好 需要切换的图片 和 执行是否循环 和执行时间等 文件放在res/drawable 目录下 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;!-- oneshot代表着是否只展示一遍，false 不停的循环播放动画 android:duration 时间长度 --&gt; &lt;animation-list xmlns:android=\"http://schemas.android.com/apk/res/android\" android:oneshot=\"true\" &gt; &lt;item android:drawable=\"@drawable/icon6\" android:duration=\"150\"&gt;&lt;/item&gt; &lt;item android:drawable=\"@drawable/icon5\" android:duration=\"150\"&gt;&lt;/item&gt; &lt;item android:drawable=\"@drawable/icon4\" android:duration=\"150\"&gt;&lt;/item&gt; &lt;item android:drawable=\"@drawable/icon3\" android:duration=\"150\"&gt;&lt;/item&gt; &lt;item android:drawable=\"@drawable/icon2\" android:duration=\"150\"&gt;&lt;/item&gt; &lt;item android:drawable=\"@drawable/icon1\" android:duration=\"150\"&gt;&lt;/item&gt; &lt;/animation-list&gt; JAVA调用XML开启动画先创建一个IamgeView 将其背景设置成 之前配置好的xml 1234ImageView imageView = (ImageView) findViewById(R.id.imageView); imageView.setImageResource(R.drawable.animation1); AnimationDrawable animationDrawable = (AnimationDrawable) animationIV.getDrawable(); animationDrawable.start(); 注意事项要在代码中调用 ImageView 的 setBackgroundResource 方法，如果直接在 XML 布局文件中设置其 src 属性当触发动画时会 ForceClose ； 在动画 start 之前要先 stop，不然在第一次动画之后会停在最后一帧，这样动画就只会触发一次； 正如SDK中所提到的，不要在 onCreate 中调用 start，因为 AnimationDrawable 还没有完全跟 Window 相关联，如果想要界面显示时就开始动画的话，可以在 onWindowFoucsChanged 中调用 start 。 属性动画 属性动画指的是 通过改变view 的属性来实现动画 跟补间动画本质的区别在于 补间动画 在改变的只是样子 例如将一个Button 放大 补间动画 放大后 其点击时间 并没有变 还是原来的大小 具体先看这篇文章 http://blog.csdn.net/lmj623565791/article/details/38067475 插值器 Interpolator class Resource ID 备注 AccelerateDecelerateInterpolator @android:anim/accelerate_decelerate_interpolator 加速减速 AccelerateInterpolator @android:anim/accelerate_interpolator 加速 AnticipateInterpolator @android:anim/anticipate_interpolator 退小步往前冲 AnticipateOvershootInterpolator @android:anim/anticipate_overshoot_interpolator 退小步冲过头退回 BounceInterpolator @android:anim/bounce_interpolator 球落地弹动效果 CycleInterpolator @android:anim/cycle_interpolator 周期重复 DecelerateInterpolator @android:anim/decelerate_interpolator 减速 LinearInterpolator @android:anim/linear_interpolator 匀速 OvershootInterpolator @android:anim/overshoot_interpolator 冲过头再退回","categories":[{"name":"Android","slug":"Android","permalink":"https://3431339973.github.io/categories/Android/"}],"tags":[{"name":"原创","slug":"原创","permalink":"https://3431339973.github.io/tags/原创/"},{"name":"动画","slug":"动画","permalink":"https://3431339973.github.io/tags/动画/"}]},{"title":"Android动画 详解（一 补间动画）","slug":"Android动画 详解（一 补间动画）","date":"2015-05-17T11:42:33.000Z","updated":"2017-10-02T10:42:17.919Z","comments":true,"path":"2015/05/17/Android动画 详解（一 补间动画）/","link":"","permalink":"https://3431339973.github.io/2015/05/17/Android动画 详解（一 补间动画）/","excerpt":"打算整理下 android动画方面的知识，嗯 开始","text":"打算整理下 android动画方面的知识，嗯 开始 一.android补间动画 分为四大类alpha（透明度渐变）、scale（尺寸渐变）、translate（位置移动）、rotate（旋转） 通过JAVA类来表示 AlphaAnimation ScaleAnimation TranslateAnimation RotateAnimation 二.可以通过 XML文件 或者JAVA代码的方式来实现动画1.动过XML来实现动画在res目录中新建anim文件夹在anim目录中新建一个anim.xml1234567&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;alpha/&gt; &lt;scale/&gt; &lt;translate/&gt; &lt;rotate/&gt; &lt;/set&gt; XML动画详细解析 alpha说明: 0.0表示完全透明 1.0表示完全不透明 时间以毫秒为单位 123456&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\" &gt; &lt;alpha android:fromAlpha=\"0.1\" &lt;!--动画起始时透明度 --&gt; android:toAlpha=\"1.0\" &lt;!--动画结束时透明度 --&gt; android:duration=\"3000\" /&gt; &lt;!--动画持续时间--&gt; &lt;/set&gt; Scale说明: 插入器 下一篇详细说 pivotX pivotY 确定了 放大缩小的中心 上面4个属性 定义了开始 和结束的比例 1放大 12345678910111213141516171819202122&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;scale android:interpolator= \"@android:anim/accelerate_decelerate_interpolator\" &lt;!--interpolator 指定一个动画的插入器 --&gt; android:fromXScale=\"0.0\" &lt;!--起始时 X坐标上的伸缩尺寸 --&gt; android:toXScale=\"1.4\" &lt;!--结束时 X坐标上的伸缩尺寸 --&gt; android:fromYScale=\"0.0\" &lt;!--起始时Y坐标上的伸缩尺寸 --&gt; android:toYScale=\"1.4\" &lt;!--结束时Y坐标上的伸缩尺寸 --&gt; android:pivotX=\"50%\" &lt;!--属性为动画相对于物件的X坐标的开始位置 --&gt; android:pivotY=\"50%\" &lt;!--属性为动画相对于物件的Y坐标的开始位置 --&gt; android:fillAfter=\"false\" &lt;!--当设置为true ，该动画转化在动画结束后被应用 --&gt; android:duration=\"700\" &lt;!--时间 --&gt; /&gt; &lt;/set&gt; Translate 说明：没啥说的了12345678910111213141516 &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;translate android:fromXDelta=\"30\" &lt;!--始时 X坐标上的位置 --&gt; android:toXDelta=\"-80\" &lt;!--结束时 X坐标上的位置 --&gt; android:fromYDelta=\"30\" &lt;!--起始时 Y坐标上的位置 --&gt; android:toYDelta=\"300\" &lt;!--结束时 Y坐标上的位置 --&gt; android:duration=\"2000\" &lt;!--时间--&gt; /&gt; &lt;/set&gt; Rotate 说明：其实也没啥好说的了12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;rotate android:interpolator=\"@android:anim/accelerate_decelerate_interpolator\" &lt;!--动画的插入器 --&gt; android:fromDegrees=\"0\" &lt;!--动画起始时物件的角度 --&gt; android:toDegrees=\"+350\" &lt;!--画结束时物件旋转的角度 可以大于360度 --&gt; android:pivotX=\"50%\" &lt;!--X坐标的开始位置 --&gt; android:pivotY=\"50%\" &lt;!--Y坐标的开始位置 --&gt; android:duration=\"3000\" /&gt; &lt;/set&gt; 在JAVA 代码中调用XML12 Animation myAnimation= AnimationUtils.loadAnimation(this, R.anim.my_action); //使用AnimationUtils类的静态方法loadAnimation()来加载XML中的动画XML文件 2 试用JAVA 代码 来创建动画 说明 具体参数含义 可对照上面的XML1234567891011121314151617181920212223242526272829303132333435//在代码中定义 动画实例对象private Animation myAnimation_Alpha;private Animation myAnimation_Scale;private Animation myAnimation_Translate;private Animation myAnimation_Rotate;//根据各自的构造方法来初始化一个实例对象myAnimation_Alpha = new AlphaAnimation(0.1f, 1.0f);myAnimation_Scale = new ScaleAnimation(0.0f, 1.4f, 0.0f, 1.4f,Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);myAnimation_Translate = new TranslateAnimation(30.0f, -80.0f, 30.0f, 300.0f);myAnimation_Rotate = new RotateAnimation(0.0f, +350.0f,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF, 0.5f);设置动画监听，注意 当控件移动后 其点击事件 还在原来的未知 需要调用view.layout(x,x,x,x);方法修改下 控件的未知animation.setAnimationListener(new Animation.AnimationListener() &#123; @Override public void onAnimationStart(Animation animation) &#123; &#125; @Override public void onAnimationRepeat(Animation animation) &#123; &#125; @Override public void onAnimationEnd(Animation animation) &#123; &#125; &#125;);最后 就查给控件添加上 创建好的动画 并启动了view.startAnimation(animation); 谢谢","categories":[{"name":"Android","slug":"Android","permalink":"https://3431339973.github.io/categories/Android/"}],"tags":[{"name":"原创","slug":"原创","permalink":"https://3431339973.github.io/tags/原创/"},{"name":"动画","slug":"动画","permalink":"https://3431339973.github.io/tags/动画/"}]},{"title":"Android代码和JS 相互调用 html js","slug":"Android代码和JS 相互调用 html js","date":"2015-02-12T03:37:23.000Z","updated":"2017-10-02T16:25:33.627Z","comments":true,"path":"2015/02/12/Android代码和JS 相互调用 html js/","link":"","permalink":"https://3431339973.github.io/2015/02/12/Android代码和JS 相互调用 html js/","excerpt":"摘要:今天接到需求要调用相机拍照 但页面是H5写的 所以研究了下 android里 JAVA 代码和JS 相互调用这方面的姿势","text":"摘要:今天接到需求要调用相机拍照 但页面是H5写的 所以研究了下 android里 JAVA 代码和JS 相互调用这方面的姿势 一:JS调用 JAVA1.首先让webview 支持JS1webView.getSettings().setJavaScriptEnabled(true); 2.注入 Java 对象到 WebView 中。12JSKit js = new JSKit(this); mWebView.addJavascriptInterface(js, \"myjs\"); 1234567891011121314/** * Created by zhush on 2016/5/3. */public class JSKit &#123; private MainActivity ma; public JSKit(MainActivity context) &#123; this.ma = context; &#125; @JavascriptInterface public void showMsg(String msg) &#123; Toast.makeText(ma, msg, Toast.LENGTH_SHORT).show(); &#125;&#125; 注意：在 JELLY_BEAN_MR1以后 需要在被调用的方法上加 @JavascriptInterface 要不然调用会失败[Android版本和API Level对应关系]（http://blog.csdn.net/huiguixian/article/details/39928027） 3.JS代码12345678910111213141516171819&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html40/strict.dtd\"&gt;&lt;HTML&gt;&lt;HEAD&gt; &lt;meta name=\"viewport\" content=\"width=device-width, target-densitydpi=device-dpi\" /&gt; &lt;META http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;script&gt; function showMsgInAndroid()&#123; myjs.showMsg('标识符'); &#125;&lt;/script&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;span&gt;测试js使用&lt;/span&gt;&lt;button id='btntest' onclick='showMsgInAndroid()'&gt;调用android方法&lt;/button&gt;&lt;/BODY&gt;&lt;/HTML&gt; 二：JAVA调用JS1.JAVA 代码1mWebView.loadUrl(\"javascript:funFromjs('\"+imageUrl+\"')\") 2.JS代码123function funFromjs(str)&#123; alert(str); &#125; Demo下载：https://github.com/hui46226021/JSAndroidCallCamera.git","categories":[{"name":"Android","slug":"Android","permalink":"https://3431339973.github.io/categories/Android/"}],"tags":[{"name":"移动开发","slug":"移动开发","permalink":"https://3431339973.github.io/tags/移动开发/"},{"name":"原创","slug":"原创","permalink":"https://3431339973.github.io/tags/原创/"},{"name":"JS JAVA调用","slug":"JS-JAVA调用","permalink":"https://3431339973.github.io/tags/JS-JAVA调用/"}]},{"title":"Linux中vi编辑器的使用详解","slug":"Linux中vi编辑器的使用详解","date":"2015-01-22T14:37:23.000Z","updated":"2017-10-01T12:50:01.531Z","comments":true,"path":"2015/01/22/Linux中vi编辑器的使用详解/","link":"","permalink":"https://3431339973.github.io/2015/01/22/Linux中vi编辑器的使用详解/","excerpt":"摘要:记录","text":"摘要:记录 模式vi编辑器是Linux系统下标准的编辑器.而且不逊色于其他任何最新的编辑器.可是会用的有多少呢.下面介绍一下vi编辑器的简单用法和部分命令.让你在Linux系统中畅行无阻. 基本上vi可以分为三种状态，分别是命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode）. 1) 命令行模式command mode） 控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode。 2) 插入模式（Insert mode） 只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。 3) 底行模式（last line mode） 将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。 不过一般我们在使用时把vi简化成两个模式，就是将底行模式（last line mode）也算入命令行模式command mode）。 工具/原料 Linux 方法/步骤 1首先进入Linux的命令行界面.在目录下创建一个用于测试的文本文件(touch filename).我这里就新建了一个test12文本文件.当然这个名字是可以随便取得. 2用”vi test12”命令进入vi命令行模式(vi filename). 如果要想编辑文本文件.必须要转换到插入模式下,也就是按一下键盘上的”i”就可以了.这样你就可以编辑文本,删除文本中的内容.按键盘上的上下左右键.来回移动了.就跟你在windows 系统中编辑文本一样. 3输入你要输入的内容.如果你想退出文本编辑模式.并且保存刚刚编辑的文本.首先点击一下键盘上的”ESC”,然后输入”:wq!”这样就将文本保存了.然后推出了vi编辑器.如果不想保存就按一下键盘上的”ESC”,输入”:q!”.如果你不确定是否成功.可以通过”cat filename” 命令来查看. 4光标的移动除了键盘上的上下左右键.也可以是小写模式下,按键盘上的”h,j,k,l”,“ctrl+b”:屏幕往后移动一页“ctrl+f”:屏幕往前移动一页“ctrl+u”:屏幕往后移动半页“ctrl+d”:屏幕往前移动半页输入任何一个整数,然后输入”shift+G” 就可以到这一页的开头了.按键盘上的大写”G”移动到文章的最后.按”$”符号将光标移动到行尾“^”将光标移到行头“w”:将光标移到下一行头“b”:跟”w”相反.移到上一行行头“e”:将光标移到下一行尾.如果想让文本显示行号.就在命令行 模式下,在文本最后输入”:set nu”命令.就可以了 5复制 「yw」：将光标所在之处到字尾的字符复制到缓冲区中。 「yy」：复制光标所在行到缓冲区。 「#yy」：例如，「6yy」表示拷贝从光标所在的该行”往下数”6行文字。 「p」：将缓冲区内的字符贴到光标所在位置。注意：所有与”y”有关的复制命令都必须与”p”配合才能完成复制与粘贴功能。 6查找用”/“加上要查找的内容.例如”/hello”或者是”?hello”也是可以的.7替换 「r」：替换光标所在处的字符。 ,按一下”r”然后输入要即可. 「R」：替换光标所到之处的字符，直到按下「ESC」键为止。 8恢复上一次操作 「u」：如果您误执行一个命令，可以马上按下「u」，回到上一个操作。按多次”u”可以执行多次恢复.就相当于”CTRL +Z”的操作.","categories":[{"name":"Linux","slug":"Linux","permalink":"https://3431339973.github.io/categories/Linux/"}],"tags":[{"name":"原创","slug":"原创","permalink":"https://3431339973.github.io/tags/原创/"},{"name":"vi","slug":"vi","permalink":"https://3431339973.github.io/tags/vi/"},{"name":"Linux","slug":"Linux","permalink":"https://3431339973.github.io/tags/Linux/"}]},{"title":"java动态代理","slug":"Proxy","date":"2015-01-21T09:35:17.000Z","updated":"2017-10-25T04:42:43.601Z","comments":true,"path":"2015/01/21/Proxy/","link":"","permalink":"https://3431339973.github.io/2015/01/21/Proxy/","excerpt":"摘要:在学习Spring的时候，我们知道Spring主要有两大思想，一个是IoC，另一个就是AOP，对于IoC，依赖注入就不用多说了，而对于Spring的核心AOP来说，我们不但要知道怎么通过AOP来满足的我们的功能，我们更需要学习的是其底层是怎么样的一个原理，而AOP的原理就是java的动态代理机制。","text":"摘要:在学习Spring的时候，我们知道Spring主要有两大思想，一个是IoC，另一个就是AOP，对于IoC，依赖注入就不用多说了，而对于Spring的核心AOP来说，我们不但要知道怎么通过AOP来满足的我们的功能，我们更需要学习的是其底层是怎么样的一个原理，而AOP的原理就是java的动态代理机制。 在java的动态代理机制中，有两个重要的类或接口，一个是 InvocationHandler(Interface)、另一个则是 Proxy(Class)，这一个类和接口是实现我们动态代理所必须用到的。首先我们先来看看java的API帮助文档是怎么样对这两个类进行描述的： InvocationHandler: InvocationHandler is the interface implemented by the invocation handler of a proxy instance. Each proxy instance has an associated invocation handler. When a method is invoked on a proxy instance, the method invocation is encoded and dispatched to the invoke method of its invocation handler.每一个动态代理类都必须要实现InvocationHandler这个接口，并且每个代理类的实例都关联到了一个handler，当我们通过代理对象调用一个方法的时候，这个方法的调用就会被转发为由InvocationHandler这个接口的 invoke 方法来进行调用。我们来看看InvocationHandler这个接口的唯一一个方法 invoke 方法：1Object invoke(Object proxy, Method method, Object[] args) throws Throwable 我们看到这个方法一共接受三个参数，那么这三个参数分别代表什么呢？1Object invoke(Object proxy, Method method, Object[] args) throws Throwable proxy: 指代我们所代理的那个真实对象 method: 指代的是我们所要调用真实对象的某个方法的Method对象 args: 指代的是调用真实对象某个方法时接受的参数如果不是很明白，等下通过一个实例会对这几个参数进行更深的讲解。 接下来我们来看看Proxy这个类： Proxy provides static methods for creating dynamic proxy classes and instances, and it is also the superclass of all dynamic proxy classes created by those methods.Proxy这个类的作用就是用来动态创建一个代理对象的类，它提供了许多的方法，但是我们用的最多的就是 newProxyInstance 这个方法：1public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException Returns an instance of a proxy class for the specified interfaces that dispatches method invocations to the specified invocation handler.这个方法的作用就是得到一个动态的代理对象，其接收三个参数，我们来看看这三个参数所代表的含义： 1public static Object newProxyInstance(ClassLoader loader, Class&lt;?&gt;[] interfaces, InvocationHandler h) throws IllegalArgumentException loader: 一个ClassLoader对象，定义了由哪个ClassLoader对象来对生成的代理对象进行加载 interfaces: 一个Interface对象的数组，表示的是我将要给我需要代理的对象提供一组什么接口，如果我提供了一组接口给它，那么这个代理对象就宣称实现了该接口(多态)，这样我就能调用这组接口中的方法了 h: 一个InvocationHandler对象，表示的是当我这个动态代理对象在调用方法的时候，会关联到哪一个InvocationHandler对象上 好了，在介绍完这两个接口(类)以后，我们来通过一个实例来看看我们的动态代理模式是什么样的： 首先我们定义了一个Subject类型的接口，为其声明了两个方法：123456public interface Subject&#123; public void rent(); public void hello(String str);&#125; 接着，定义了一个类来实现这个接口，这个类就是我们的真实对象，RealSubject类： 1234567891011121314public class RealSubject implements Subject&#123; @Override public void rent() &#123; System.out.println(\"I want to rent my house\"); &#125; @Override public void hello(String str) &#123; System.out.println(\"hello: \" + str); &#125;&#125; 下一步，我们就要定义一个动态代理类了，前面说个，每一个动态代理类都必须要实现 InvocationHandler 这个接口，因此我们这个动态代理类也不例外： 123456789101112131415161718192021222324252627282930public class DynamicProxy implements InvocationHandler&#123; // 这个就是我们要代理的真实对象 private Object subject; // 构造方法，给我们要代理的真实对象赋初值 public DynamicProxy(Object subject) &#123; this.subject = subject; &#125; @Override public Object invoke(Object object, Method method, Object[] args) throws Throwable &#123; // 在代理真实对象前我们可以添加一些自己的操作 System.out.println(\"before rent house\"); System.out.println(\"Method:\" + method); // 当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用 method.invoke(subject, args); // 在代理真实对象后我们也可以添加一些自己的操作 System.out.println(\"after rent house\"); return null; &#125;&#125; 最后，来看看我们的Client类： 123456789101112131415161718192021222324public class Client&#123; public static void main(String[] args) &#123; // 我们要代理的真实对象 Subject realSubject = new RealSubject(); // 我们要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法的 InvocationHandler handler = new DynamicProxy(realSubject); /* * 通过Proxy的newProxyInstance方法来创建我们的代理对象，我们来看看其三个参数 * 第一个参数 handler.getClass().getClassLoader() ，我们这里使用handler这个类的ClassLoader对象来加载我们的代理对象 * 第二个参数realSubject.getClass().getInterfaces()，我们这里为代理对象提供的接口是真实对象所实行的接口，表示我要代理的是该真实对象，这样我就能调用这组接口中的方法了 * 第三个参数handler， 我们这里将这个代理对象关联到了上方的 InvocationHandler 这个对象上 */ Subject subject = (Subject)Proxy.newProxyInstance(handler.getClass().getClassLoader(), realSubject .getClass().getInterfaces(), handler); System.out.println(subject.getClass().getName()); subject.rent(); subject.hello(\"world\"); &#125;&#125; 我们先来看看控制台的输出： 1234567891011$Proxy0before rent houseMethod:public abstract void com.xiaoluo.dynamicproxy.Subject.rent()I want to rent my houseafter rent housebefore rent houseMethod:public abstract void com.xiaoluo.dynamicproxy.Subject.hello(java.lang.String)hello: worldafter rent house 我们首先来看看 $Proxy0 这东西，我们看到，这个东西是由 System.out.println(subject.getClass().getName()); 这条语句打印出来的，那么为什么我们返回的这个代理对象的类名是这样的呢？12Subject subject = (Subject)Proxy.newProxyInstance(handler.getClass().getClassLoader(), realSubject .getClass().getInterfaces(), handler); 可能我以为返回的这个代理对象会是Subject类型的对象，或者是InvocationHandler的对象，结果却不是，首先我们解释一下为什么我们这里可以将其转化为Subject类型的对象？原因就是在newProxyInstance这个方法的第二个参数上，我们给这个代理对象提供了一组什么接口，那么我这个代理对象就会实现了这组接口，这个时候我们当然可以将这个代理对象强制类型转化为这组接口中的任意一个，因为这里的接口是Subject类型，所以就可以将其转化为Subject类型了。 同时我们一定要记住，通过 Proxy.newProxyInstance 创建的代理对象是在jvm运行时动态生成的一个对象，它并不是我们的InvocationHandler类型，也不是我们定义的那组接口的类型，而是在运行是动态生成的一个对象，并且命名方式都是这样的形式，以$开头，proxy为中，最后一个数字表示对象的标号。 接着我们来看看这两句12subject.rent();subject.hello(\"world\"); 这里是通过代理对象来调用实现的那种接口中的方法，这个时候程序就会跳转到由这个代理对象关联到的 handler 中的invoke方法去执行，而我们的这个 handler 对象又接受了一个 RealSubject类型的参数，表示我要代理的就是这个真实对象，所以此时就会调用 handler 中的invoke方法去执行： 12345678910111213141516public Object invoke(Object object, Method method, Object[] args) throws Throwable &#123; // 在代理真实对象前我们可以添加一些自己的操作 System.out.println(\"before rent house\"); System.out.println(\"Method:\" + method); // 当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用 method.invoke(subject, args); // 在代理真实对象后我们也可以添加一些自己的操作 System.out.println(\"after rent house\"); return null; &#125; 我们看到，在真正通过代理对象来调用真实对象的方法的时候，我们可以在该方法前后添加自己的一些操作，同时我们看到我们的这个 method 对象是这样的：123public abstract void com.xiaoluo.dynamicproxy.Subject.rent()public abstract void com.xiaoluo.dynamicproxy.Subject.hello(java.lang.String) 正好就是我们的Subject接口中的两个方法，这也就证明了当我通过代理对象来调用方法的时候，起实际就是委托由其关联到的 handler 对象的invoke方法中来调用，并不是自己来真实调用，而是通过代理的方式来调用的。 这就是我们的java动态代理机制 来自 http://www.cnblogs.com/xiaoluo501395377/p/3383130.html","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://3431339973.github.io/categories/JAVA/"}],"tags":[{"name":"JAVA","slug":"JAVA","permalink":"https://3431339973.github.io/tags/JAVA/"},{"name":"Proxy","slug":"Proxy","permalink":"https://3431339973.github.io/tags/Proxy/"}]},{"title":"Linux环境配置","slug":"Linux服务器环境配置","date":"2015-01-12T13:35:23.000Z","updated":"2017-10-01T12:50:05.416Z","comments":true,"path":"2015/01/12/Linux服务器环境配置/","link":"","permalink":"https://3431339973.github.io/2015/01/12/Linux服务器环境配置/","excerpt":"摘要:记录","text":"摘要:记录 Linux安装JDK步骤1、先从网上下载jdk(jdk-7u1-linux-i586.rpm)，下载地址:http://www.oracle.com/technetwork/java/javase/downloads/jdk-7u1-download-513651.html下载后放在/home目录中，当然其它地方也行。 2、进入安装目录 #cd /home #cp jdk-7u1-linux-i586.rpm /usr/local #cd /usr/local 给所有用户添加可执行的权限 #rpm -ivh jdk-7u1-linux-i586.rpm 安装过程如图所示： 3、设置环境变量 #vi /etc/profile 打开后，在文档最下方加上以下环境变量配置代码： export JAVA_HOME=/usr/java/javajdk1.7.0_01 export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar export PATH=$JAVA_HOME/bin:$PATH 注意：export PATH=$JAVA_HOME/bin:$PATH，注意将$PATH放到最后。以免造成新旧版本问题。 编辑profile文档立即生效 source /etc/profile 4、检查JDK是否安装成功。 #java -version 如果看到JVM版本及相关信息，即安装成功！ Linux下Tomcat的安装配置下载安装tomcat http://tomcat.apache.org/ [root@master ~]# unzip apache-tomcat-6.0.30.zip [root@master ~]# mv apache-tomcat-6.0.30/ /usr/local/ [root@master ~]cd /usr/local/ [root@master local]# ln -s /usr/local/apache-tomcat-6.0.30/ /usr/local/tomcat [root@master local]# cd tomcat/bin/ [root@master bin]#ls [root@master bin]#vim catalina.sh 添加以下内容： CATALINA_HOME=/usr/local/apache-tomcat-6.0.30/ [root@master local]#chmod +x *.sh 三．启动tomcat服务器 [root@master tomcat]# /usr/local/tomcat /bin/catalina.sh start 安装及启动nginx输入yum install nginx命令进行nginx的安装，当需要确认时输入”y“确认。 输入service nginx start启动nginx服务。 输入wget http://127.0.0.1测试nginx服务。 使用命令nginx -t查找nginx配置文件，并使用vi命令修改该配置文件：","categories":[{"name":"Linux","slug":"Linux","permalink":"https://3431339973.github.io/categories/Linux/"}],"tags":[{"name":"原创","slug":"原创","permalink":"https://3431339973.github.io/tags/原创/"},{"name":"Linux","slug":"Linux","permalink":"https://3431339973.github.io/tags/Linux/"},{"name":"nginx","slug":"nginx","permalink":"https://3431339973.github.io/tags/nginx/"}]},{"title":"JAVA 多线程","slug":"JAVA多线程深度解析","date":"2015-01-12T10:37:23.000Z","updated":"2017-10-01T12:49:30.761Z","comments":true,"path":"2015/01/12/JAVA多线程深度解析/","link":"","permalink":"https://3431339973.github.io/2015/01/12/JAVA多线程深度解析/","excerpt":"摘要:之前学习过一下JAVA的多线程知识 当时也没有 做记录 等再次用到的时候 发现已经忘干净了 所以这次记录下来 可能不是很详细 以后看不到 就单个点 继续百度学习","text":"摘要:之前学习过一下JAVA的多线程知识 当时也没有 做记录 等再次用到的时候 发现已经忘干净了 所以这次记录下来 可能不是很详细 以后看不到 就单个点 继续百度学习 后台线程所谓的后台线程，是指在程序运行的时候在后台提供一种通用服务的线程，并且这种线程并不属于程序中不可或缺的部分。因此当所有的非后台线程结束时，程序也就终止了，同时会杀死所有后台线程。反过来说，只要有任何非后台线程(用户线程)还在运行，程序就不会终止。后台线程在不执行finally子句的情况下就会终止其run方法。后台线程创建的子线程也是后台线程 main 是非后台线程 setDaemon(true); 必须在线程start(); 方法前执行 isDaemon() 来判断一个线程是否是守护线程 在Daemon线程中产生的新线程也是Daemon的 带返回值的线程 Callable Future f1 = pool.submit(); call()方法 线程阻塞到 所有线程都 返回结果 线程本地缓存 ThreadLocalThreadLocal.set() 到线程中的对象是该线程自己使用的对象，其他线程是不需要访问的，也访问不到的 实际是放到当前线程的ThreadLocalMap这个map中 线程安全1.即有synchronized关键字修饰的方法。由于java的每个对象都有一个内置锁，当用此关键字修饰方法时， 内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。 代码如：1public synchronized void save()&#123;&#125; 2 即有synchronized关键字修饰的语句块。被该关键字修饰的语句块会自动被加上内置锁，从而实现同步 代码如： 123 synchronized(object)&#123;&#125; 3.使用特殊域变量(volatile)实现线程同步当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值 volatile保证了 可见性 但不保证原子行 private volatile int account = 100; 4.使用重入锁实现线程同步 ReentrantLock() : 创建一个ReentrantLock实例 lock() : 获得锁 unlock() : 释放锁 5.wait() notify()Obj.wait()，与Obj.notify()必须要与synchronized(Obj)一起使用，也就是wait,与notify是针对已经获取了Obj锁进行操作，从语法角度来说就是Obj.wait(),Obj.notify必须在synchronized(Obj){…}语句块内。从功能上来说wait就是说线程在获取对象锁后，主动释放对象锁，同时本线程休眠。直到有其它线程调用对象的notify()唤醒该线程，才能继续获取对象锁，并继续执行 调用 notify() 方法导致解除阻塞的线程是从因调用该对象的 wait() 方法而阻塞的线程中随机选取的 除了 notify()，还有一个方法 notifyAll() 也可起到类似作用，唯一的区别在于，调用 notifyAll() 方法将把因调用该对象的 wait() 方法而阻塞的所有线程一次性全部解除阻塞。 和 suspend() 和 resume()功能类似 不过后者不会释放锁 注 ：Lock有比synchronized更精确的线程语义和更好的性能。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放 CountDownLatchCountDownLatch是减计数方式，计数==0时释放所有等待的线程；CyclicBarrier是加计数方式，计数达到构造方法中参数指定的值时释放所有等待的线程。CountDownLatch当计数到0时，计数无法被重置；CyclicBarrier计数达到指定值时，计数置为0重新开始。CountDownLatch每次调用countDown()方法计数减一，调用await()方法只进行阻塞，对计数没任何影响；CyclicBarrier只有一个await()方法，调用await()方法计数加1，若加1后的值不等于构造方法的值，则线程阻塞 线程池1.减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。2.可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。Java里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是ExecutorService。 Executors 静态方法 newSingleThreadExecutor 创建一个单线程的线程池 newFixedThreadPool 创建固定大小的线程池 newCachedThreadPool 创建一个可缓存的线程池 newScheduledThreadPool 创建一个大小无限的线程池 ThreadPoolExecutor的完整构造方法的签名是：ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) corePoolSize：核心池的大小 maximumPoolSize：线程池最大线程数 keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止 unit：参数keepAliveTime的时间单位 workQueue：一个阻塞队列 threadFactory：线程工厂，主要用来创建线程 handler：表示当拒绝处理任务时的策略，有以下四种取值 常用方法 execute() submit() shutdown() shutdownNow() 线程异常捕获：线程代码不能抛出任何checked异常。所有的线程中的checked异常都只能被线程本身消化掉当 线程代码抛出运行级别异常之后，线程会中断。 在thread.start()之前 设置 异常回调12345678910111213thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() &#123; @Override public void uncaughtException(Thread t, Throwable e) &#123; System.out.println(\"线程\"+t.getName()+\"--异常信息\"); e.printStackTrace(); &#125; &#125;) 线程池捕获异常而在线程池中却比较特殊。默认情况下，线程池 java.util.concurrent.ThreadPoolExecutor 会Catch住所有异常 通过覆盖ThreadPoolExecutor.afterExecute 方法，我们才能捕获到任务的异常1234567protected void afterExecute(Runnable r, Throwable t) &#123; super.afterExecute(r, t); &#125;","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://3431339973.github.io/categories/JAVA/"}],"tags":[{"name":"原创","slug":"原创","permalink":"https://3431339973.github.io/tags/原创/"},{"name":"服务器开发","slug":"服务器开发","permalink":"https://3431339973.github.io/tags/服务器开发/"},{"name":"JAVA 多线程","slug":"JAVA-多线程","permalink":"https://3431339973.github.io/tags/JAVA-多线程/"}]},{"title":"基于注解的mybatis","slug":"MySQL DBA 面试全揭秘","date":"2014-12-17T08:17:33.000Z","updated":"2017-10-01T12:50:19.580Z","comments":true,"path":"2014/12/17/MySQL DBA 面试全揭秘/","link":"","permalink":"https://3431339973.github.io/2014/12/17/MySQL DBA 面试全揭秘/","excerpt":"","text":"原文地址：http://wwww.iteye.com/blog/1235996","categories":[{"name":"DB","slug":"DB","permalink":"https://3431339973.github.io/categories/DB/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://3431339973.github.io/tags/数据库/"},{"name":"注解","slug":"注解","permalink":"https://3431339973.github.io/tags/注解/"}]},{"title":"基于Redis的Session共享示例","slug":"基于Redis的Session共享示例","date":"2014-12-17T08:17:33.000Z","updated":"2017-10-01T12:46:50.259Z","comments":true,"path":"2014/12/17/基于Redis的Session共享示例/","link":"","permalink":"https://3431339973.github.io/2014/12/17/基于Redis的Session共享示例/","excerpt":"摘要: 在单机情况下，Session可由部署在服务器上的Web容器来管理 (如Tomcat、JBoss)。 在负载均衡的集群环境下，负载均衡可能将请求分发到不同的服务器上去，在这种情况，需要将有状态的session统一管理起来","text":"摘要: 在单机情况下，Session可由部署在服务器上的Web容器来管理 (如Tomcat、JBoss)。 在负载均衡的集群环境下，负载均衡可能将请求分发到不同的服务器上去，在这种情况，需要将有状态的session统一管理起来https://my.oschina.net/wangmengjun/blog/810179#0-tsina-1-15650-397232819ff9a47a7b7e80a40613cfe1","categories":[{"name":"DB","slug":"DB","permalink":"https://3431339973.github.io/categories/DB/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://3431339973.github.io/tags/Redis/"},{"name":"session共享","slug":"session共享","permalink":"https://3431339973.github.io/tags/session共享/"},{"name":"分布式","slug":"分布式","permalink":"https://3431339973.github.io/tags/分布式/"}]},{"title":"基于注解的mybatis","slug":"基于注解的mybatis","date":"2014-12-17T08:17:33.000Z","updated":"2017-10-01T12:46:37.668Z","comments":true,"path":"2014/12/17/基于注解的mybatis/","link":"","permalink":"https://3431339973.github.io/2014/12/17/基于注解的mybatis/","excerpt":"","text":"原文地址：http://wwww.iteye.com/blog/1235996","categories":[{"name":"DB","slug":"DB","permalink":"https://3431339973.github.io/categories/DB/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://3431339973.github.io/tags/数据库/"},{"name":"注解","slug":"注解","permalink":"https://3431339973.github.io/tags/注解/"}]},{"title":"Java程序打包成jar包/","slug":"20141205","date":"2014-12-05T05:47:23.000Z","updated":"2017-03-19T05:05:27.920Z","comments":true,"path":"2014/12/05/20141205/","link":"","permalink":"https://3431339973.github.io/2014/12/05/20141205/","excerpt":"","text":"方法一：通过jar命令jar命令的用法：下面是jar命令的帮助说明： 用法：jar {ctxui}[vfm0Me] [jar-file] [manifest-file] [entry-point] [-C dir] files … 选项包括： -c 创建新的归档文件 -t 列出归档目录 -x 解压缩已归档的指定（或所有）文件 -u 更新现有的归档文件 -v 在标准输出中生成详细输出 -f 指定归档文件名 -m 包含指定清单文件中的清单信息 -e 为捆绑到可执行 jar 文件的独立应用程序 指定应用程序入口点 -0 仅存储；不使用任何 ZIP 压缩 -M 不创建条目的清单文件 -i 为指定的 jar 文件生成索引信息 -C 更改为指定的目录并包含其中的文件如果有任何目录文件，则对其进行递归处理。清单文件名、归档文件名和入口点名的指定顺序与 “m”、”f” 和 “e” 标志的指定顺序相同。 示例 1：将两个类文件归档到一个名为 classes.jar 的归档文件中： jar cvf classes.jar Foo.class Bar.class示例 2：使用现有的清单文件 “mymanifest” 并 将 foo/ 目录中的所有文件归档到 “classes.jar” 中： jar cvfm classes.jar mymanifest -C foo/ . 下文假设编译后的class文件在bin目录下 一、打包成一般的jar包输入如下命令即可： Cmd代码 复制代码 收藏代码jar cvf counter.jar -C bin .其中，“-C bin”实际上是告诉jar命令先cd到bin目录下，再在此目录执行没有参数“-C bin”的命令，等价于： Cmd代码 复制代码 收藏代码cd binjar cvf counter.jar . // “.”代表当前路径 二、打包成可运行的jar包要打包成可运行的jar包，有两种方法，一是手动创建MANIFEST.MF文件，并在其中指定主类;二是使用jar的-e参数指定可运行jar包的入口点（即main类的完全名称）. 以Java源代码行数统计程序的打包为例，演示如何打包: 手动创建MANIFEST.MF文件： 1）首先编辑MANIFEST.MF文件，内容如下： Mf代码 收藏代码 复制代码Manifest-Version: 1.0Created-By: rsljdktClass-Path: .Main-Class: Main 说明： 第一行指定清单的版本，若无，则JDK默认生成：Manifest-Version: 1.0 第二行指明创建的作者，若无，则JDK默认生成Created-By: 1.6.0_22(Sun Microsystems Inc.) 第三行指定主类所在类路径， 第四行指明程序运行的主类 2）使用jar命令进行打包： Cmd代码 复制代码 收藏代码jar cvfm counter.jar MANIFEST.MF -C bin . 说明： 参数f：指定打包后的包名。 参数m：指定自定义的MANIFEST.MF清单文件，否则，JDK会自动生成不包含Main-Class的默认清单。 参数c：指定是创建新的归档文件。 参数v：在标准输出中生成详细输出，该选项是可选的。 使用-e参数指定入口点： 执行如下命令即可： Cmd代码 复制代码 收藏代码jar cvfe counter.jar Main -C bin . 原文地址：http://blog.sina.com.cn/s/blog_93d133c601013hdm.html","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://3431339973.github.io/categories/JAVA/"}],"tags":[{"name":"转载","slug":"转载","permalink":"https://3431339973.github.io/tags/转载/"},{"name":"Jar包","slug":"Jar包","permalink":"https://3431339973.github.io/tags/Jar包/"}]},{"title":"spring security的原理及教程","slug":"spring security的原理及教程","date":"2014-11-17T08:17:33.000Z","updated":"2017-10-01T12:50:47.697Z","comments":true,"path":"2014/11/17/spring security的原理及教程/","link":"","permalink":"https://3431339973.github.io/2014/11/17/spring security的原理及教程/","excerpt":"","text":"原文地址：http://www.2cto.com/kf/201408/329607.html#0-tsina-1-20953-397232819ff9a47a7b7e80a40613cfe1","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://3431339973.github.io/categories/JAVA/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://3431339973.github.io/tags/spring/"},{"name":"权限","slug":"权限","permalink":"https://3431339973.github.io/tags/权限/"},{"name":"后端开发","slug":"后端开发","permalink":"https://3431339973.github.io/tags/后端开发/"}]},{"title":"JAVA Web缓存","slug":"JAVA Web缓存","date":"2014-11-12T10:37:23.000Z","updated":"2017-10-01T12:49:37.693Z","comments":true,"path":"2014/11/12/JAVA Web缓存/","link":"","permalink":"https://3431339973.github.io/2014/11/12/JAVA Web缓存/","excerpt":"摘要:去年整理过关于JAVA web的一些缓冲知识 今天无疑见翻出这篇笔记 怕以后弄丢了 就在这里记录下吧","text":"摘要:去年整理过关于JAVA web的一些缓冲知识 今天无疑见翻出这篇笔记 怕以后弄丢了 就在这里记录下吧 JAVA缓存最简单一种实现创建一个静态的map ConcurrentHashMap 线程安全 本地文件缓存Ehcache 缓存jar包ehcache-core-2.5.2.jar slf4j-api-1.6.1.jar slf4j-jdk14-1.6.1.jar 配置 ehcache.xml可配置多个cache通过 Cache sample = cacheManager.getCache(“name”);获取缓存对象 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"../bin/ehcache.xsd\"&gt; &lt;!-- name：Cache的唯一标识 maxElementsInMemory：内存中最大缓存对象数 maxElementsOnDisk：磁盘中最大缓存对象数，若是0表示无穷大 eternal：Element是否永久有效，一但设置了，timeout将不起作用 overflowToDisk：配置此属性，当内存中Element数量达到maxElementsInMemory时，Ehcache将会Element写到磁盘中 timeToIdleSeconds：设置Element在失效前的允许闲置时间。仅当element不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大 11. timeToLiveSeconds：设置Element在失效前允许存活时间。最大时间介于创建时间和失效时间之间。仅当element不是永久有效时使用，默认是0.，也就是element存活时间无穷大 diskPersistent ： 是否持久化磁盘缓存。当这个属性的值为true时，系统在初始化的时候会在磁盘中查找文件名为cache名称，后缀名为index的的文件 diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒 diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区 memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用） --&gt; &lt;defaultCache overflowToDisk=\"true\" eternal=\"false\"/&gt; &lt;diskStore path=\"D:/cache\" /&gt; &lt;!-- &lt;cache name=\"zzugxy\" overflowToDisk=\"true\" eternal=\"false\" timeToIdleSeconds=\"300\" timeToLiveSeconds=\"600\" maxElementsInMemory=\"1000\" &gt; maxElementsOnDisk=\"10\" diskPersistent=\"true\" diskExpiryThreadIntervalSeconds=\"300\" diskSpoolBufferSizeMB=\"100\" memoryStoreEvictionPolicy=\"LRU\" /&gt; --&gt; &lt;/ehcache&gt; JAVA 代码 1.获取CacheManager 对象 不传参数表示默认路径 可以传入文件路径和网络地址 2.CacheManager cacheManager = CacheManager.create(); 获取ehcache.xml 文件里配置好的 cache Cache sample = cacheManager.getCache(“SimplePageCachingFilter”); 3.创建 缓存元素 key 和 val 字面意思 Element element = new Element(“key”, “val”); 4.sample.put(element); 将缓存对象 加入缓存 通过key获取cache中的 缓存元素 Element result = sample.get(“key”); 注意添加到cache中对象要序列化 实现Serializable接口 通过 次元素 可获取 val等 属性的值 删除缓存 sample.remove(“key”); sample.removeAll(); 获取所有的缓存对象 for (Object key : cache.getKeys()) { System.out.println(key); } 得到缓存中的对象数 cache.getSize(); 得到缓存对象占用内存的大小 cache.getMemoryStoreSize(); 得到缓存读取的命中次数 cache.getStatistics().getCacheHits(); 得到缓存读取的错失次数 cache.getStatistics().getCacheMisses(); 写入磁盘 cache.flush(); 要想把cache真正持久化到磁盘，写程序时必须注意，在是用net.sf.ehcache.Cache的void put (Element element)方法后要使用void flush()方法 创建个缓存123Ehcache cache = new Cache(\"testCache\", 5000, false, false, 5, 2);sample.add(cache ) Ehcache整合MyBatis导入 mybatis-ehcache-1.0.0.jar 还有其他myBatis相关包1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.qiuqiu.dao.PersonDao\"&gt; &lt;!-- 以下两个&lt;cache&gt;标签二选一,第一个可以输出日志,第二个不输出日志 --&gt; &lt;cache type=\"org.mybatis.caches.ehcache.LoggingEhcache\"/&gt; &lt;!-- &lt;cache type=\"org.mybatis.caches.ehcache.EhcacheCache\"/&gt; --&gt; &lt;select id=\"selectUserById\" parameterType=\"int\" resultType=\"org.qiuqiu.vo.Person\"&gt; select * from person where id=#&#123;id&#125; &lt;/select&gt; &lt;/mapper&gt; 通过注释的方式 整合 1@CacheNamespace(implementation=org.mybatis.caches.ehcache.EhcacheCache.class) EhcacheCache 实现了 mybatis的 Cache接口 默认获取根目录下的ehcache.xml文件 如果 之前在ehcache.xml 没有配置过 相应的cache 这里会根据 id创建一个cache id= Dao的地址 在ehcache.xml配置 cache麻烦的话 可以 自定义类 继承EhcacheCache 重写 获取cache 将@CacheNamespace 注解里面的参数传进去 自定义 cache Ehcache页面缓存jar包 12345&lt;dependency&gt; &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt; &lt;artifactId&gt;ehcache-web&lt;/artifactId&gt; &lt;version&gt;2.0.4&lt;/version&gt;&lt;/dependency&gt; 页面缓存主要用Filter过滤器对请求的url进行过滤，如果该url在缓存中出现。那么页面数据就从缓存对象中获取，并以gzip压缩后返回。其速度是没有压缩缓存时速度的3-5倍，效率相当之高！其中页面缓存的过滤器有CachingFilter，一般要扩展filter或是自定义Filter都继承该CachingFilter 自定义类 继承 SimplePageCachingFilter 重写 doFilter 方法 在里面先判断 是否是要缓存的地址 如果是就调用super.doFilter(request, response, chain); 如果不是就调用chain.doFilter(request, response); SimplePageCachingFilter里面默认获取 名字SimplePageCachingFilter 的 cache配置 重写 getCacheName方法 设置 cache名字 默认 key :1stringBuffer.append(httpRequest.getMethod()).append(httpRequest.getRequestURI()).append(httpRequest.getQueryString()) 可以重写 SimplePageCachingFilter 的 calculateKey() 方法 自己定义key Ehcache Spring 整合123456789101112&lt;bean id=\"defaultCacheManager\" class=\"org.springframework.cache.ehcache.EhCacheManagerFactoryBean\"&gt; &lt;property name=\"configLocation\" value=\"classpath:ehcache.xml\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"cacheManager\" class=\"org.springframework.cache.ehcache.EhCacheCacheManager\"&gt; &lt;property name=\"cacheManager\"&gt; &lt;ref local=\"defaultCacheManager\"/&gt; &lt;/property&gt; &lt;/bean&gt; &lt;cache:annotation-driven cache-manager=\"cacheManager\"/&gt; 在类或方法上@Cacheable @Cacheable(value=”cache”) 这个注释的意思是，当调用这个方法的时候，会从一个名叫 cache的缓存中查询，如果没有，则执行实际的方法（即查询数据库），并将执行的结果存入缓存中，否则返回缓存中的对象。 同时 还有@CacheEvict @CachePut 等注解 详解http://wenku.baidu.com/link?url=g5ptu1e1vHrJ2FePys7a9ILMhoI_JkX4-3vX9Ir3VfSiTGuE6eOqEx-DuWGMZBWoIa9zKQ9RmM4eiJw86Q_uXx7U1Ux75X2odvUGxqL8JaW 远程缓存Memcachedjava memcached clientjar包 commons-pool-1.5.6.jar java_memcached-release_2.6.6.jar slf4j-api-1.6.1.jar slf4j-simple-1.6.1.jar 主要是两个类 SockIOPool 和 MemCachedClient SockIOPool 这个类用来创建管理客户端和服务器通讯连接池 MemCachedClient 缓存的管理 set方法 gei 方法 等 memcached 缓存对象 需要 实现序列化 set方法 gei 方法 等 注：设置有效时间为5秒是 new Date(5000) 不是 new Date(System.currentTimeMillis()+5000) 神逻辑 更多API http://wenku.baidu.com/link?url=vxMR6BGKj7_8RHMN9H_trAV4p4NVPfVjxSl08uQcL8eooRTk7g1PQVmiqcKP4MQPr5Hm3NsIlEHqdFcPFroddtzHaOliasg5I2MYGjz0XiC java memcached client 整合spring1234567891011121314151617181920212223242526272829303132&lt;bean id=\"sockIOPool\" class=\"com.danga.MemCached.SockIOPool\" factory-method=\"getInstance\" init-method=\"initialize\" destroy-method=\"shutDown\"&gt; &lt;constructor-arg&gt; &lt;value&gt;neeaMemcachedPool&lt;/value&gt; &lt;/constructor-arg&gt; &lt;property name=\"servers\"&gt; &lt;list&gt; &lt;value&gt;127.1.0.1:11211&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"initConn\"&gt; &lt;value&gt;10&lt;/value&gt; &lt;/property&gt; &lt;property name=\"maxConn\"&gt; &lt;value&gt;250&lt;/value&gt; &lt;/property&gt; &lt;property name=\"maintSleep\"&gt; &lt;value&gt;30&lt;/value&gt; &lt;/property&gt; &lt;property name=\"nagle\"&gt; &lt;value&gt;false&lt;/value&gt; &lt;/property&gt; &lt;property name=\"socketTO\"&gt; &lt;value&gt;3000&lt;/value&gt; &lt;/property&gt;&lt;/bean&gt; &lt;bean id=\"memcachedClient\" class=\"com.danga.MemCached.MemCachedClient\"&gt; &lt;constructor-arg&gt; &lt;value&gt;neeaMemcachedPool&lt;/value&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; 参考 Ehcache 整合 Spring org.springframework.cache.ehcache.EhCacheCacheManager 重org.springframework.cache.Cache和 org.springframework.cache.support.AbstractCacheManager 1234567&lt;bean id=\"cacheManager\" class=\"com.dingxin.kunyu.cache.MemcachedCacheManager\"&gt; &lt;property name=\"memcachedClient\"&gt; &lt;ref bean=\"memcachedClient\"/&gt; &lt;/property&gt;&lt;/bean&gt;&lt;cache:annotation-driven cache-manager=\"cacheManager\"/&gt;mybatis和memcached的整合 mybatis和memcached的整合JAR 包12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt; &lt;artifactId&gt;mybatis-memcached&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/dependency&gt; 1&lt;mapper namespace=\"org.acme.FooMapper\"&gt; &lt;cache type=\"org.mybatis.caches.memcached.MemcachedCache\" /&gt; 打印日志1&lt;cache type=\"org.mybatis.caches.memcached.LoggingMemcachedCache\" /&gt; ...&lt;/mapper&gt; memcache的配置是根据classpath下的 /memcached.properties 配置的，如果没有使用默 还可以实现 mybatis的 Cache接口 进行整合 使用Simple-Spring-Memcached注解做缓存操作 针对xmemcached 客户端 1234567891011&lt;dependency&gt; &lt;groupId&gt;com.google.code.simple-spring-memcached&lt;/groupId&gt; &lt;artifactId&gt;xmemcached-provider&lt;/artifactId&gt; &lt;version&gt;3.6.0&lt;/version&gt;&lt;/dependency&gt; &lt;!--spymemcached客户端 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.google.code.simple-spring-memcached&lt;/groupId&gt; &lt;artifactId&gt;spymemcached-provider&lt;/artifactId&gt; &lt;version&gt;3.6.0&lt;/version&gt;&lt;/dependency&gt; Spring 配置 12&lt;import resource=\"simplesm-context.xml\" /&gt;&lt;aop:aspectj-autoproxy /&gt; http://https://code.google.com/p/simple-spring-memcached/wiki/Getting_Started#@CacheKeyMethod 这里面有针对不同客户端的spring配置 simplesm-context.xml 在simple-spring-memcached-3.4.0.jar 包里 在方法上 使用 @ReadThroughSingleCache 两个参数 namespace key前缀 expiration到期时间 在参数上@ParameterValueKeyProvider 生成key 多个参数时候 需要指定 order 值 注 参数不能带空格 或者空的 会报错 @InvalidateSingleCache 作用：失效Cache中的数据 @UpdateSingleCache 作用：更新Cache中的数据 等等 @CacheKeyMethod 标记做为参数 的对象方法上 调用该方法生产key 不包含此注解则调用 toString方法 xmemcached 客户端 Jar 包 12345&lt;dependency&gt; &lt;groupId&gt;com.googlecode.xmemcached&lt;/groupId&gt; &lt;artifactId&gt;xmemcached&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt;&lt;/dependency&gt; 1234567891011121314151617181920212223242526MemcachedClientBuilder builder = new XMemcachedClientBuilder( AddrUtil.getAddresses(\"127.1.0.1:11211\"), new int[] &#123; 1, 1, 1, 1 &#125; //设置连接池大小，即客户端个数 builder.setConnectionPoolSize(50); //宕机报警 builder.setFailureMode(true); //使用二进制文件 builder.setCommandFactory(new BinaryCommandFactory()); MemcachedClient memcachedClient = null; try &#123; memcachedClient = builder.build(); try &#123; memcachedClient.set(\"zlex\", 36000, \"set/get\"); memcachedClient.get(\"zlex\",); &#125; catch (TimeoutException e) &#123; e.printStackTrace(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (MemcachedException e) &#123; e.printStackTrace(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace();&#125; API http://www.tuicool.com/articles/qMnQVfe Redis1&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt; Jedis客户端连接池配置 12345678//连接池配置 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(10); config.setMaxIdle(50);//设置最大空闲数 config.setBlockWhenExhausted(false); config.setMaxWaitMillis(timeout);//设置超时时间 config.setMinEvictableIdleTimeMillis(30000); 更多参数 详解 http://shift-alt-ctrl.iteye.com/blog/1885910 1234567891011121314151617181920//获得连接池JedisPool pool == new JedisPool(config, host, port, timeout)//jedisPool对象 可以通过spring 进行封装//获得JedisJedis client = jedisPool.getResource(); try&#123; client.set(\"k1\", \"v1\"); client.expire(\"k1\", time) //设置有效时间 client.get(\"k1\"); //获取值 client.del(\"k1\"); //删除值 &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; jedisPool.returnResource(client); //必须 释放对象池 &#125; 更多API http://tool.oschina.net/uploads/apidocs/ Redis的key和value都支持二进制安全的字符串 保存对象 需要 序列化对象 序列化工具 123456789101112131415161718192021222324252627282930public class SerializeUtil &#123; public static byte[] serialize(Object object) &#123; ObjectOutputStream oos = null; ByteArrayOutputStream baos = null; try &#123; //序列化 baos = new ByteArrayOutputStream(); oos = new ObjectOutputStream(baos); oos.writeObject(object); byte[] bytes = baos.toByteArray(); return bytes; &#125; catch (Exception e) &#123; &#125; return null; &#125; public static Object unserialize(byte[] bytes) &#123; ByteArrayInputStream bais = null; try &#123; //反序列化 bais = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bais); return ois.readObject(); &#125; catch (Exception e) &#123; &#125; return null; &#125;&#125; Spring Data Redis在Jedis的基础上，提供了对Redis访问的进一步封装。使用SDR，不在需要手动维护连接的建立、释放，对对象序列化提供了默认实现 SDR依赖的的是Spring的高版本3.x12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt; &lt;version&gt;1.5.2.RELEASE&lt;/version&gt;&lt;/dependency&gt; Spring 配置 123456789101112131415161718&lt;!--定义连接工厂--&gt;&lt;bean id = \"jedisConnectionFactory\" class=\"org.springframework.data.redis.connection.jedis.JedisConnectionFactory\"&gt; &lt;constructor-arg index=\"0\" ref=\"jedisPoolConfig\"/&gt; &lt;property name=\"hostName\" value=\"$&#123;redis.host&#125;\"/&gt; &lt;property name=\"port\" value=\"$&#123;redis.port&#125;\"/&gt; &lt;property name=\"timeout\" value=\"$&#123;redis.timeout&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;redis.password&#125;\"/&gt; &lt;/bean&gt;&lt;!--定义redisTemplate：提供了对Jedis进行的通用API操作。--&gt;&lt;bean id = \"redisTemplate\" class=\"org.springframework.data.redis.core.RedisTemplate\"&gt; &lt;property name=\"connectionFactory\" ref=\"jedisConnectionFactory\"/&gt; &lt;property name=\"keySerializer\"&gt; &lt;bean class=\"org.springframework.data.redis.serializer.StringRedisSerializer\"&gt;&lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; SDR默认采用JDK的序列化机制 使用JdkSerializationRedisSerializer类，进行对象和byte[]之间的相互转换，就像上面的序列化代码 这里是设置 keySerializer 为StringRedisSerializer 所以使用字符串形式的key123redisTemplate.opsForValue().set(key, value);redisTemplate.opsForValue().get(key);redisTemplate.delete(key); 更多apihttp://docs.spring.io/spring-data/redis/docs/1.0.x/api/org/springframework/data/redis/core/RedisTemplate.html Redis 整合 MyBatis自定义类 继承myBatis 的cache接口 http://www.tuicool.com/articles/j2AzA3","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://3431339973.github.io/categories/JAVA/"}],"tags":[{"name":"原创","slug":"原创","permalink":"https://3431339973.github.io/tags/原创/"},{"name":"JAVA Web缓存","slug":"JAVA-Web缓存","permalink":"https://3431339973.github.io/tags/JAVA-Web缓存/"},{"name":"服务器开发","slug":"服务器开发","permalink":"https://3431339973.github.io/tags/服务器开发/"}]},{"title":"安装ubuntu 配置环境","slug":"安装ubuntu 配置环境","date":"2014-10-12T05:21:35.000Z","updated":"2017-10-01T12:46:54.576Z","comments":true,"path":"2014/10/12/安装ubuntu 配置环境/","link":"","permalink":"https://3431339973.github.io/2014/10/12/安装ubuntu 配置环境/","excerpt":"摘要:记录","text":"摘要:记录 1.sudo apt-get update 2.安装chrome 在（百度云） 3.安装 flash sudo apt-get install flashplugin-installer 4.安装sougo输入法 （百度云） 5.安装JDK 官网下载 解压到 /use/lib/jva 目录 名字改为java 6.配置jdk环境变量：gedit /etc/profile #set jdk environmentexport JAVA_HOME=/usr/lib/jvm/jdk1.7.0_21export CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/jre/lib:$CLASSPATHexport PATH=$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATH source /etc/profile查看配置是否成功。 java -version 如果显示仍是openJDK， 配置默认JDK，ubuntu下默认JDK是openJDK。。终端输入sudo update-alternatives –install /usr/lib/java java /usr/lib/jvm/java/bin/java 300sudo update-alternatives –install /usr/lib/javac javac /usr/lib/java/bin/javac 300 sudo update-alternatives –config java会列出jdk版本，其中被“*”标注的为默认JDK。如果要维持当前默认JDK，直接按回车键即可；否则输入相应JDK的编号将其设置为默认版本。 7.安装32位库sudo apt-get install lib32z1 lib32ncurses5 lib32bz2-1.0 lib32stdc++6 8.安装 android studio 中文社区 下载（快他妈安装100遍了）、 9.装QQ ubuntu麒麟官网 下载","categories":[{"name":"Linux","slug":"Linux","permalink":"https://3431339973.github.io/categories/Linux/"}],"tags":[{"name":"原创","slug":"原创","permalink":"https://3431339973.github.io/tags/原创/"},{"name":"操作系统","slug":"操作系统","permalink":"https://3431339973.github.io/tags/操作系统/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://3431339973.github.io/tags/ubuntu/"}]},{"title":"git 常用命令","slug":"git 常用命令","date":"2014-03-18T14:37:23.000Z","updated":"2017-10-03T15:44:08.578Z","comments":true,"path":"2014/03/18/git 常用命令/","link":"","permalink":"https://3431339973.github.io/2014/03/18/git 常用命令/","excerpt":"摘要:记录","text":"摘要:记录 git config –global user.name “Tony” //设置名字 git config –global user.email “tony@gmail.com” //设置邮箱 git init git add AndroidManifest.xml //添加单个文件 git add src //添加文件夹 git add . //添加所有文件 git commit -m “First commit.” //提交 我们在ProviderTest项目的根目录下创建一个名为.gitignore的文件，然后编辑这个文件 排除 git status //查看修改项目 git diff src/com/example/providertest/MainActivity.java //查看修改文件的内容 git checkout src/com/example/providertest/MainActivity.java //撤销修改的文件 在提交之前 git reset HEAD src/com/example/providertest/MainActivity.java //取消添加 git log //查看日志 git log 2e7c0547af28cc1e9f303a4a1126fddbb704281b -1 -p //查看具体内容 git branch –a //查看分支 git branch version1.0 //创建分支 git checkout version1.0 //切换分支 git checkout master git merge version1.0 //合并分支 git branch -D version1.0 //删除分支 git clone https://github.com/exmaple/test.git //远程代码下载到本地 git push origin master //提交到远程仓库 其中origin部分指定的是远程版本库的Git地址，master部分指定的是同步到哪一个分支 git fetch origin master //下载远程代码 执行这个命令后，就会将远程版本库上的代码同步到本地，不过同步下来的代码并不会合并到任何分支上去，而是会存放在到一个origin/master分支上，这时我们可以通过diff命令来查看远程版本库上到底修改了哪些东西： git diff origin/master 之后再调用merge命令将origin/master分支上的修改合并到主分支上即可，如下所示： git merge origin/master git pull origin master //相当于上面两条命令","categories":[{"name":"VSC","slug":"VSC","permalink":"https://3431339973.github.io/categories/VSC/"}],"tags":[{"name":"原创","slug":"原创","permalink":"https://3431339973.github.io/tags/原创/"},{"name":"版本控制","slug":"版本控制","permalink":"https://3431339973.github.io/tags/版本控制/"},{"name":"git命令","slug":"git命令","permalink":"https://3431339973.github.io/tags/git命令/"}]}]}