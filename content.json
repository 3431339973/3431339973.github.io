{"meta":{"title":"独角兽之路","subtitle":"到了汉堡，我们每天必须演足8小时","description":"到了含堡，我们每天必须演足8小时","author":"Harlan Zhush","url":"https://hui46226021.github.io"},"pages":[{"title":"关于我","date":"2017-03-15T14:49:53.000Z","updated":"2017-03-19T08:22:29.962Z","comments":true,"path":"about/index.html","permalink":"https://hui46226021.github.io/about/index.html","excerpt":"","text":""},{"title":"读书","date":"2017-03-15T14:49:53.000Z","updated":"2017-10-01T06:06:32.726Z","comments":true,"path":"book/index.html","permalink":"https://hui46226021.github.io/book/index.html","excerpt":"","text":"作者: [美] Marty Cagan豆瓣评分 8.5 链接我的评价虽然是11年的书，不过放到现在，书里面很多情节依然像是发生在周边，有些事情道理都懂，但执行起来却困难重重，推荐给每位软件行业的人，无论你是程序员还是产品经理，或是项目管理者，粗略看一遍，肯定会带着笔纸回来看第二遍 作者: 【加】马尔科姆•格拉德威尔（Malcolm Gladwell）豆瓣评分 7.6 链接我的评价想引发一个流行，首先要有人推，谁来推？就是书里说的 联系员（社交广的人）内行人（喜欢研究，对别人有一定说服力）还有销售员 ，第二 产品要有粘性，客户使用产品的时候 有附加的感受，这样有会有粘性，第三 要出现在恰当的时机，例如淘宝如果出生在 交通不发达的年代，也只有死路一条 作者: 马尔科姆·格拉德威尔豆瓣评分 8.1 链接我的评价成功并不是某一个人努力的结果，需要正好出生在一个 有机遇的时机，用中国话说就是乱世出英雄（感觉差不多意思），当机遇来的时候 正好已经掌握成熟的技能书上说的10000小时 也不过是个虚数，但你确实要经过刻苦的训练，反复的琢磨，同时你还要有个一个良好的成长环境，树立正确的价值观和与人沟通的技巧，最后在你生活地区 是否有 类似荣誉文化的影响（如东北地区的人脾气比较火爆，很明显做生意的都是南方人） 作者: [美]卡迈恩·加洛豆瓣评分 8.3 链接我的评价好书是好书，我就是个内向的人 每次再公共场合发言都很害怕，看了这本书 发现即使罗永浩这样的人 在演讲的时候 也都不过是 扒书里的套路 ，这给我带来了很大的信心，这本书也应该是我以后每次演讲的 工具书 甚至是练习的模板 作者: [英] 安德鲁·霍奇斯豆瓣评分 7.5 链接我的评价读起来有点费劲，看不大进去,一个同性恋给另一个同性恋写的传记，我要能看进去就坏了 作者: 陈雄华 / 林开雄豆瓣评分 7.7链接我的评价也就入门用吧，想深入 还是读源码收获最大"},{"title":"categories","date":"2017-03-15T14:49:53.000Z","updated":"2017-03-16T15:33:27.797Z","comments":true,"path":"categories/index.html","permalink":"https://hui46226021.github.io/categories/index.html","excerpt":"","text":"comments: false"},{"title":"tags","date":"2015-03-15T14:48:43.000Z","updated":"2017-03-16T15:33:43.405Z","comments":true,"path":"tags/index.html","permalink":"https://hui46226021.github.io/tags/index.html","excerpt":"","text":"comments: false"}],"posts":[{"title":"Android表单映射框架 SHFormLayout 快速生成表单布局","slug":"ShFormLayout","date":"2017-03-17T14:37:23.000Z","updated":"2017-03-18T09:47:10.277Z","comments":true,"path":"2017/03/17/ShFormLayout/","link":"","permalink":"https://hui46226021.github.io/2017/03/17/ShFormLayout/","excerpt":"摘要:由于公司业务 有大量表单页面的需求 故独立封装一套表单映射 布局框架","text":"摘要:由于公司业务 有大量表单页面的需求 故独立封装一套表单映射 布局框架 ShFormUtilsDownloadDownload the latest JAR or grab via Maven:123456&lt;dependency&gt; &lt;groupId&gt;com.sh.zsh.code&lt;/groupId&gt; &lt;artifactId&gt;shform&lt;/artifactId&gt; &lt;version&gt;3.2.2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt;&lt;/dependency&gt; or Gradle:1compile 'com.sh.zsh.code:shform:3.2.2' 功能表单对象映射 1.页面实现 FormCheckInterface 接口 改接口 是页面表单检查的回调 下面有介绍 2.开启表单注入 FormInit.injection(this); 123456789101112131415@Override protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); nameEdit = (EditText) findViewById(R.id.name); phoneEdit = (EditText) findViewById(R.id.phone); professionEdit = (EditText) findViewById(R.id.profession); spinner = (Spinner) findViewById(R.id.spinner); married = (CheckBox) findViewById(R.id.married); party = (CheckBox) findViewById(R.id.party); /** * 初始化表单注入 要在 所有控件初始化成功后 调用 */ FormInit.injection(this); &#125; 3.在 onDestroy 里 注销 表单 12345678@Overrideprotected void onDestroy() &#123;/** * 注销表单 */FormInit.deleteInjection(this);super.onDestroy();&#125; 4.通过 @FormInjection 绑定控件 12345678910111213141516/** * name 对应 实体类 字段名 * message 参数为空的时候 默认提示 的字符串 * isNull 该字段是否可以为空 默认 false */ @FormInjection(name = \"name\", message = \"名字\",isNull = true) EditText nameEdit; @FormCheck(type = CheckType.Phone) @FormInjection(name = \"phone\", message = \"电话\") EditText phoneEdit; @FormInjection(name = \"profession\", message = \"公司-职业\") EditText professionEdit; @FormInjection(name = \"workingLife\", message = \"工作时间\") Spinner spinner; @FormInjection(name = \"married\") CheckBox married; 4.调用映射方法 12345678/** * 表单自动生成对象 */ UserModel userModel = FormUtls.formToObjectAndCheck(this,UserModel.class);/** * 实体对象 映射到表单 返回true 表示映射成功 */ FormUtls.objectToForm(this,userModel); 表单参数检查* 1.使用 @FormCheck 123456789101112131415161718192021222324252627282930313233343536//type 是 验证类型枚举 默认 是自定义验证 @FormCheck(type = CheckType.Phone) @FormInjection(name = \"phone\", message = \"电话\") EditText phoneEdit; @FormCheck @FormInjection(name = \"profession\", message = \"公司-职业\") EditText professionEdit; /** * 通过 实现 FormCheckInterface 接口的 formCheck * 自定定义 表单检查 默认要返回true * @param v * @return */ @Override public boolean formCheck(View v) &#123; switch (v.getId())&#123; case R.id.profession: if(!(professionEdit.getText()+\"\").contains(\"-\"))&#123; Toast.makeText(this,\"职业格式不正确\",Toast.LENGTH_SHORT).show(); return false; &#125; break; &#125; return true; &#125; /** * 表单检查 不合法回调 * @param v * @param message */ @Override public void formCheckNullCall(View v, String message) &#123; Toast.makeText(this,message,Toast.LENGTH_SHORT).show(); &#125; 验证类型CUSTOM,//自定义 PHONE,//手机号 EMAIL,//邮箱 CHINESE,//中文 IDCARD,//身份证 ISDATA,//“yyyy-mm-dd“ 格式的日期校验，已考虑平闰年 AMOUNT_MONEY,//金额校验，精确到2位小数 AMOUNT,//存数字 URL,//Url PASSWORD;//密码强度 是不是6至12位字母组合 快速生成表单布局 ShFormLayoutShFormLayout 可以在使用 系统控件的基础上 实现快速生成表单布局 样式 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687&lt;com.sh.zsh.code.layout.ShFormLayout &lt;!--该布局 需要在这确定 每行的高度 --&gt; app:less_form_row_height=\"50dp\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"&gt; &lt;TextView &lt;!--这里表明 这个控件 只是用于显示标题--&gt; app:less_form_group_titel=\"true\" android:text=\"基本信息\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /&gt; &lt;EditText &lt;!--该行的标题--&gt; app:less_form_title=\"姓名\" &lt;!--该行对应的字段名--&gt; app:less_form_name=\"name\" &lt;!--该行是否必填--&gt; app:less_form_must=\"true\" android:layout_height=\"wrap_content\" android:layout_width=\"match_parent\" /&gt; &lt;EditText app:less_form_title=\"电话\" &lt;!--该行的验证方式--&gt; app:less_form_check_type=\"phone\" app:less_form_name=\"phone\" android:layout_height=\"wrap_content\" android:layout_width=\"match_parent\" app:less_form_must=\"true\" /&gt; &lt;com.sh.zsh.code.layout.view.FormSpinner android:id=\"@+id/company\" app:less_form_title=\"公司\" app:less_form_name=\"company\" android:layout_height=\"wrap_content\" android:layout_width=\"match_parent\" app:less_form_must=\"true\" /&gt; &lt;com.sh.zsh.code.layout.view.FormSpinner android:id=\"@+id/department\" app:less_form_title=\"部门\" app:less_form_name=\"department\" android:layout_height=\"wrap_content\" android:layout_width=\"match_parent\" app:less_form_must=\"true\" /&gt; &lt;com.sh.zsh.code.layout.view.FormTimeView app:less_form_title=\"出生日期\" app:less_form_name=\"birthday\" android:layout_height=\"wrap_content\" android:layout_width=\"match_parent\" app:less_form_must=\"true\" /&gt; &lt;CheckBox app:less_form_title=\"男性：\" app:less_form_name=\"sex\" android:layout_height=\"wrap_content\" android:layout_width=\"match_parent\" app:less_form_must=\"true\" /&gt; &lt;LinearLayout app:less_form_group_top_layout=\"true\" android:layout_width=\"match_parent\" android:layout_height=\"150dp\" android:background=\"@color/white\" android:orientation=\"horizontal\"&gt; &lt;TextView android:layout_width=\"wrap_content\" android:layout_height=\"match_parent\" android:layout_margin=\"18dp\" android:textSize=\"@dimen/form_text_size\" android:text=\"签名\" /&gt; &lt;EditText android:id=\"@+id/sign\" android:gravity=\"top\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:layout_margin=\"16dp\" android:padding=\"5dp\" android:textSize=\"@dimen/form_text_size\" android:background=\"@drawable/bg_text_factoryaudit\" android:hint=\"多行输入\" /&gt; &lt;/LinearLayout&gt; &lt;/com.sh.zsh.code.layout.ShFormLayout&gt; 界面预览 快看，你不需要去关心 每一行的样式，高度 只需要确定这一行是 TextView 或是EditText 等控件 就可以了我们来看一下 框架都提供了 哪些表单属性 供我们使用 ShFormLayout less_form_row_height 表单每行的 高度 内部控件less_form_title 名称less_form_title_image 设置名称左侧的iconless_form_can_click 该行是否显示 右侧箭头less_form_must 该字段是否必填less_form_name 该字段对应实体类的字段名称less_form_is_null 该字段是否可以为空less_form_bottomLine 该行是否显示底部横线less_form_check_type 检查类型less_form_group_titel 该组表单的标题 （上面的例子里 基本信息 那一行）less_form_group_top_layout 改控件不 参与表单映射 和布局生成（上面的例子里签名 那个布局） FormTimeView 时间控件less_time_is_time 时间控件的格式（all，year_month_day，hours_mins，month_day_hour_min，year_month） FormSpinner 选择器 用法参考Demoless_form_spi_sel 默认选中第一项 源码地址：https://github.com/hui46226021/ShFormUtils","categories":[{"name":"Android","slug":"Android","permalink":"https://hui46226021.github.io/categories/Android/"},{"name":"JAVA","slug":"Android/JAVA","permalink":"https://hui46226021.github.io/categories/Android/JAVA/"},{"name":"View","slug":"Android/JAVA/View","permalink":"https://hui46226021.github.io/categories/Android/JAVA/View/"}],"tags":[{"name":"移动开发","slug":"移动开发","permalink":"https://hui46226021.github.io/tags/移动开发/"},{"name":"原创","slug":"原创","permalink":"https://hui46226021.github.io/tags/原创/"},{"name":"Form","slug":"Form","permalink":"https://hui46226021.github.io/tags/Form/"},{"name":"框架","slug":"框架","permalink":"https://hui46226021.github.io/tags/框架/"},{"name":"表单映射","slug":"表单映射","permalink":"https://hui46226021.github.io/tags/表单映射/"},{"name":"自定义View","slug":"自定义View","permalink":"https://hui46226021.github.io/tags/自定义View/"}]},{"title":"ShVideoDemo android 适配录制，压缩","slug":"ShVideoDemo android 适配录制，压缩","date":"2017-02-18T14:37:23.000Z","updated":"2017-09-29T14:59:42.913Z","comments":true,"path":"2017/02/18/ShVideoDemo android 适配录制，压缩/","link":"","permalink":"https://hui46226021.github.io/2017/02/18/ShVideoDemo android 适配录制，压缩/","excerpt":"摘要：Android 视频录制Demo 仿微信小视频 视频压缩（FFmpeg）","text":"摘要：Android 视频录制Demo 仿微信小视频 视频压缩（FFmpeg） ShVideoDemoAndroid 视频录制Demo 防微信小视频 视频压缩（FFmpeg） #Download Download the latest JAR or grab via Maven:123456&lt;dependency&gt; &lt;groupId&gt;com.sh.shvideo&lt;/groupId&gt; &lt;artifactId&gt;shvideolibrary&lt;/artifactId&gt; &lt;version&gt;1.0.3&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt;&lt;/dependency&gt; or Gradle:1compile 'com.sh.shvideo:shvideolibrary:1.0.3' 注意:targetSdkVersion 23 及以上 要注意 6.0运行时权限 或干脆用23以下 源码地址:https://github.com/hui46226021/ShVideoDemo","categories":[{"name":"Android","slug":"Android","permalink":"https://hui46226021.github.io/categories/Android/"},{"name":"JAVA","slug":"Android/JAVA","permalink":"https://hui46226021.github.io/categories/Android/JAVA/"},{"name":"FFmpeg","slug":"Android/JAVA/FFmpeg","permalink":"https://hui46226021.github.io/categories/Android/JAVA/FFmpeg/"}],"tags":[{"name":"移动开发","slug":"移动开发","permalink":"https://hui46226021.github.io/tags/移动开发/"},{"name":"原创","slug":"原创","permalink":"https://hui46226021.github.io/tags/原创/"},{"name":"视频压缩","slug":"视频压缩","permalink":"https://hui46226021.github.io/tags/视频压缩/"},{"name":"视频录制","slug":"视频录制","permalink":"https://hui46226021.github.io/tags/视频录制/"}]},{"title":"Android系统启动流程","slug":"Android系统启动流程","date":"2017-01-21T14:37:23.000Z","updated":"2017-09-29T14:59:40.158Z","comments":true,"path":"2017/01/21/Android系统启动流程/","link":"","permalink":"https://hui46226021.github.io/2017/01/21/Android系统启动流程/","excerpt":"摘要:梳理一下android系统的启动流程，从init进程 到java层面","text":"摘要:梳理一下android系统的启动流程，从init进程 到java层面 init是一个进程，做完android系统启动的第一个进程，同时也是linux内核启动的第一个进程，init进程在启动过程中起到了重要的责任。 init进程的工作 1.解析配置文件 在init进程中会解析两个配置文件，一个是init.rc, 另一个是 与硬件平台相关的 配置 2.解析Service 3.启动zygote 关于 zygotezygote本身是个Native程序。原名app_process ,该名字 在Android.mk中指定，运行在 该进程又将自己的 名字改成zygote，zygote 启动AppRuntime.在AppRuntime 中主要完成了3步 1.创建虚拟机 startVm 2.注册JNI函数 startReg 3.调用com.android.internal.os.Zygotelnit的main函数，正式让系统进入了java语言的世界 在Zygotelnit 的main函数中 1.建立IPC通信服务端 2.调用registerZygoteSocket ,通过这个函数他可以相应子孙后代的请求，预加载类和资源（预加载相当多的类 1000多个 想想 android启动为啥慢） 3.启动system_server 分裂出一个子进程（承担一部分责任，建立与Binder的链接，调用init1 和inti2来启动一些系统服务） 4.zygote完成创世纪调用下runSelectLoopMode 便睡了","categories":[{"name":"Android","slug":"Android","permalink":"https://hui46226021.github.io/categories/Android/"},{"name":"JAVA","slug":"Android/JAVA","permalink":"https://hui46226021.github.io/categories/Android/JAVA/"},{"name":"Linux","slug":"Android/JAVA/Linux","permalink":"https://hui46226021.github.io/categories/Android/JAVA/Linux/"}],"tags":[{"name":"移动开发","slug":"移动开发","permalink":"https://hui46226021.github.io/tags/移动开发/"},{"name":"Android","slug":"Android","permalink":"https://hui46226021.github.io/tags/Android/"},{"name":"系统","slug":"系统","permalink":"https://hui46226021.github.io/tags/系统/"}]},{"title":"Retrofit2.0 - 网络请求库 注解 详解","slug":"Retrofit2.0","date":"2017-01-01T04:32:21.000Z","updated":"2017-03-18T01:24:40.644Z","comments":true,"path":"2017/01/01/Retrofit2.0/","link":"","permalink":"https://hui46226021.github.io/2017/01/01/Retrofit2.0/","excerpt":"Retrofit基于注解和动态代理，优化了Android中的网络请求操作。","text":"Retrofit基于注解和动态代理，优化了Android中的网络请求操作。 OverView这篇笔记基于Retrofit 1.9。 从上图可见，对Retrofit的使用可以分成三部分： 1.建立POJO或者Model Class服务端返回给客户端的数据一般都是JSON格式，所以可以利用GSON或其他库把JSON直接转换成一个对象。POJO或这个Model Class就是这个对象的类。 2.定义REST API Interface定义一个Interface，声明我们需要的网络请求方法。例如：1234public interface GitHubService &#123; @GET(\"/users/&#123;user&#125;/repos\") List&lt;Repo&gt; listRepos(@Path(\"user\") String user);&#125; Repo，就是第一步中定义的POJO或者Model Class。Retrofit框架会自动把服务端返回的JSON数据，转换成Repo。Retrofit默认采用GSON库。 3.RestAdapterRestAdapter用来配置网络请求的参数，并且生成一个接口的实现。配置请求参数：1234RestAdapter restAdapter = new RestAdapter.Builder() .setEndpoint(\"https://api.github.com\") .setClient(new OkClient(new OkHttpClient())) .build(); 生成接口的实现：1GitHubService service = restAdapter.create(GitHubService.class); 以上三步完成后，调用接口函数完成与服务器的交互： List repos = service.listRepos(“octocat”); 请求方法 Retrofit框架提供了很多注解，其中HTTP注解有五个，用来修饰请求方法（还可以顺便处理URL路径）： GET POST PUT DELETE HEAD这五个注解正好涵盖了数据的增删改查方法，符合REST标准。每一个请求方法都必须要由这五个注解中的一个修饰。1@GET(\"/users/list\") 可以在注解中添加查询参数1@GET(\"/users/list?sort=desc\") URL处理 @Path - 替换参数 12@GET(\"/group/&#123;id&#125;/users\")List&lt;User&gt; groupList(@Path(\"id\") int groupId); @Query - 添加查询参数 12@GET(\"/group/&#123;id&#125;/users\")List&lt;User&gt; groupList(@Path(\"id\") int groupId, @Query(\"sort\") String sort); @QueryMap - 如果有多个查询参数，把它们放在Map中 12@GET(\"/group/&#123;id&#125;/users\")List&lt;User&gt; groupList(@Path(\"id\") int groupId, @QueryMap Map&lt;String, String&gt; options); 请求体请求体（RequestBody），一般用于POST方法传递请求参数。@Body12@POST(\"/users/new\")void createUser(@Body User user, Call&lt;User&gt; call); 参数会被指定的转换器转换成字符串或字节流提交到服务器，如果没有指定转换器，Retrofit将会默认使用RequestBody。 FORM ENCODED(表单) And MULTIPART FORM ENCODED 使用 @FormUrlEncoded 修饰请求方法，可以把表单数据提交到服务端。用 @Field 修饰key-value对。123@FormUrlEncoded@POST(\"/user/edit\")User updateUser(@Field(\"first_name\") String first, @Field(\"last_name\") String last); MULTIPART 使用 @Multipart 修饰请求方法，@Part 修饰每一个Part123@Multipart@PUT(\"/user/photo\")User updateUser(@Part(\"photo\") TypedFile photo, @Part(\"description\") TypedString description); Multipart 中的Part使用 RestAdapter 的转换器来转换，也可以实现 TypedOutput 自己处理序列化。 Multipart主要用来上传文件吗？如果是，具体操作又是如何？ 答案在这里 配制HEADER用 @Headers 设置Http请求的header。12345678910@Headers(\"Cache-Control: max-age=640000\")@GET(\"/widget/list\")void widgetList(Call&lt;List&lt;Widget&gt;&gt; call);@Headers(&#123; \"Accept: application/vnd.github.v3.full+json\", \"User-Agent: Retrofit-Sample-App\"&#125;)@GET(\"/users/&#123;username&#125;\")void getUser(@Path(\"username\") String username, Call&lt;User&gt;); Http请求头不会互相覆盖，如果存在多个请求头的名字相同，那么它们全部都会被包含在Http请求中。 动态更新HEADER 在请求方法的参数中，用 @Header 动态更新Http请求头12@GET(\"/user\")void getUser(@Header(\"Authorization\") String authorization, Call&lt;User&gt; call) 参数不能为null，否则这个header将会被删掉。 在RestAdapter中，利用RequestInterceptor动态更新Header12345678910RequestInterceptor requestInterceptor = new RequestInterceptor() &#123; @Override public void intercept(RequestFacade request) &#123; request.addHeader(\"User-Agent\", \"Retrofit-Sample-App\"); &#125;&#125;;RestAdapter restAdapter = new RestAdapter.Builder() .setEndpoint(\"https://api.github.com\") .setRequestInterceptor(requestInterceptor) .build(); 异步与同步每个请求方法都可以定义成同步或者异步。 同步 同步方法有返回值，且参数中不包含回调123456789101112131415161718192021 @GET(\"/users/&#123;user&#125;/repos\") List&lt;Repo&gt; listRepos(@Path(\"user\") String user);~~* 异步异步方法没有返回值，且最后一个参数须是Callback对象~~~java @GET(\"/users/&#123;user&#125;/repos\") void listRepos(@Path(\"user\") String user, Callback&lt;List&lt;Repo&gt;&gt; call);~~在Android中，callbacks将会在主线程中调用。在普通Java程序中，callbacks将会在执行HTTP请求方法的那个线程中调用。## 处理服务器返回结果RestAdapter中的转换器会把服务器的返回结果（一般为JSON）转换成我们在函数返回值或Callback接口中定义的Java对象。~~~java @GET(\"/users/&#123;user&#125;/repos\") List&lt;Repo&gt; listRepos(@Path(\"user\") String user); @GET(\"/users/&#123;user&#125;/repos\") void listRepos(@Path(\"user\") String user, Callback&lt;List&lt;Repo&gt;&gt; call); List,就是将要被转换成的Java对象。 直接获取返回体如果要直接获取服务器返回的HTTP返回体，在返回值或callback中直接使用 Response对象。12345@GET(\"/users/&#123;user&#125;/repos\")Response listRepos(@Path(\"user\") String user);@GET(\"/users/&#123;user&#125;/repos\")void listRepos(@Path(\"user\") String user, Callback&lt;Response&gt; call); 参考链接: 官方文档：不过是Retrofit2.0中文文档：这个是Retrofit1.9源码解析：[http://frodoking.github.io/2015/05/16/android-retrofit/](http://frodoking.github.io/2015/05/16/ 原文地址：http://www.jianshu.com/p/63723f593695","categories":[{"name":"Android","slug":"Android","permalink":"https://hui46226021.github.io/categories/Android/"},{"name":"JAVA","slug":"Android/JAVA","permalink":"https://hui46226021.github.io/categories/Android/JAVA/"},{"name":"restful","slug":"Android/JAVA/restful","permalink":"https://hui46226021.github.io/categories/Android/JAVA/restful/"}],"tags":[{"name":"移动开发","slug":"移动开发","permalink":"https://hui46226021.github.io/tags/移动开发/"},{"name":"转贴","slug":"转贴","permalink":"https://hui46226021.github.io/tags/转贴/"},{"name":"Retrofit2.0","slug":"Retrofit2-0","permalink":"https://hui46226021.github.io/tags/Retrofit2-0/"},{"name":"网络访问","slug":"网络访问","permalink":"https://hui46226021.github.io/tags/网络访问/"}]},{"title":"Android Library项目发布到JCenter最简单的配置方法","slug":"JCenter","date":"2016-12-22T04:32:21.000Z","updated":"2017-03-18T00:57:54.385Z","comments":true,"path":"2016/12/22/JCenter/","link":"","permalink":"https://hui46226021.github.io/2016/12/22/JCenter/","excerpt":"为了方便 需要把jar发布到Maven服务器网上的步骤看起来实在太麻烦，gituhb上偶然间看到的一个项目，经过实际验证确实可行。github连接：https://github.com/xiaopansky/android-library-publish-to-jcenter 这是一个帮助Android开发者将aar发布到jcenter的项目，这个项目已经将需要写的脚本封装好了，我们只需要配置相关属性即可在5分钟之内发布我们的项目到JCenter 先看一下上传过程图解","text":"为了方便 需要把jar发布到Maven服务器网上的步骤看起来实在太麻烦，gituhb上偶然间看到的一个项目，经过实际验证确实可行。github连接：https://github.com/xiaopansky/android-library-publish-to-jcenter 这是一个帮助Android开发者将aar发布到jcenter的项目，这个项目已经将需要写的脚本封装好了，我们只需要配置相关属性即可在5分钟之内发布我们的项目到JCenter 先看一下上传过程图解 步骤1. 注册Bintray账号 ([传送门(https://bintray.com))Bintray是jcenter的托管商，因此你必须注册一个Bintray账号，注册完账号后记下你的用户名以及API Key。 登陆后在首页右上角点击用户名进入个人主页，然后点击用户名下面的Edit进入个人信息编辑页面，接下来点击页面左边列表的最后一项API Key 如图所示点击最右边箭头指示的复制按钮即可复制你的API Key 注册得时候要注意 这里有两个坑有两个注册 入口 要选上面得那个 否者最后会创建不了项目 报HTTP/1.1 404 Not Found 得错误 1 注册时，不少邮箱地址还不支持，要注意。 2 创建仓库时，如果使用Bintray-release,名字就填成maven,因为他的wiki:repoName: The repository name. Set to ‘maven’ by default.(有错误请指出) 这里写图片描述 Finally，坑了我一天之后，终于BUILD SUCCESSFUL了 检查Android插件版本 首先你要检查你的Android插件的版本，因为1.1.0版本有一个BUG会导致生成javadoc失败，所以你只需升级到最新即可。目前最新版本是1.3.0，在项目根目录下的build.gradle文件中修改版本号即可，如下: 复制代码123456789101112131415161718// Top-level build file where you can add configuration options common to all sub-projects/modules.buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:1.3.0' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125;&#125;allprojects &#123; repositories &#123; jcenter() &#125;&#125; 如果你在看到这篇文章的时候有更新的版本的话，直接改为最新的版本即可。 添加所需插件 在项目根目录下build.gradle文件中的dependencies节点中追加如下代码：12classpath 'com.github.dcendents:android-maven-gradle-plugin:1.3'classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.0' android-maven-gradle-plugin插件是用来打包Maven所需文件的 gradle-bintray-plugin插件是用来将生成的Maven所需文件上传到Bintray的 完成后如下所示： 123456789101112131415161718192021// Top-level build file where you can add configuration options common to all sub-projects/modules.buildscript &#123; repositories &#123; jcenter() &#125; dependencies &#123; classpath 'com.android.tools.build:gradle:1.3.0' classpath 'com.github.dcendents:android-maven-gradle-plugin:1.3' classpath 'com.jfrog.bintray.gradle:gradle-bintray-plugin:1.0' // NOTE: Do not place your application dependencies here; they belong // in the individual module build.gradle files &#125;&#125;allprojects &#123; repositories &#123; jcenter() &#125;&#125; 配置项目信息 下载project.properties文件并放到你的library module目录下 project.properties文件的原始内容如下： 1234567891011#projectproject.name=project.groupId=project.artifactId=project.packaging=aarproject.siteUrl=project.gitUrl=#javadocjavadoc.name= 详解： project.name：项目名称 project.groupId：项目组ID，通常情况下如果你的包名为com.example.test，那么项目组ID就是com.example project.artifactId：项目ID，通常情况下如果你的包名为com.example.test，那么项目ID就是test project.packaging：包类型，Android库是aar project.siteUrl：项目官方网站的地址，没有的话就用Github上的地址，例如：https://github.com/xiaopansky/Sketch project.gitUrl：项目的Git地址，例如：https://github.com/xiaopansky/Sketch.git javadoc.name：生成的javadoc打开后主页显示的名称，通常跟项目名称一样即可完成配置后如下所示： 1234567891011#projectproject.name=Sketchproject.groupId=me.xiaopanproject.artifactId=sketchproject.packaging=aarproject.siteUrl=https://github.com/xiaopansky/Sketchproject.gitUrl=https://github.com/xiaopansky/Sketch.git#javadocjavadoc.name=Sketch 配置Bintray账号以及开发者信息 下载local.properties文件并放到你的library module目录下 local.properties文件的原始内容如下： 12345678#bintraybintray.user=bintray.apikey=#developerdeveloper.id=developer.name=developer.email= 详解： bintray.user：你的Bintray的用户名 bintray.apikey：你的的Bintray的API Key developer.id：通常是你在开源社区的昵称 developer.name：你的姓名 developer.email：你的邮箱完成配置后如下所示： 123456789#bintraybintray.user=xiaopanskybintray.apikey=*****************************#developerdeveloper.id=xiaopandeveloper.name=********developer.email=sky@xiaopan.me *号显示的为个人信息不反方便透露，还请见谅 注意要将local.proerties文件加入忽略列表，以免被提交到Github或其他网站泄露个人信息 配置bintrayUpload.gradle 方法1：直接使用远程bintrayUpload.gradle文件 修改你的library module的build.gradle文件，在最后加上apply from: “https://raw.githubusercontent.com/xiaopansky/android-library-publish-to-jcenter/master/bintrayUpload.gradle&quot;，如下所示： 1234567891011121314151617181920212223apply plugin: 'com.android.library'android &#123; compileSdkVersion 22 buildToolsVersion \"22.0.0\" defaultConfig &#123; minSdkVersion 7 targetSdkVersion 22 versionCode 100 versionName \"1.0.0\" &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125;&#125;apply from: \"https://raw.githubusercontent.com/xiaopansky/android-library-publish-to-jcenter/master/bintrayUpload.gradle\" 方法2：下载后使用本地bintrayUpload.gradle文件 首先下载bintrayUpload.gradle文件并放到你的library module目录下 然后修改你的library module的build.gradle文件，在最后加上apply from: “bintrayUpload.gradle”，如下所示： 1234567891011121314151617181920212223apply plugin: 'com.android.library'android &#123; compileSdkVersion 22 buildToolsVersion \"22.0.0\" defaultConfig &#123; minSdkVersion 7 targetSdkVersion 22 versionCode 100 versionName \"1.0.0\" &#125; buildTypes &#123; release &#123; minifyEnabled false proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' &#125; &#125;&#125;apply from: \"bintrayUpload.gradle\" 推荐大家使用第一种方案，简单快捷，至此配置工作已全部结束 执行命令打包并上传到Bintray 打开终端进入项目目录下， 执行 gradlew install 先编译一下 再执行gradlew bintrayUpload命令即可 另外，如果你的本地已经配置了Gradle了，那么执行gradle bintrayUpload命令也可以。gradlew是Gradle的一层封装，如果你本地没有安装Gradle gradlew就会自动下载Gradle 请求提交你的项目到jcenter 前面所有步骤走完之后实际上只是上传了你的项目到Bintray而已，并没有被包含在jcenter中，要想提交到jcenter中还需要Bintray的审核。 登入Bintray网站，进入个人中心，在右侧的Owned Repositories区域点击Maven的图标，进入你的Maven项目列表。 如果已经上传成功了，在这里就能看到你的项目，进入项目详情，在右下角的Linked To区域点击Add to JCenter，然后在Comments输入框里随便填写下信息，最后点Send提交请求即可 一般情况下审核需要4到5个小时，耐心等待就行了，审核通过后会给你发邮件通知你，并且以后更新项目就不需要再审核了。 一句话导入你的项目 当审核通过后，别人就可以一句话导入你的项目了，例如：1compile 'me.xiaopan:sketch:2.0.0' 额外补充： 保持你的library module的名字同artifactId一样 因为在Bintray上你的项目的maven-metadata.xml文件的路径是gruopId+”/“+module名称。 例如你的groupId是com.example，artifactId是test，但module名称是library。 这时候项目文件是在com.example.test目录下的，但maven-metadata.xml文件却是在com.example.library目录下的。 这样一来如果你有多个项目groupId一样，artifactId不一样，但module名称都是library的话，可能就会冲突。 目前为止我还没有找到更好的解决办法，就只能让module名称和artifactId保持一致，如果你们谁有更好的办法，欢迎留言交流。 参考文章 Android拓展系列(12)–使用Gradle发布aar项目到JCenter仓库使用Gradle发布Android开源项目到JCenterAndroid 项目打包到 JCenter 的坑 常见问题 Error:Cause: org/gradle/api/publication/maven/internal/DefaultMavenFactory：当你使用的Gradle版本是2.4以上，Android插件版本是1.3.0以上的时候就会出现这个问题，这时候你只需将android-maven-gradle-plugin插件版本改为classpath ‘com.github.dcendents:android-maven-gradle-plugin:1.3’即可You are using JDK version ‘java version “1.7.0_71”’. Some versions of JDK 1.7 (e.g. 1.7.0_10) may cause class loading errors in Gradle.Please update to a newer version (e.g. 1.7.0_67)：当你使用的Gradle版本是2.4以上，Andriod插件版本是1.2.3的时候就会出现这个问题，同样的你只需要将android-maven-gradle-plugin插件版本改为classpath ‘com.github.dcendents:android-maven-gradle-plugin:1.3’即可 以上文章转载：https://github.com/xiaopansky/android-library-publish-to-jcenter 关于jcenter和Maven Central的理解和gradle是如何从仓库上获取一个library 如果你想在Android Studio中引入一个library到你的项目，你只需添加如下的一行代码到模块的build.gradle文件中。123dependencies &#123; compile 'com.inthecheesefactory.thecheeselibrary:fb-like:0.9.3'&#125; 就是如此简单的一行代码，你就可以使用这个library了。 酷呆了。不过你可能很好奇Android Studio是从哪里得到这个library的。这篇文章将详细讲解这是怎么回事，包括如何把你的库发布出去分享给世界各地的其他开发者，这样不仅可以让世界更美好，还可以耍一次酷。 Android studio 是从哪里得到库的？先从这个简单的问题开始，我相信不是每个人都完全明白Android studio 是从哪里得到这些library的。莫非就是Android studio 从google搜索然后下载了一个合适的给我们？ 呵 呵，没那么复杂。Android Studio是从build.gradle里面定义的Maven 仓库服务器上下载library的。Apache Maven是Apache开发的一个工具，提供了用于贡献library的文件服务器。总的来说，只有两个标准的Android library文件服务 器：jcenter 和 Maven Central。 jcenterjcenter是一个由 bintray.com维护的Maven仓库 。你可以在这里看到整个仓库的内容。 我们在项目的build.gradle 文件中如下定义仓库，就能使用jcenter了：12345allprojects &#123; repositories &#123; jcenter() &#125;&#125; Maven CentralMaven Central 则是由sonatype.org维护的Maven仓库。你可以在这里看到整个仓库。 注：不管是jcenter还是Maven Central ，两者都是Maven仓库 我们在项目的build.gradle 文件中如下定义仓库，就能使用Maven Central了：12345allprojects &#123; repositories &#123; mavenCentral() &#125;&#125; 注意，虽然jcenter和Maven Central 都是标准的 android library仓库，但是它们维护在完全不同的服务器上，由不同的人提供内容，两者之间毫无关系。在jcenter上有的可能 Maven Central 上没有，反之亦然。 除了两个标准的服务器之外，如果我们使用的library的作者是把该library放在自己的服务器上，我们还可以自己定义特有的Maven仓库服务器。Twitter的Fabric.io 就是这种情况，它们在https://maven.fabric.io/public上维护了一个自己的Maven仓库。如果你想使用Fabric.io的library，你必须自己如下定义仓库的url。123repositories &#123; maven &#123; url 'https://maven.fabric.io/public' &#125;&#125; 然后在里面使用相同的方法获取一个library。 dependencies { compile ‘com.crashlytics.sdk.android:crashlytics:2.2.4@aar’}但是将library上传到标准的服务器与自建服务器，哪种方法更好呢？当然是前者。如果将我们的library公开，其他开发者除了一行定义依赖名的代码之外不需要定义任何东西。因此这篇文章中，我们将只关注对开发者更友好的jcenter 和 Maven Central 。 实际上可以在Android Studio上使用的除了Maven 仓库之外还有另外一种仓库：Ivy 仓库 。但是根据我的经验来看，我还没看到任何人用过它，包括我，因此本文就直接忽略了。 理解jcenter和Maven Central为何有两个标准的仓库？ 事实上两个仓库都具有相同的使命：提供Java或者Android library服务。上传到哪个（或者都上传）取决于开发者。 起初，Android Studio 选择Maven Central作为默认仓库。如果你使用老版本的Android Studio创建一个新项目，mavenCentral()会自动的定义在build.gradle中。 但 是Maven Central的最大问题是对开发者不够友好。上传library异常困难。上传上去的开发者都是某种程度的极客。同时还因为诸如安全方面的其他原 因，Android Studio团队决定把默认的仓库替换成jcenter。正如你看到的，一旦使用最新版本的Android Studio创建一个项目，jcenter()自动被定义，而不是mavenCentral()。 有许多将Maven Central替换成jcenter的理由，下面是几个主要的原因。 jcenter通过CDN发送library，开发者可以享受到更快的下载体验。 jcenter是全世界最大的Java仓库，因此在Maven Central 上有的，在jcenter上也极有可能有。换句话说jcenter是Maven Central的超集。 上传library到仓库很简单，不需要像在 Maven Central上做很多复杂的事情。 友好的用户界面 如果你想把library上传到 Maven Central ，你可以在bintray网站上直接点击一个按钮就能实现。 基于上面的原因以及我自己的经验，可以说替换到jcenter是明智之举。 所以我们这篇文章将把重心放在jcenter，反正如果你能成功把library放在jcenter，转到 Maven Central 是非常容易的事情。 gradle是如何从仓库上获取一个library的？在讨论如何上传library到jcenter之前，我们先看看gradle是如何从仓库获取library的。比如我们在 build.gradle输入如下代码的时候，这些库是如果奇迹般下载到我们的项目中的。1compile 'com.inthecheesefactory.thecheeselibrary:fb-like:0.9.3' 一般来说，我们需要知道library的字符串形式，包含3部分 GROUP_ID:ARTIFACT_ID:VERSION上面的例子中，GROUP_ID是com.inthecheesefactory.thecheeselibrary ，ARTIFACT_ID是fb-like，VERSION是0.9.3。 GROUP_ID 定义了library的group。有可能在同样的上下文中存在多个不同功能的library。如果library具有相同的group，那么它们将共享 一个GROUP_ID。通常我们以开发者包名紧跟着library的group名称来命名，比如com.squareup.picasso。然后 ARTIFACT_ID中是library的真实名称。至于VERSION，就是版本号而已，虽然可以是任意文字，但是我建议设置为x.y.z的形式，如 果喜欢还可以加上beta这样的后缀。 下面是Square library的一个例子。你可以看到每个都可以很容易的分辨出library和开发者的名称。 1234567dependencies &#123; compile 'com.squareup:otto:1.3.7' compile 'com.squareup.picasso:picasso:2.5.2' compile 'com.squareup.okhttp:okhttp:2.4.0' compile 'com.squareup.retrofit:retrofit:1.9.0'&#125; 那么在添加了上面的依赖之后会发生什么呢？简单。Gradle会询问Maven仓库服务器这个library是否存在，如果是，gradle会获得 请求library的路径，一般这个路径都是这样的形式：GROUP_ID/ARTIFACT_ID/VERSION_ID。比如可以在http://jcenter.bintray.com/com/squareup/otto/1.3.7 和 https://oss.sonatype.org/content/repositories/releases/com/squareup/otto/1.3.7/ 下获得com.squareup:otto:1.3.7的library文件。 然后Android Studio 将下载这些文件到我们的电脑上，与我们的项目一起编译。整个过程就是这么简单，一点都不复杂。 我 相信你应该清楚的知道从仓库上下载的library只是存储在仓库服务器上的jar 或者aar文件而已。有点类似于自己去下载这些文件，拷贝然后和项目 一起编译。但是使用gradle依赖管理的最大好处是你除了添加几行文字之外啥也不做。library一下子就可以在项目中使用了。 了解aar文件 等等，我刚才说了仓库中存储的有两种类型的library：jar 和 aar。jar文件大家都知道，但是什么是aar文件呢？ aar文件时在jar文件之上开发的。之所以有它是因为有些Android Library需要植入一些安卓特有的文件，比如AndroidManifest.xml，资源文件，Assets或者JNI。这些都不是jar文件的标准。 因此aar文件就时发明出来包含所有这些东西的。总的来说它和jar一样只是普通的zip文件，不过具有不同的文件结构。jar文件以classes.jar的名字被嵌入到aar文件中。其余的文件罗列如下： /AndroidManifest.xml (mandatory) /classes.jar (mandatory) /res/ (mandatory) /R.txt (mandatory) /assets/ (optional) /libs/*.jar (optional) /jni//*.so (optional) /proguard.txt (optional) /lint.jar (optional) 可以看到.aar文件是专门为安卓设计的。 以上转载：http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0623/3097.html 后记Gradle 2.4之后已经可以使用JitPack发布项目，这个用起来甚至比上述方法还要简单的多，感兴趣的可以了解一下。 JitPack官网：https://jitpack.io/相当方便","categories":[{"name":"Android","slug":"Android","permalink":"https://hui46226021.github.io/categories/Android/"},{"name":"JAVA","slug":"Android/JAVA","permalink":"https://hui46226021.github.io/categories/Android/JAVA/"},{"name":"gradle","slug":"Android/JAVA/gradle","permalink":"https://hui46226021.github.io/categories/Android/JAVA/gradle/"},{"name":"Maven","slug":"Android/JAVA/gradle/Maven","permalink":"https://hui46226021.github.io/categories/Android/JAVA/gradle/Maven/"},{"name":"JCenter","slug":"Android/JAVA/gradle/Maven/JCenter","permalink":"https://hui46226021.github.io/categories/Android/JAVA/gradle/Maven/JCenter/"}],"tags":[{"name":"移动开发","slug":"移动开发","permalink":"https://hui46226021.github.io/tags/移动开发/"},{"name":"转贴","slug":"转贴","permalink":"https://hui46226021.github.io/tags/转贴/"},{"name":"Maven","slug":"Maven","permalink":"https://hui46226021.github.io/tags/Maven/"},{"name":"JCenter","slug":"JCenter","permalink":"https://hui46226021.github.io/tags/JCenter/"}]},{"title":"关于JVM类加载器","slug":"关于JAVA类加载器","date":"2016-10-21T12:37:23.000Z","updated":"2017-09-29T14:47:13.082Z","comments":true,"path":"2016/10/21/关于JAVA类加载器/","link":"","permalink":"https://hui46226021.github.io/2016/10/21/关于JAVA类加载器/","excerpt":"摘要:最近需要弄android的 插件开发，那就先从JAVA的类加载器开始吧","text":"摘要:最近需要弄android的 插件开发，那就先从JAVA的类加载器开始吧 首先来了解一下字节码和class文件的区别：我们知道，新建一个java对象的时候，JVM要将这个对象对应的字节码加载到内存中，这个字节码的原始信息存放在classpath(就是我们新建Java工程的bin目录下)指定的目录下的.class文件,类加载需要将.class文件导入到硬盘中，经过一些处理之后变成字节码在加载到内存中。 顾名思义，类加载器（class loader）用来加载 Java 类到 Java 虚拟机中。一般来说，Java 虚拟机使用 Java 类的方式如下：Java 源程序（.java 文件）在经过 Java 编译器编译之后就被转换成 Java 字节代码（.class 文件）。类加载器负责读取 Java 字节代码，并转换成 java.lang.Class类的一个实例。每个这样的实例用来表示一个 Java 类。通过此实例的 newInstance()方法就可以创建出该类的一个对象。实际的情况可能更加复杂，比如 Java 字节代码可能是通过工具动态生成的，也可能是通过网络下载的。基本上所有的类加载器都是 java.lang.ClassLoader类的一个实例 类的加载过程来自 http://blog.csdn.net/gjanyanlig/article/details/6818655/JVM将类加载过程分为三个步骤：装载（Load），链接（Link）和初始化(Initialize)链接又分为三个步骤，如下图所示： 1) 装载：查找并加载类的二进制数据；2)链接：验证：确保被加载类的正确性；准备：为类的静态变量分配内存，并将其初始化为默认值；解析：把类中的符号引用转换为直接引用；3)初始化：为类的静态变量赋予正确的初始值； 那为什么我要有验证这一步骤呢？首先如果由编译器生成的class文件，它肯定是符合JVM字节码格式的，但是万一有高手自己写一个class文件，让JVM加载并运行，用于恶意用途，就不妙了，因此这个class文件要先过验证这一关，不符合的话不会让它继续执行的，也是为了安全考虑吧。 准备阶段和初始化阶段看似有点牟盾，其实是不牟盾的，如果类中有语句：private static int a = 10，它的执行过程是这样的，首先字节码文件被加载到内存后，先进行链接的验证这一步骤，验证通过后准备阶段，给a分配内存，因为变量a是static的，所以此时a等于int类型的默认初始值0，即a=0,然后到解析（后面在说），到初始化这一步骤时，才把a的真正的值10赋给a,此时a=10。 类的初始化 类什么时候才被初始化：1）创建类的实例，也就是new一个对象2）访问某个类或接口的静态变量，或者对该静态变量赋值3）调用类的静态方法4）反射（Class.forName(“com.lyj.load”)）5）初始化一个类的子类（会首先初始化子类的父类）6）JVM启动时标明的启动类，即文件名和类名相同的那个类只有这6中情况才会导致类的类的初始化。 类的初始化步骤：1）如果这个类还没有被加载和链接，那先进行加载和链接 2）假如这个类存在直接父类，并且这个类还没有被初始化（注意：在一个类加载器中，类只能初始化一次），那就初始化直接的父类（不适用于接口） 3)加入类中存在初始化语句（如static变量和static块），那就依次执行这些初始化语句。 3.类的加载 类的加载指的是将类的.class文件中的二进制数据读入到内存中，将其放在运行时数据区的方法区内，然后在堆区创建一个这个类的java.lang.Class对象，用来封装类在方法区类的对象。看下面2图 类的加载的最终产品是位于堆区中的Class对象 Class对象封装了类在方法区内的数据结构，并且向Java程序员提供了访问方法区内的数据结构的接口 加载类的方式有以下几种： 1）从本地系统直接加载2）通过网络下载.class文件3）从zip，jar等归档文件中加载.class文件4）从专有数据库中提取.class文件5）将Java源文件动态编译为.class文件（服务器） Java虚拟机中类加载器：java虚拟机中主要又3个系统类加载器，BootStrap,ExtClassLoader,AppClassLoader，同时也可以安装多个 其他的加载器 BootStrap,使用C/C++代码写的，是第一个类加载器，已经封装到JVM内核中了，而ExtClassLoader和AppClassLoader是Java类，其他的类加载器也都是JAVA写的。 看一下类加载器的属性结构图： Java虚拟机中的所有类加载器采用具有父子关系的树形结构进行组织，在实例化每个类加载器对象的时候，需要为其指定一个父级类加载器对象或者默认采用系统类加载器为其父级类加载类加载器的委托机制：当Java虚拟机要加载第一个类的时候，到底派出哪个类加载器去加载呢？(1). 首先当前线程的类加载器去加载线程中的第一个类(当前线程的类加载器：Thread类中有一个get/setContextClassLoader(ClassLoader cl);方法，可以获取/指定本线程中的类加载器)(2). 如果类A中引用了类B,Java虚拟机将使用加载类A的类加载器来加载类B(3). 还可以直接调用ClassLoader.loadClass(String className)方法来指定某个类加载器去加载某个类每个类加载器加载类时，又先委托给其上级类加载器当所有祖宗类加载器没有加载到类，回到发起者类加载器，还加载不了，则会抛出ClassNotFoundException,不是再去找发起者类加载器的儿子，因为没有getChild()方法。例如：如上图所示： MyClassLoader-&gt;AppClassLoader-&gt;Ext-&gt;ClassLoader-&gt;BootStrap.自定定义的MyClassLoader1首先会先委托给AppClassLoader,AppClassLoader会委托给ExtClassLoader,ExtClassLoader会委托给BootStrap，这时候BootStrap就去加载，如果加载成功，就结束了。如果加载失败，就交给ExtClassLoader去加载，如果ExtClassLoader加载成功了，就结束了，如果加载失败就交给AppClassLoader加载，如果加载成功，就结束了，如果加载失败，就交给自定义的MyClassLoader1类加载器加载，如果加载失败，就报ClassNotFoundException异常，结束。","categories":[{"name":"JVM","slug":"JVM","permalink":"https://hui46226021.github.io/categories/JVM/"},{"name":"JAVA","slug":"JVM/JAVA","permalink":"https://hui46226021.github.io/categories/JVM/JAVA/"},{"name":"Linux","slug":"JVM/JAVA/Linux","permalink":"https://hui46226021.github.io/categories/JVM/JAVA/Linux/"}],"tags":[{"name":"AppClassLoader","slug":"AppClassLoader","permalink":"https://hui46226021.github.io/tags/AppClassLoader/"},{"name":"JVN","slug":"JVN","permalink":"https://hui46226021.github.io/tags/JVN/"}]},{"title":"友盟封装第三方登录 第三方粉线","slug":"ShUmengSdk 友盟第三方分享 登录 封装","date":"2016-10-18T13:37:23.000Z","updated":"2017-09-29T14:59:24.662Z","comments":true,"path":"2016/10/18/ShUmengSdk 友盟第三方分享 登录 封装/","link":"","permalink":"https://hui46226021.github.io/2016/10/18/ShUmengSdk 友盟第三方分享 登录 封装/","excerpt":"","text":"ShUmengSdk封装友盟 第三方 分享 登录 微信支付 ###当前友盟SDK版本v6.0.9 ###所需各种 appkey 质询QQ 3431339973 ##使用方法 导入Module(umeng_sdk) 替换key_strings.xml下的所有 appkey 在项目的Application 里调用 UMShareHelper.init(this); 注册友盟 添加微信 回调页面WXEntryActivity 注意：wxapi 后的路径一定不能变 通过 ShareDialog.getInstance(this,null,”测试分享”,”https://www.baidu.co,&quot;,&quot;测试分享&quot;).showDialog();弹出分享菜单 通过 mShareAPI.getPlatformInfo(MainActivity.this, SHARE_MEDIA.WEIXIN, umAuthListener); 第三方登录 ##注意：在调用分享的页面 要加入 页面回调123456@Overrideprotected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; super.onActivityResult(requestCode, resultCode, data); UMShareAPI.get(this).onActivityResult(requestCode, resultCode, data);&#125;","categories":[{"name":"Android","slug":"Android","permalink":"https://hui46226021.github.io/categories/Android/"},{"name":"JAVA","slug":"Android/JAVA","permalink":"https://hui46226021.github.io/categories/Android/JAVA/"}],"tags":[{"name":"移动开发","slug":"移动开发","permalink":"https://hui46226021.github.io/tags/移动开发/"},{"name":"原创","slug":"原创","permalink":"https://hui46226021.github.io/tags/原创/"},{"name":"友盟","slug":"友盟","permalink":"https://hui46226021.github.io/tags/友盟/"},{"name":"第三方登录","slug":"第三方登录","permalink":"https://hui46226021.github.io/tags/第三方登录/"}]},{"title":"腾讯 IM 封装成Library","slug":"腾讯IM封装 ShIMLibrary","date":"2016-09-18T14:37:23.000Z","updated":"2017-09-29T14:59:17.599Z","comments":true,"path":"2016/09/18/腾讯IM封装 ShIMLibrary/","link":"","permalink":"https://hui46226021.github.io/2016/09/18/腾讯IM封装 ShIMLibrary/","excerpt":"把腾讯 IM 封装成Library","text":"把腾讯 IM 封装成Library IM_Demo把腾讯 IM 封装成Library依照Demo主项目 先到腾讯IM 管理平台创建应用 传送门 1.导入JrImLibrary 2.复制 主项目下im 下面的三个类 3.在Application 中初始化IM模块 4.替换string.xml 下面的 sdk_appid 和 account_type 5.还有部分功能 没有实现 例如 上传图片，和搜索用户（考虑在主项目里实现） 6.服务器端 签名生成 JAVA 代码 [下载地址] (https://github.com/hui46226021/ShIMLibrary/raw/master/java_native.rar) 源码地址:https://github.com/hui46226021/ShIMLibrary","categories":[{"name":"Android","slug":"Android","permalink":"https://hui46226021.github.io/categories/Android/"},{"name":"JAVA","slug":"Android/JAVA","permalink":"https://hui46226021.github.io/categories/Android/JAVA/"},{"name":"IM","slug":"Android/JAVA/IM","permalink":"https://hui46226021.github.io/categories/Android/JAVA/IM/"}],"tags":[{"name":"移动开发","slug":"移动开发","permalink":"https://hui46226021.github.io/tags/移动开发/"},{"name":"原创","slug":"原创","permalink":"https://hui46226021.github.io/tags/原创/"},{"name":"即时通讯","slug":"即时通讯","permalink":"https://hui46226021.github.io/tags/即时通讯/"},{"name":"腾讯IM","slug":"腾讯IM","permalink":"https://hui46226021.github.io/tags/腾讯IM/"}]},{"title":"DecorView","slug":"DecorView","date":"2016-09-17T08:17:33.000Z","updated":"2017-03-17T23:07:17.958Z","comments":true,"path":"2016/09/17/DecorView/","link":"","permalink":"https://hui46226021.github.io/2016/09/17/DecorView/","excerpt":"摘要: Activity 的结构 setContentView 的执行","text":"摘要: Activity 的结构 setContentView 的执行 执行顺序Activity的setContentView 方法里 调用了 getWindow().setContentView(layoutResID); 这个getWindow 获取到的就是PhoneWindow 在PhoneWindow里面 将布局文件 渲染到 一个mContentParent 的 viewgruop里面 viewgruop 通过generateLayout (DecorView) 生成 ,generateDecour 方法初始 该方法生成一个 DecorView DecorView 就是一个 FrameLayout 所以 所有的 Activity 的跟布局 都是一个 FrameLayout generateLayout 方法里 判断 加载不同的系统布局 （有无标题 Actionbar等）生成一个View Add到DecorView里 这是 DecorView 里 就是一个 线性布局 里面是一个 Titel 下面是个 FrameLayout getWindow().getDecorView 可以在 decorView findViewById(android.R.id.content) 获取 DecorView 里面的 FrameLayout","categories":[{"name":"Android","slug":"Android","permalink":"https://hui46226021.github.io/categories/Android/"},{"name":"JAVA","slug":"Android/JAVA","permalink":"https://hui46226021.github.io/categories/Android/JAVA/"}],"tags":[{"name":"DecorView","slug":"DecorView","permalink":"https://hui46226021.github.io/tags/DecorView/"},{"name":"源码","slug":"源码","permalink":"https://hui46226021.github.io/tags/源码/"},{"name":"setContentView","slug":"setContentView","permalink":"https://hui46226021.github.io/tags/setContentView/"}]},{"title":"Android-PickerView 时间控件，选择权","slug":"Android-PickerView","date":"2016-08-17T14:37:23.000Z","updated":"2017-09-29T14:59:16.595Z","comments":true,"path":"2016/08/17/Android-PickerView/","link":"","permalink":"https://hui46226021.github.io/2016/08/17/Android-PickerView/","excerpt":"在 saiwu-bigkoo 大神以上修改 便于自己使用","text":"在 saiwu-bigkoo 大神以上修改 便于自己使用 PickerView (2.x系列)精仿iOS的PickerView控件，有时间选择和选项选择并支持一二三级联动效果——TimePickerView 时间选择器，支持年月日时分，年月日，年月，时分等格式——OptionsPickerView 选项选择器，支持一，二，三级选项选择，并且可以设置是否联动 2.x是全新的3D效果，比1.x版本更加贴近iOS的效果，从外观细节上也得到了改善。api兼容1.x版本，只需要把依赖的版本号升级即可，几乎不用修改代码即可完成升级。 ####使用maven 依赖123456&lt;dependency&gt; &lt;groupId&gt;com.sh.zsh.code&lt;/groupId&gt; &lt;artifactId&gt;pickerview&lt;/artifactId&gt; &lt;version&gt;2.1.2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt;&lt;/dependency&gt; ####使用gradle 依赖:12 compile 'com.sh.zsh.code:pickerview:2.1.2'//这个是支持农历的分支 compile 'com.bigkoo:pickerview:lunar.1.0' Demo 图片 demo代码请看戳这里 更新说明v2.1.2 增加设置选中item方法。 v2.1.1 修复dismiss时候点击背景会重复dismiss动画问题。 v2.1.0 去掉反射获取字符串，改为通过继承IPickerViewData。 解决多个PickerView同时存在时取消不了弹窗问题。 v2.0.9 解决属性和其他第三方库冲突问题。 v2.0.8 修复＃41 未选中项有错乱数据问题。 加入pickerview_customTextSize 和 pickerview_textsize 到 xml 中 来控制自定义文字大小 v2.0.7 修复设置初始化position ，第三级数据不对的BUG。 v2.0.6 修复不循环模式下点击超出范围问题，修复后点击空白的地方，只能滚到最顶或最底，不会滚出数据范围。 v2.0.5 修复不循环模式下底部超出范围问题 v2.0.4 修复不循环模式下顶部超出范围问题 wheel view文字颜色通过xml配置 v2.0.3 修复时间选择的时候部分数字选不到直接跳到下一个数字的问题 v2.0.2 修复不循环模式下点击空白item处出现数组越界问题 修复循环模式下只有一条数据的时候只显示三条而不是填充满高度问题 v2.0.1 去掉popupWindow，改用View，类名也对应修改为TimePickerView和 OptionsPickerView 加入遮罩效果 v2.0.0 不需修改任何代码就可以兼容1.x 外观大整改 支持反射获取getPickerViewText()来获取要展示数据，以前只能传String的对象，现在可以传任意对象只要有getPickerViewText()函数即可显示对应的字符串，如果没有getPickerViewText()函数则使用对象toString作为显示 加入setTitle -－－－－－－－－－－－－－－－－－－－－华丽丽的分割线－－－－－－－－－－－－－－－－－－－－－－－－－－ PickerView1.x (我已经把1.0.3版本分到v1.x的分支去了，停止维护1.x的分支)####使用gradle 依赖:1compile 'com.bigkoo:pickerview:1.0.3' Demo 图片（招行信用卡的“掌上生活”里面条件选择器他们用的就是我这个库，大家可以当实际项目参考） Thanks WheelView androidWheelView 源码地址:https://github.com/hui46226021/Android-PickerView","categories":[{"name":"Android","slug":"Android","permalink":"https://hui46226021.github.io/categories/Android/"},{"name":"JAVA","slug":"Android/JAVA","permalink":"https://hui46226021.github.io/categories/Android/JAVA/"}],"tags":[{"name":"移动开发","slug":"移动开发","permalink":"https://hui46226021.github.io/tags/移动开发/"},{"name":"原创","slug":"原创","permalink":"https://hui46226021.github.io/tags/原创/"},{"name":"自定义view","slug":"自定义view","permalink":"https://hui46226021.github.io/tags/自定义view/"}]},{"title":"Android 通过gardle限制引入so库 版本","slug":"Android 通过gardle限制引入so库 版本","date":"2016-07-20T15:37:23.000Z","updated":"2017-09-29T14:59:14.728Z","comments":true,"path":"2016/07/20/Android 通过gardle限制引入so库 版本/","link":"","permalink":"https://hui46226021.github.io/2016/07/20/Android 通过gardle限制引入so库 版本/","excerpt":"摘要:android 的cpu不同 需要引入的so版本也不尽相同，有时候 会出现由于so库加载不到 崩溃的情况","text":"摘要:android 的cpu不同 需要引入的so版本也不尽相同，有时候 会出现由于so库加载不到 崩溃的情况 今天 集成百度地图api的时候 同时项目里 还有 之前实现的一个 模糊图像的功能，由于 百度地图 提供了 armeabi 的so库，而模糊功能的 依赖 compile ‘net.qiujuer.genius:blur:2.0.0-beta4’实现的，这个库里面 包含了 armeabi armeabi-v7a arm64-v8a 每个里面 有libgenius_blur.so 这就导致 在部分 arm64的 手机上 百度地图的相关功能 会加载不到 so库,导致程序崩溃 最后找到解决方案 在app 的 build.gradle 下的defaultConfig 添加12345ndk&#123; moduleName \"libgenius_blur\" ldLibs \"log\" abiFilters \"armeabi\"&#125; 完美运行 谢谢","categories":[{"name":"Android","slug":"Android","permalink":"https://hui46226021.github.io/categories/Android/"},{"name":"JAVA","slug":"Android/JAVA","permalink":"https://hui46226021.github.io/categories/Android/JAVA/"},{"name":"gradle","slug":"Android/JAVA/gradle","permalink":"https://hui46226021.github.io/categories/Android/JAVA/gradle/"},{"name":"so","slug":"Android/JAVA/gradle/so","permalink":"https://hui46226021.github.io/categories/Android/JAVA/gradle/so/"}],"tags":[{"name":"移动开发","slug":"移动开发","permalink":"https://hui46226021.github.io/tags/移动开发/"},{"name":"原创","slug":"原创","permalink":"https://hui46226021.github.io/tags/原创/"},{"name":"so库","slug":"so库","permalink":"https://hui46226021.github.io/tags/so库/"}]},{"title":"Android JSON解析工具ShJsonUtils","slug":"JSON解析","date":"2016-07-20T13:37:23.000Z","updated":"2017-09-29T14:59:44.133Z","comments":true,"path":"2016/07/20/JSON解析/","link":"","permalink":"https://hui46226021.github.io/2016/07/20/JSON解析/","excerpt":"摘要:封装了一个 json解析的库","text":"摘要:封装了一个 json解析的库 ShJsonUtilsandroid json解析框架Download the latest JAR or grab via Maven:123456&lt;dependency&gt; &lt;groupId&gt;com.sh.zsh.code&lt;/groupId&gt; &lt;artifactId&gt;shjson&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt;&lt;/dependency&gt; or Gradle:1compile 'com.sh.zsh.code:shjson:1.2.3' #使用方法123456789JSONUtil jsonUtil = new JSONUtil(jsonStr);//二维数组List&lt;People&gt; peoples =jsonUtil.getList(People.class,\"people\",Look.class);//三维数组List&lt;People&gt; peoples =jsonUtil.getList(People.class,\"people\",Look.class,En.class);List&lt;People&gt; peoples2 =jsonUtil.getList(People.class,\"data.people\");String animal = jsonUtil.getObject(String.class,\"data.animal\");Look look = jsonUtil.getObject(Look.class,\"data.look\"); 创建 JSONUtil 对象，传入json字符串 通过getObject方法 获取 实体对象 ，层级用.隔开 通过getList方法 获取 数组对象 ，层级用.隔开 源码地址：https://github.com/hui46226021/ShJsonUtils/edit/master/README.md","categories":[{"name":"Android","slug":"Android","permalink":"https://hui46226021.github.io/categories/Android/"},{"name":"JAVA","slug":"Android/JAVA","permalink":"https://hui46226021.github.io/categories/Android/JAVA/"},{"name":"JSON","slug":"Android/JAVA/JSON","permalink":"https://hui46226021.github.io/categories/Android/JAVA/JSON/"}],"tags":[{"name":"移动开发","slug":"移动开发","permalink":"https://hui46226021.github.io/tags/移动开发/"},{"name":"原创","slug":"原创","permalink":"https://hui46226021.github.io/tags/原创/"},{"name":"JSON解析","slug":"JSON解析","permalink":"https://hui46226021.github.io/tags/JSON解析/"}]},{"title":"Android JSON解析工具ShJsonUtils","slug":"Android 仿微信 相册多图选择器 - 副本","date":"2016-07-18T13:37:23.000Z","updated":"2017-09-29T14:59:38.319Z","comments":true,"path":"2016/07/18/Android 仿微信 相册多图选择器 - 副本/","link":"","permalink":"https://hui46226021.github.io/2016/07/18/Android 仿微信 相册多图选择器 - 副本/","excerpt":"摘要:封装了一个 json解析的库","text":"摘要:封装了一个 json解析的库 ShJsonUtilsandroid json解析框架Download the latest JAR or grab via Maven:123456&lt;dependency&gt; &lt;groupId&gt;com.sh.zsh.code&lt;/groupId&gt; &lt;artifactId&gt;shjson&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt;&lt;/dependency&gt; or Gradle:1compile 'com.sh.zsh.code:shjson:1.2.3' #使用方法123456789JSONUtil jsonUtil = new JSONUtil(jsonStr);//二维数组List&lt;People&gt; peoples =jsonUtil.getList(People.class,\"people\",Look.class);//三维数组List&lt;People&gt; peoples =jsonUtil.getList(People.class,\"people\",Look.class,En.class);List&lt;People&gt; peoples2 =jsonUtil.getList(People.class,\"data.people\");String animal = jsonUtil.getObject(String.class,\"data.animal\");Look look = jsonUtil.getObject(Look.class,\"data.look\"); 创建 JSONUtil 对象，传入json字符串 通过getObject方法 获取 实体对象 ，层级用.隔开 通过getList方法 获取 数组对象 ，层级用.隔开 源码地址：https://github.com/hui46226021/ShJsonUtils/edit/master/README.md","categories":[{"name":"Android","slug":"Android","permalink":"https://hui46226021.github.io/categories/Android/"},{"name":"JAVA","slug":"Android/JAVA","permalink":"https://hui46226021.github.io/categories/Android/JAVA/"},{"name":"JSON","slug":"Android/JAVA/JSON","permalink":"https://hui46226021.github.io/categories/Android/JAVA/JSON/"}],"tags":[{"name":"移动开发","slug":"移动开发","permalink":"https://hui46226021.github.io/tags/移动开发/"},{"name":"原创","slug":"原创","permalink":"https://hui46226021.github.io/tags/原创/"},{"name":"JSON解析","slug":"JSON解析","permalink":"https://hui46226021.github.io/tags/JSON解析/"}]},{"title":"Android 仿微信 相册多图选择器","slug":"Android 仿微信 相册多图选择器","date":"2016-07-01T14:37:23.000Z","updated":"2017-03-17T23:06:27.668Z","comments":true,"path":"2016/07/01/Android 仿微信 相册多图选择器/","link":"","permalink":"https://hui46226021.github.io/2016/07/01/Android 仿微信 相册多图选择器/","excerpt":"摘要:公司需要多图选择并上传，自己实现了一个并 封装成 Library，方便以后使用","text":"摘要:公司需要多图选择并上传，自己实现了一个并 封装成 Library，方便以后使用 下载方式123456&lt;dependency&gt; &lt;groupId&gt;com.sh.zsh.code&lt;/groupId&gt; &lt;artifactId&gt;shphotoselectorlibrary&lt;/artifactId&gt; &lt;version&gt;2.0.9&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt;&lt;/dependency&gt; or Gradle:1compile 'com.sh.zsh.code:shphotoselectorlibrary:2.0.9' 该项目依赖 Glide:3.7.0 如果有冲突 可以 修改主项目里的依赖 或者 直接导入Library 跳转到 图片选择器页面123456789101112public static final int IMGSACTIVITY_REQUEST = 10001; public void chise(View v) &#123; Intent intent = new Intent(); //可选择图片的最大数量 intent.putExtra(PhotoActivity.IMAGE_COUNT,9); //顶部Toolbar栏背景颜色 intent.putExtra(PhotoActivity.BAR_COLORS,R.color.colorPrimary); intent.setClass(this,PhotoActivity.class); startActivityForResult(intent,IMGSACTIVITY_REQUEST); &#125; 在Activity的回调里获取到 所有选择的图片地址123456789101112131415@Override protected void onActivityResult(int requestCode, int resultCode, Intent data) &#123; if (requestCode == IMGSACTIVITY_REQUEST &amp;&amp; resultCode == RESULT_OK) &#123; Bundle bundle = data.getExtras(); if (bundle != null) &#123; if (bundle.getStringArrayList(\"files\") != null) &#123; listfile = bundle.getStringArrayList(\"files\"); listView.setVisibility(View.VISIBLE); ArrayAdapter&lt;String&gt; arryAdapter = new ArrayAdapter&lt;String&gt;(this, android.R.layout.simple_list_item_1, listfile); listView.setAdapter(arryAdapter); &#125; &#125; &#125; &#125; 效果 源码地址：https://github.com/hui46226021/ShPhotoSelector","categories":[{"name":"Android","slug":"Android","permalink":"https://hui46226021.github.io/categories/Android/"},{"name":"JAVA","slug":"Android/JAVA","permalink":"https://hui46226021.github.io/categories/Android/JAVA/"}],"tags":[{"name":"相册","slug":"相册","permalink":"https://hui46226021.github.io/tags/相册/"},{"name":"微信","slug":"微信","permalink":"https://hui46226021.github.io/tags/微信/"},{"name":"移动开发","slug":"移动开发","permalink":"https://hui46226021.github.io/tags/移动开发/"},{"name":"原创","slug":"原创","permalink":"https://hui46226021.github.io/tags/原创/"},{"name":"多图选择","slug":"多图选择","permalink":"https://hui46226021.github.io/tags/多图选择/"}]},{"title":"ShVideoPlay android视频播放器","slug":"ShVideoPlay android视频播放器","date":"2016-05-18T14:37:23.000Z","updated":"2017-09-29T14:59:41.499Z","comments":true,"path":"2016/05/18/ShVideoPlay android视频播放器/","link":"","permalink":"https://hui46226021.github.io/2016/05/18/ShVideoPlay android视频播放器/","excerpt":"摘要：Android 视频播放器","text":"摘要：Android 视频播放器 ShVideoPlayandroid 视频播放封装Download the latest JAR or grab via Maven:123456&lt;dependency&gt; &lt;groupId&gt;com.sh.zsh.code&lt;/groupId&gt; &lt;artifactId&gt;shvideoplayer&lt;/artifactId&gt; &lt;version&gt;1.0.2&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt;&lt;/dependency&gt; or Gradle:1compile 'com.sh.zsh.code:shvideoplayer:1.0.2' 源码地址:https://github.com/hui46226021/ShVideoPlay","categories":[{"name":"Android","slug":"Android","permalink":"https://hui46226021.github.io/categories/Android/"},{"name":"JAVA","slug":"Android/JAVA","permalink":"https://hui46226021.github.io/categories/Android/JAVA/"},{"name":"FFmpeg","slug":"Android/JAVA/FFmpeg","permalink":"https://hui46226021.github.io/categories/Android/JAVA/FFmpeg/"}],"tags":[{"name":"移动开发","slug":"移动开发","permalink":"https://hui46226021.github.io/tags/移动开发/"},{"name":"原创","slug":"原创","permalink":"https://hui46226021.github.io/tags/原创/"},{"name":"视频播放","slug":"视频播放","permalink":"https://hui46226021.github.io/tags/视频播放/"}]},{"title":"Android JSON解析工具ShJsonUtils","slug":"Android JSON解析工具ShJsonUtils","date":"2016-03-18T13:37:23.000Z","updated":"2017-09-29T14:59:36.005Z","comments":true,"path":"2016/03/18/Android JSON解析工具ShJsonUtils/","link":"","permalink":"https://hui46226021.github.io/2016/03/18/Android JSON解析工具ShJsonUtils/","excerpt":"摘要:公司需要多图选择并上传，自己实现了一个并 封装成 Library，方便以后使用","text":"摘要:公司需要多图选择并上传，自己实现了一个并 封装成 Library，方便以后使用 ShJsonUtilsandroid json解析框架Download the latest JAR or grab via Maven:123456&lt;dependency&gt; &lt;groupId&gt;com.sh.zsh.code&lt;/groupId&gt; &lt;artifactId&gt;shjson&lt;/artifactId&gt; &lt;version&gt;1.2.3&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt;&lt;/dependency&gt; or Gradle:1compile 'com.sh.zsh.code:shjson:1.2.3' #使用方法123456789JSONUtil jsonUtil = new JSONUtil(jsonStr);//二维数组List&lt;People&gt; peoples =jsonUtil.getList(People.class,\"people\",Look.class);//三维数组List&lt;People&gt; peoples =jsonUtil.getList(People.class,\"people\",Look.class,En.class);List&lt;People&gt; peoples2 =jsonUtil.getList(People.class,\"data.people\");String animal = jsonUtil.getObject(String.class,\"data.animal\");Look look = jsonUtil.getObject(Look.class,\"data.look\"); 创建 JSONUtil 对象，传入json字符串 通过getObject方法 获取 实体对象 ，层级用.隔开 通过getList方法 获取 数组对象 ，层级用.隔开 源码地址：https://github.com/hui46226021/ShJsonUtils/edit/master/README.md","categories":[{"name":"Android","slug":"Android","permalink":"https://hui46226021.github.io/categories/Android/"},{"name":"JAVA","slug":"Android/JAVA","permalink":"https://hui46226021.github.io/categories/Android/JAVA/"},{"name":"JSON","slug":"Android/JAVA/JSON","permalink":"https://hui46226021.github.io/categories/Android/JAVA/JSON/"}],"tags":[{"name":"移动开发","slug":"移动开发","permalink":"https://hui46226021.github.io/tags/移动开发/"},{"name":"原创","slug":"原创","permalink":"https://hui46226021.github.io/tags/原创/"},{"name":"JSON解析","slug":"JSON解析","permalink":"https://hui46226021.github.io/tags/JSON解析/"}]},{"title":"andfix 增量升级更新 热补丁修复","slug":"andfix","date":"2016-03-17T14:37:23.000Z","updated":"2017-03-19T03:15:34.747Z","comments":true,"path":"2016/03/17/andfix/","link":"","permalink":"https://hui46226021.github.io/2016/03/17/andfix/","excerpt":"摘要:最近想着Android有没有什么热补丁更新技术的实现，于是上网搜索。接着实现了这一功能后，记录一下，免得自己忘了，可能文章会有出错的地方，望指出，呵呵","text":"摘要:最近想着Android有没有什么热补丁更新技术的实现，于是上网搜索。接着实现了这一功能后，记录一下，免得自己忘了，可能文章会有出错的地方，望指出，呵呵 搜索发现有这3种方式可以实现（至于其他的方式，暂不清楚）1.dexposed github https://github.com/alibaba/dexposed 2.andfix github https://github.com/alibaba/AndFix 3.bsdiff http://blog.csdn.net/lazyer_dog/article/details/47173013 dexposed和andfix是alibaba的开源项目，都是apk增量更新的实现框架，目前dexposed的兼容性较差，只有2.3，4.0~4.4兼容，其他Android版本不兼容或未测试，详细可以去dexposed的github项目主页查看，而andfix则兼容2.3~6.0，所以就拿这个项目来实现增量更新吧。至于bsdiff，只是阅览了一下，还没研究过。 首先 Git clone github https://github.com/alibaba/AndFix，将andfix项目下载下来，Android studio可以在build.gradle里导入andfix， compile ‘com.alipay.euler:andfix:0.3.1@aar’但是我是使用module的方式添加andfix，这样可以直接查看编辑源码，而且直接gradle导入的话还有个问题，后面再说。 andfix项目里有sample，导入也行，自己新建也行，我是自己新建项目，接着导入andfix作为module，demo里就两个类，mainactivity和myapplication andfix里有些文件夹不用导入的，例如tools，doc等，记得新建jniLibs文件夹，libs里的so文件移到jniLibs里。~~~javapublic class MainApplication extends Application { private static final String TAG = “euler”; private static final String APATCH_PATH = &quot;/out.apatch&quot;; private static final String DIR = &quot;apatch&quot;;//补丁文件夹 /** * patch manager */ private PatchManager mPatchManager; @Override public void onCreate() { super.onCreate(); // initialize mPatchManager = new PatchManager(this); mPatchManager.init(&quot;1.0&quot;); Log.d(TAG, &quot;inited.&quot;); // load patch mPatchManager.loadPatch(); // Log.d(TAG, “apatch loaded.”); // add patch at runtime try { // .apatch file path String patchFileString = Environment.getExternalStorageDirectory() .getAbsolutePath() + APATCH_PATH; mPatchManager.addPatch(patchFileString); Log.d(TAG, &quot;apatch:&quot; + patchFileString + &quot; added.&quot;); //这里我加了个方法，复制加载补丁成功后，删除sdcard的补丁，避免每次进入程序都重新加载一次 File f = new File(this.getFilesDir(), DIR + APATCH_PATH); if (f.exists()) { boolean result = new File(patchFileString).delete(); if (!result) Log.e(TAG, patchFileString + &quot; delete fail&quot;); } } catch (IOException e) { Log.e(TAG, &quot;&quot;, e); } } public class MainActivity extends Activity { private static final String TAG = “euler”; @Override public void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); toast(); } @Override protected void onDestroy() { super.onDestroy(); android.os.Process.killProcess(android.os.Process.myPid()); } //旧方法，1.apk private void toast() { Toast.makeText(this, &quot;old&quot;, Toast.LENGTH_SHORT).show(); }} 刚刚说的直接在gradle里导入andfix会有个问题，是在原来的项目中，加载一次补丁后，out.apatch文件会copy到getFilesDir目录下的/apatch文件夹中，在下次补丁更新时，会检测补丁是否已经添加在apatch文件夹下，已存在就不会复制加载sdcard的out.apatch。 原来的addpath方法 public void addPatch(String path) throws IOException { File src = new File(path); File dest = new File(mPatchDir, src.getName()); if(!src.exists()){ throw new FileNotFoundException(path); } if (dest.exists()) { Log.d(TAG, “patch [“ + path + “] has be loaded.”); return; } FileUtil.copyFile(src, dest);// copy to patch’s directory Patch patch = addPatch(dest); if (patch != null) { loadPatch(patch); }} 修改后，判断apatch下的out.apatch存在即删除掉，重新复制加载sdcard下的out.apatch public void addPatch(String path) throws IOException { File src = new File(path); File dest = new File(mPatchDir, src.getName()); if (!src.exists()) { throw new FileNotFoundException(path); } if (dest.exists()) { Log.d(TAG, “patch [“ + src.getName() + “] has be loaded.”); boolean deleteResult = dest.delete(); if (deleteResult) Log.e(TAG, “patch [“ + dest.getPath() + “] has be delete.”); else { Log.e(TAG, “patch [“ + dest.getPath() + “] delete error”); return; } } FileUtil.copyFile(src, dest);// copy to patch’s directory Patch patch = addPatch(dest); if (patch != null) { loadPatch(patch); }} 还有源码混淆 -optimizationpasses 5 # 指定代码的压缩级别-dontusemixedcaseclassnames # 是否使用大小写混合-dontskipnonpubliclibraryclasses # 是否混淆第三方jar-dontpreverify # 混淆时是否做预校验-verbose # 混淆时是否记录日志-optimizations !code/simplification/arithmetic,!field/,!class/merging/ # 混淆时所采用的算法 重要，別忘了這些，不混淆andfix包，不混淆native方法-dontwarn android.annotation-dontwarn com.alipay.euler.-keep class com.alipay.euler. {;}-keep class extends java.lang.annotation.Annotation-keepclasseswithmembernames class * { native ;} 接着打包1.apk， 然后修改mainactivity的toast()，打包2.apk //修改Toast內容，2.apkprivate void toast() { Toast.makeText(this, “new”, Toast.LENGTH_SHORT).show();} cmd输入命令，具体参数看usage 如无错误，编译后会生成一个apatch文件，改名成out.apatch 安装打开1.apk 关闭app，将out.apatch放sdcard根目录后，重新打开app，toast方法改变了 ps： 这里只是简单的测试了一下，没有复杂的功能，而且andfix不支持布局资源等的修改。 github主页的issues反应说Android4.0.4，以及5.0以上版本会crash，不过我使用了两个虚拟机，genymotion的4.2和5.0虚拟机，没有错误，其他请自测 使用了apk加固时（360加固，百度加固等等），发现在加固前要先apkpatch制作补丁，不能使用加固后的apk制作，否则补丁无法使用，但是在加固前制作的补丁可以很容易的被反编译出源码 demo下载 http://download.csdn.net/detail/ityangjun/9177377","categories":[{"name":"Android","slug":"Android","permalink":"https://hui46226021.github.io/categories/Android/"},{"name":"JAVA","slug":"Android/JAVA","permalink":"https://hui46226021.github.io/categories/Android/JAVA/"}],"tags":[{"name":"移动开发","slug":"移动开发","permalink":"https://hui46226021.github.io/tags/移动开发/"},{"name":"转载","slug":"转载","permalink":"https://hui46226021.github.io/tags/转载/"},{"name":"增量升级","slug":"增量升级","permalink":"https://hui46226021.github.io/tags/增量升级/"},{"name":"热补丁修复","slug":"热补丁修复","permalink":"https://hui46226021.github.io/tags/热补丁修复/"},{"name":"andfix","slug":"andfix","permalink":"https://hui46226021.github.io/tags/andfix/"}]},{"title":"Android动画 详解（一 补间动画）","slug":"Android动画 详解（一 补间动画）","date":"2015-12-23T11:42:33.000Z","updated":"2017-03-19T04:38:12.300Z","comments":true,"path":"2015/12/23/Android动画 详解（一 补间动画）/","link":"","permalink":"https://hui46226021.github.io/2015/12/23/Android动画 详解（一 补间动画）/","excerpt":"打算整理下 android动画方面的知识，嗯 开始","text":"打算整理下 android动画方面的知识，嗯 开始 一.android补间动画 分为四大类alpha（透明度渐变）、scale（尺寸渐变）、translate（位置移动）、rotate（旋转） 通过JAVA类来表示 AlphaAnimation ScaleAnimation TranslateAnimation RotateAnimation 二.可以通过 XML文件 或者JAVA代码的方式来实现动画1.动过XML来实现动画在res目录中新建anim文件夹在anim目录中新建一个anim.xml1234567&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;alpha/&gt; &lt;scale/&gt; &lt;translate/&gt; &lt;rotate/&gt; &lt;/set&gt; XML动画详细解析 alpha说明: 0.0表示完全透明 1.0表示完全不透明 时间以毫秒为单位 123456&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\" &gt; &lt;alpha android:fromAlpha=\"0.1\" &lt;!--动画起始时透明度 --&gt; android:toAlpha=\"1.0\" &lt;!--动画结束时透明度 --&gt; android:duration=\"3000\" /&gt; &lt;!--动画持续时间--&gt; &lt;/set&gt; Scale说明: 插入器 下一篇详细说 pivotX pivotY 确定了 放大缩小的中心 上面4个属性 定义了开始 和结束的比例 1放大 12345678910111213141516171819202122&lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;scale android:interpolator= \"@android:anim/accelerate_decelerate_interpolator\" &lt;!--interpolator 指定一个动画的插入器 --&gt; android:fromXScale=\"0.0\" &lt;!--起始时 X坐标上的伸缩尺寸 --&gt; android:toXScale=\"1.4\" &lt;!--结束时 X坐标上的伸缩尺寸 --&gt; android:fromYScale=\"0.0\" &lt;!--起始时Y坐标上的伸缩尺寸 --&gt; android:toYScale=\"1.4\" &lt;!--结束时Y坐标上的伸缩尺寸 --&gt; android:pivotX=\"50%\" &lt;!--属性为动画相对于物件的X坐标的开始位置 --&gt; android:pivotY=\"50%\" &lt;!--属性为动画相对于物件的Y坐标的开始位置 --&gt; android:fillAfter=\"false\" &lt;!--当设置为true ，该动画转化在动画结束后被应用 --&gt; android:duration=\"700\" &lt;!--时间 --&gt; /&gt; &lt;/set&gt; Translate 说明：没啥说的了12345678910111213141516 &lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;translate android:fromXDelta=\"30\" &lt;!--始时 X坐标上的位置 --&gt; android:toXDelta=\"-80\" &lt;!--结束时 X坐标上的位置 --&gt; android:fromYDelta=\"30\" &lt;!--起始时 Y坐标上的位置 --&gt; android:toYDelta=\"300\" &lt;!--结束时 Y坐标上的位置 --&gt; android:duration=\"2000\" &lt;!--时间--&gt; /&gt; &lt;/set&gt; Rotate 说明：其实也没啥好说的了12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;set xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;rotate android:interpolator=\"@android:anim/accelerate_decelerate_interpolator\" &lt;!--动画的插入器 --&gt; android:fromDegrees=\"0\" &lt;!--动画起始时物件的角度 --&gt; android:toDegrees=\"+350\" &lt;!--画结束时物件旋转的角度 可以大于360度 --&gt; android:pivotX=\"50%\" &lt;!--X坐标的开始位置 --&gt; android:pivotY=\"50%\" &lt;!--Y坐标的开始位置 --&gt; android:duration=\"3000\" /&gt; &lt;/set&gt; 在JAVA 代码中调用XML12 Animation myAnimation= AnimationUtils.loadAnimation(this, R.anim.my_action); //使用AnimationUtils类的静态方法loadAnimation()来加载XML中的动画XML文件 2 试用JAVA 代码 来创建动画 说明 具体参数含义 可对照上面的XML1234567891011121314151617181920212223242526272829303132333435//在代码中定义 动画实例对象private Animation myAnimation_Alpha;private Animation myAnimation_Scale;private Animation myAnimation_Translate;private Animation myAnimation_Rotate;//根据各自的构造方法来初始化一个实例对象myAnimation_Alpha = new AlphaAnimation(0.1f, 1.0f);myAnimation_Scale = new ScaleAnimation(0.0f, 1.4f, 0.0f, 1.4f,Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF, 0.5f);myAnimation_Translate = new TranslateAnimation(30.0f, -80.0f, 30.0f, 300.0f);myAnimation_Rotate = new RotateAnimation(0.0f, +350.0f,Animation.RELATIVE_TO_SELF,0.5f,Animation.RELATIVE_TO_SELF, 0.5f);设置动画监听，注意 当控件移动后 其点击事件 还在原来的未知 需要调用view.layout(x,x,x,x);方法修改下 控件的未知animation.setAnimationListener(new Animation.AnimationListener() &#123; @Override public void onAnimationStart(Animation animation) &#123; &#125; @Override public void onAnimationRepeat(Animation animation) &#123; &#125; @Override public void onAnimationEnd(Animation animation) &#123; &#125; &#125;);最后 就查给控件添加上 创建好的动画 并启动了view.startAnimation(animation); 谢谢","categories":[{"name":"Android","slug":"Android","permalink":"https://hui46226021.github.io/categories/Android/"},{"name":"JAVA","slug":"Android/JAVA","permalink":"https://hui46226021.github.io/categories/Android/JAVA/"}],"tags":[{"name":"原创","slug":"原创","permalink":"https://hui46226021.github.io/tags/原创/"},{"name":"动画","slug":"动画","permalink":"https://hui46226021.github.io/tags/动画/"}]},{"title":"整理 iOS 9 适配中出现的坑","slug":"整理 iOS 9 适配中出现的坑","date":"2015-12-18T08:17:33.000Z","updated":"2017-03-19T05:27:01.979Z","comments":true,"path":"2015/12/18/整理 iOS 9 适配中出现的坑/","link":"","permalink":"https://hui46226021.github.io/2015/12/18/整理 iOS 9 适配中出现的坑/","excerpt":"摘要: 整理 iOS 9 适配中出现的坑","text":"摘要: 整理 iOS 9 适配中出现的坑 http://www.cocoachina.com/ios/20151012/13715.html#0-tsina-1-57205-397232819ff9a47a7b7e80a40613cfe1","categories":[{"name":"IOS","slug":"IOS","permalink":"https://hui46226021.github.io/categories/IOS/"},{"name":"移动开发","slug":"IOS/移动开发","permalink":"https://hui46226021.github.io/categories/IOS/移动开发/"}],"tags":[{"name":"session共享","slug":"session共享","permalink":"https://hui46226021.github.io/tags/session共享/"},{"name":"分布式","slug":"分布式","permalink":"https://hui46226021.github.io/tags/分布式/"},{"name":"IOS 9","slug":"IOS-9","permalink":"https://hui46226021.github.io/tags/IOS-9/"}]},{"title":"单个ViewControl适配不同ios版本xib文件实现","slug":"单个ViewControl适配不同ios版本xib文件实现","date":"2015-12-07T08:17:33.000Z","updated":"2017-03-19T05:29:45.643Z","comments":true,"path":"2015/12/07/单个ViewControl适配不同ios版本xib文件实现/","link":"","permalink":"https://hui46226021.github.io/2015/12/07/单个ViewControl适配不同ios版本xib文件实现/","excerpt":"摘要: IOS 适配不同的界面xib","text":"摘要: IOS 适配不同的界面xib 方法如下： 在跳转本界面时，在代码里面实现如下： 1234567891011float systemVersion = [[[UIDevice currentDevice] systemVersion] floatValue];if (systemVersion &gt;= 7.0)&#123; AboutUSView *aboutUSView= [[[AboutUSView alloc] initWithNibName:@\"AboutUSView1\" bundle:nil] autorelease]; [self.navigationController pushViewController:aboutUSView animated:TRUE];&#125;else&#123; AboutUSView *aboutUSView= [[[AboutUSView alloc] initWithNibName:@\"AboutUSView\" bundle:nil] autorelease]; [self.navigationController pushViewController:aboutUSView animated:TRUE];&#125;","categories":[{"name":"IOS","slug":"IOS","permalink":"https://hui46226021.github.io/categories/IOS/"},{"name":"移动开发","slug":"IOS/移动开发","permalink":"https://hui46226021.github.io/categories/IOS/移动开发/"}],"tags":[{"name":"IOS","slug":"IOS","permalink":"https://hui46226021.github.io/tags/IOS/"},{"name":"xib","slug":"xib","permalink":"https://hui46226021.github.io/tags/xib/"},{"name":"屏幕适配","slug":"屏幕适配","permalink":"https://hui46226021.github.io/tags/屏幕适配/"}]},{"title":"一个Demo学会用Android兼容包新控件","slug":"一个Demo学会用Android兼容包新控件","date":"2015-11-23T11:42:23.000Z","updated":"2017-03-19T04:07:24.811Z","comments":true,"path":"2015/11/23/一个Demo学会用Android兼容包新控件/","link":"","permalink":"https://hui46226021.github.io/2015/11/23/一个Demo学会用Android兼容包新控件/","excerpt":"摘要:伟大的Google为Android推出了一系列的兼容包，最新的就是Design Support Library了，这里我们结合v7和v4中的几个控件，来主要学习Design Support Library中的几个新控件！一个Demo学会用它们！","text":"摘要:伟大的Google为Android推出了一系列的兼容包，最新的就是Design Support Library了，这里我们结合v7和v4中的几个控件，来主要学习Design Support Library中的几个新控件！一个Demo学会用它们！ 效果动图GIF： 学习内容通过本实例可以学习到以下内容： Drawerlayout和NavigationView实现优雅的Google范儿侧边栏； 新控件CoordinatorLayout、AppBarLayout、Toolbar、FloatingActionButton的用法，以及Toolbar的渐变隐藏动画效果； 官方Tabs组件TabLayout和ViewPager结合实现主界面内容区域； SwipeRefreshLayout和RecyclerView结合实现下拉刷新，以及RecyclerView的数据适配器RecyclerView.Adapter的用法，还有RecyclerView中item的点击事件的实现方法； 卡片式CardView的用法； 类似Toast的新控件Snackbar的用法。布局文件 学习Android解释再多代码都没有用，因为解释过了还是不会用。因此，我们这里将布局文件XML源码贴出来供学习，放心，所有知识点都已经注释在源码中。 styles.xml源码12345678910111213141516&lt;resources&gt; &lt;style name=\"AppTheme\" parent=\"MyThemeBlue\"&gt;&lt;/style&gt; &lt;!-- 蓝色为主色调 --&gt; &lt;style name=\"MyThemeBlue\" parent=\"Theme.AppCompat.Light.NoActionBar\"&gt; &lt;!--选中状态icon的颜色和字体颜色--&gt; &lt;item name=\"colorPrimary\"&gt;@color/main_blue_light&lt;/item&gt; &lt;item name=\"colorPrimaryDark\"&gt;@color/main_blue_dark&lt;/item&gt; &lt;item name=\"colorAccent\"&gt;@color/main_blue_light&lt;/item&gt; &lt;!--正常状态下字体颜色和icon颜色--&gt; &lt;item name=\"android:textColorPrimary\"&gt;@color/main_white&lt;/item&gt; &lt;/style&gt;&lt;/resources&gt; colorPrimary、colorPrimaryDark、colorAccent、textColorPrimary的含义，请看博文 《Android L+ Theme 与 Toolbar 实例》 。 主布局activity_my.xml源码（重点）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;android.support.v4.widget.DrawerLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:id=\"@+id/id_drawerlayout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"&gt; &lt;!-- 第一个位置 --&gt; &lt;!-- 你的主界面内容，必须放置在Drawerlayout中的第一个位置 根据自己的需要来放置控件， 例如：LinearLayout布局或者RelativeLayout布局； 也可以是单个控件， 如 TextView等 --&gt; &lt;include layout=\"@layout/content_main\" /&gt; &lt;!-- 第二个位置 --&gt; &lt;!-- 用来放Drawerlayout中的内容， 这里使用NavigationView来实现类似Google pLay中的侧滑栏效果， 必须在build.gradle中添加compile 'com.android.support:design:22.2.0'； 另外，如果不需要NavigationView效果， 也可以放置一个普通布局文件就是一个普通的侧滑栏了。 --&gt; &lt;!-- 注意： 如果使用NavigationView（其他控件也是一样）的特有属性，需要加上命名空间： xmlns:app=\"http://schemas.android.com/apk/res-auto\"； 另外，一定要添加android:layout_gravity=\"left\"属性。 --&gt; &lt;!-- 属性解析： app:headerLayout： NavigationView中头部的head部分的布局，是自己实现的； app:menu： 指定Nav中的Menu布局，就是自己写Menu中的按钮，要放在res/menu/文件夹下； app:itemTextColor： 用来设置Nav中，menu item的颜色选择器。 还有一些属性： 和itemTextColor用法一样，指定一个颜色选择器，实现不同的颜色效果。 app:itemIconTint: app:itemBackground: --&gt; &lt;android.support.design.widget.NavigationView android:id=\"@+id/id_navigationview\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:itemTextColor=\"@color/selector_nav_menu_textcolor\" android:layout_gravity=\"left\" /&gt;&lt;/android.support.v4.widget.DrawerLayout&gt; content_main.xml源码（重点）123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!-- CoordinatorLayout是这次新添加的一个增强型的FrameLayout，通过它可以实现很多东西： 例如： 1.界面向上滚动逐渐隐藏Toolbar； 2.在其中可以放置浮动的View，就像Floating Action Button。--&gt;&lt;android.support.design.widget.CoordinatorLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:id=\"@+id/id_coordinatorlayout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:fitsSystemWindows=\"true\"&gt; &lt;!-- AppBarLayout跟它的名字一样，把容器类的组件全部作为AppBar。 将AppBarLayout放在CoordinatorLayout中，就可以实现滚动效果。 本例中，TabLayout在界面滚动时，随着Toolbar的逐渐隐藏，将占据Toolbar的位置， 达到节省屏幕空间，界面动画效果的目的。 --&gt; &lt;android.support.design.widget.AppBarLayout android:id=\"@+id/id_appbarlayout\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\"&gt; &lt;!-- 属性解析： app:theme：指定Toolbar的样式，包括ActionbarToggle和popupMenu的指示图标颜色 app:popupTheme：指定popupMenu溢出后的样式 app:title: 指定Toolbar中主Title的内容 --&gt; &lt;!-- app:layout_scrollFlags的意思是： 设置的layout_scrollFlags有如下几种选项： scroll: 所有想滚动出屏幕的view都需要设置这个flag- 没有设置这个flag的view将被固定在屏幕顶部。 enterAlways: 这个flag让任意向下的滚动都会导致该view变为可见，启用快速“返回模式”。 enterAlwaysCollapsed: 当你的视图已经设置minHeight属性又使用此标志时，你的视图只能以最小高度进入，只有当滚动视图到达顶部时才扩大到完整高度。 exitUntilCollapsed: 当视图会在滚动时，它一直滚动到设置的minHeight时完全隐藏。 需要注意的是，后面两种模式基本只有在CollapsingToolbarLayout才有用， 而前面两种模式基本是需要一起使用的，也就是说，这些flag的使用场景，基本已经固定了。 --&gt; &lt;android.support.v7.widget.Toolbar android:id=\"@+id/id_toolbar\" android:layout_width=\"match_parent\" android:layout_height=\"?attr/actionBarSize\" android:background=\"?attr/colorPrimary\" app:layout_scrollFlags=\"scroll|enterAlways\" app:popupTheme=\"@style/ThemeOverlay.AppCompat.Light\" app:theme=\"@style/ThemeOverlay.AppCompat.ActionBar\" app:title=\"@string/toolbar_title\" /&gt; &lt;!-- Tabs选项卡，和ViewPager搭配使用可以增大界面的内容展示量，实现各种个性化分类内容展示而不互相干扰！ Google在Design support library中提供官方的Tab组件，它就是TabLayout。 相比Github上面开源的第三方库，这个更加简单易用。 有以下常用属性： app:tabGravity=\"fill\" 表示TabLayout中的Tabs要占满屏幕的width； app:tabSelectedTextColor：Tab被选中字体的颜色； app:tabTextColor：Tab未被选中字体的颜色； app:tabIndicatorColor：Tab指示器下标的颜色； --&gt; &lt;android.support.design.widget.TabLayout android:id=\"@+id/id_tablayout\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" app:tabGravity=\"fill\" app:tabIndicatorColor=\"@color/main_white\" /&gt; &lt;/android.support.design.widget.AppBarLayout&gt; &lt;!-- 我们常用的ViewPager，不多说了。你会发现多了一个 app:layout_behavior 属性，没错， 如果你使用CoordinatorLayout来实现Toolbar滚动渐变消失动画效果，那就必须在它下面的那个控件中加入这个属性， 并且下面的这个控件必须是可滚动的。 当设置了layout_behavior的控件滑动时，就会触发设置了layout_scrollFlags的控件发生状态的改变。 --&gt; &lt;android.support.v4.view.ViewPager android:id=\"@+id/id_viewpager\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\" /&gt; &lt;!-- 这是一个浮动按钮。由于FloatingActionButton是重写ImageView的， 所有FloatingActionButton拥有ImageView的一切属性。 属性介绍： app:backgroundTint : FAB的背景色。 app:elevation ：FAB的阴影效果。 app:rippleColor ：设置涟漪的颜色，默认是由背景色生成的暗色调，可以自己指定。 app:pressedTranslationZ ：FAB动画效果，在它被按下的时候阴影就会增大。 --&gt; &lt;android.support.design.widget.FloatingActionButton android:id=\"@+id/id_floatingactionbutton\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"bottom|end\" android:src=\"@mipmap/ic_action_plusone\" app:backgroundTint=\"@color/main_blue_light\" app:elevation=\"6dp\" app:pressedTranslationZ=\"12dp\" app:rippleColor=\"@color/main_blue_dark\" /&gt;&lt;/android.support.design.widget.CoordinatorLayout&gt; frag_main.xml源码（Fragment的布局）1234567891011121314151617181920212223242526&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;!--SwipeRefreshLayout是伟大的Google在v4包中给出的下拉刷新组件。--&gt;&lt;android.support.v4.widget.SwipeRefreshLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:id=\"@+id/id_swiperefreshlayout\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" app:layout_behavior=\"@string/appbar_scrolling_view_behavior\"&gt; &lt;!-- 使用RecyclerView需要在build.gradle中添加 compile 'com.android.support:recyclerview-v7:22.2.0' --&gt; &lt;android.support.v7.widget.RecyclerView android:id=\"@+id/id_recyclerview\" android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" /&gt;&lt;/android.support.v4.widget.SwipeRefreshLayout&gt; item_main.xml源码（RecyclerView中item）123456789101112131415161718192021222324252627282930313233343536&lt;!-- CardView就是一个卡片样式的FrameLayout。 参数介绍： app:cardBackgroundColor : 背景颜色 app:cardCornerRadius ： 设置圆角。 app:cardElevation ： 阴影。 app:cardMaxElevation ： 最大阴影。 app:cardPreventCornerOverlap ： 在v20和之前的版本中添加内边距， 这个属性是为了防止卡片内容和边角的重叠。 app:cardUseCompatPadding ： 设置内边距，v21+的版本和之前的版本仍旧具有一样的计算方式--&gt;&lt;android.support.v7.widget.CardView xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:id=\"@+id/id_cardview\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:layout_gravity=\"center\" app:cardBackgroundColor=\"@color/main_blue_light\" app:cardCornerRadius=\"4dp\" app:cardElevation=\"5dp\" app:cardMaxElevation=\"10dp\" app:cardPreventCornerOverlap=\"true\" app:cardUseCompatPadding=\"true\"&gt; &lt;TextView android:id=\"@+id/id_textview\" android:layout_width=\"200dp\" android:layout_height=\"200dp\" android:layout_gravity=\"center\" android:gravity=\"center\" android:textColor=\"@color/main_white\" android:textSize=\"30sp\" /&gt;&lt;/android.support.v7.widget.CardView&gt; menu_nav.xml的源码（NavagationView中菜单）123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;menu xmlns:android=\"http://schemas.android.com/apk/res/android\"&gt; &lt;group android:checkableBehavior=\"single\"&gt; &lt;item android:id=\"@+id/nav_menu_home\" android:icon=\"@mipmap/ic_home_white_48dp\" android:title=\"主页\" /&gt; &lt;item android:id=\"@+id/nav_menu_categories\" android:icon=\"@mipmap/ic_sort_by_alpha_white_48dp\" android:title=\"分类\" /&gt; &lt;item android:id=\"@+id/nav_menu_feedback\" android:icon=\"@mipmap/ic_message_white_48dp\" android:title=\"反馈\" /&gt; &lt;item android:id=\"@+id/nav_menu_setting\" android:icon=\"@mipmap/ic_settings_white_48dp\" android:title=\"设置\" /&gt; &lt;/group&gt;&lt;/menu&gt; header_nav.xml源码（NavagationView的head）12345678910111213141516171819202122232425262728293031323334&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;LinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"220dp\" android:background=\"@drawable/ic_user_background\" android:gravity=\"center\" android:orientation=\"vertical\"&gt; &lt;!-- 一个显示圆形头像的自定义ImageView --&gt; &lt;com.sunjiajia.androidnewwidgetsdemo.view.RoundedImageView android:id=\"@+id/id_header_face\" android:layout_width=\"110dp\" android:layout_height=\"110dp\" android:scaleType=\"fitXY\" android:src=\"@drawable/author\" /&gt; &lt;TextView android:id=\"@+id/id_header_authorname\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/header_author_name\" android:textColor=\"@android:color/black\" android:textSize=\"16sp\" /&gt; &lt;TextView android:id=\"@+id/id_header_url\" android:layout_width=\"wrap_content\" android:layout_height=\"wrap_content\" android:text=\"@string/header_author_url\" android:textColor=\"@android:color/black\" android:textSize=\"18sp\" /&gt;&lt;/LinearLayout&gt; Java代码Java代码写法比较简单，这里只给出RecyclerView.Adapter的写法（包括item点击事件）。 RecyclerView.Adapter写法源码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889package com.sunjiajia.androidnewwidgetsdemo.adapter;import android.content.Context;import android.support.v7.widget.RecyclerView;import android.view.LayoutInflater;import android.view.View;import android.view.ViewGroup;import com.sunjiajia.androidnewwidgetsdemo.R;import java.util.ArrayList;import java.util.List;/** * Created by Monkey on 2015/6/29. */public class MyRecyclerViewAdapter extends RecyclerView.Adapter&lt;MyRecyclerViewHolder&gt; &#123; // 点击事件接口 public interface OnItemClickListener &#123; void onItemClick(View view, int position); void onItemLongClick(View view, int position); &#125; public OnItemClickListener mOnItemClickListener; public void setOnItemClickListener(OnItemClickListener listener) &#123; this.mOnItemClickListener = listener; &#125; public Context mContext; public List&lt;String&gt; mDatas; public LayoutInflater mLayoutInflater; public MyRecyclerViewAdapter(Context mContext) &#123; this.mContext = mContext; mLayoutInflater = LayoutInflater.from(mContext); // 这里是模拟数据。 mDatas = new ArrayList&lt;&gt;(); for (int i = 'A'; i &lt;= 'z'; i++) &#123; mDatas.add((char) i + \"\"); &#125; &#125; /** * 创建ViewHolder */ @Override public MyRecyclerViewHolder onCreateViewHolder(ViewGroup parent, int viewType) &#123; View mView = mLayoutInflater.inflate(R.layout.item_main, parent, false); MyRecyclerViewHolder mViewHolder = new MyRecyclerViewHolder(mView); return mViewHolder; &#125; /** * 绑定ViewHoler，给item中的控件设置数据 */ @Override public void onBindViewHolder(final MyRecyclerViewHolder holder, final int position) &#123; //点击事件在这里实现，主要是利用RecyclerView中填充的布局控件可以被点击这个原理 if (mOnItemClickListener != null) &#123; holder.itemView.setOnClickListener(new View.OnClickListener() &#123; @Override public void onClick(View v) &#123; mOnItemClickListener.onItemClick(holder.itemView, position); &#125; &#125;); // 长点击事件 holder.itemView.setOnLongClickListener(new View.OnLongClickListener() &#123; @Override public boolean onLongClick(View v) &#123; mOnItemClickListener.onItemLongClick(holder.itemView, position); return true; &#125; &#125;); &#125; holder.mTextView.setText(mDatas.get(position)); &#125; @Override public int getItemCount() &#123; return mDatas.size(); &#125;&#125; MyRecyclerViewHolder.java源码1234567891011121314151617181920package com.sunjiajia.androidnewwidgetsdemo.adapter;import android.support.v7.widget.RecyclerView;import android.view.View;import android.widget.TextView;import com.sunjiajia.androidnewwidgetsdemo.R;/** * Created by Monkey on 2015/6/29. */public class MyRecyclerViewHolder extends RecyclerView.ViewHolder &#123; public TextView mTextView; public MyRecyclerViewHolder(View itemView) &#123; super(itemView); mTextView = (TextView) itemView.findViewById(R.id.id_textview); &#125;&#125; 结语在源码中学习Android，是有种身临其境的感觉的。 整个Demo的源码我放在了GitHub上，谢谢star一下~在看源码过程中如果发现什么问题，请在留言，看到一定回复。 源码地址：AndroidNewWidgetsDemo 原文地址：http://sunjiajia.com/2015/07/02/android-new-widgets-demo/","categories":[{"name":"Android","slug":"Android","permalink":"https://hui46226021.github.io/categories/Android/"},{"name":"JAVA","slug":"Android/JAVA","permalink":"https://hui46226021.github.io/categories/Android/JAVA/"},{"name":"support","slug":"Android/JAVA/support","permalink":"https://hui46226021.github.io/categories/Android/JAVA/support/"}],"tags":[{"name":"移动开发","slug":"移动开发","permalink":"https://hui46226021.github.io/tags/移动开发/"},{"name":"转载","slug":"转载","permalink":"https://hui46226021.github.io/tags/转载/"},{"name":"support v7 新控件","slug":"support-v7-新控件","permalink":"https://hui46226021.github.io/tags/support-v7-新控件/"}]},{"title":"总结下 android集成环信SDK遇到的坑","slug":"android集成环信SDK遇到的坑","date":"2015-11-01T14:37:23.000Z","updated":"2017-09-29T15:00:13.582Z","comments":true,"path":"2015/11/01/android集成环信SDK遇到的坑/","link":"","permalink":"https://hui46226021.github.io/2015/11/01/android集成环信SDK遇到的坑/","excerpt":"摘要:集成了一次环信 sdk 用的是他自带的essyui库 集成的过程中遇到了各种问题 翻来覆去弄个了好几天 记录一下","text":"摘要:集成了一次环信 sdk 用的是他自带的essyui库 集成的过程中遇到了各种问题 翻来覆去弄个了好几天 记录一下在官网创建应用 这些都很顺利按照文档 导入EasyUI库 本来预期是 这样就成功了 可是导入后显然不一样怎么办 最后 联系客服 沟通了好半天 最后 确认几次 是不是 直接导入easyui库 即可 客服 信誓旦旦的说 对 最后经过高人指点 先删除 原easyui项目下的 build.gradle 再次导入 成了 跟文档写的一样了 过了第一个坑 接下来开始编写代码也没什么问题 完美运行起来了 但本还有个 坚果手机 安装测试下 嗯 蹦了 就这么蹦了 查看报错信息 百度了一下 说是有 so库没有加载进去看了下demo里面easyui库 在看看 自己的项目 发现确实缺少没导入 好高兴 发现问题了 接下来把 so库复制进来 在 build.gradle 文件添加代码 android 下面 12345sourceSets &#123; main &#123; jniLibs.srcDirs = ['libs'] &#125; &#125; 启动 。。。依然报错 联系客服 客服又是信誓旦旦 的说 没毛病 最后 发现 应用中有armeabi-v7a 包 ###所以 将armeabi 的文件在复制出一份 放到armeabi-v7a文件夹里 编译 运行 这回真没毛病了","categories":[{"name":"Android","slug":"Android","permalink":"https://hui46226021.github.io/categories/Android/"},{"name":"JAVA","slug":"Android/JAVA","permalink":"https://hui46226021.github.io/categories/Android/JAVA/"},{"name":"IM","slug":"Android/JAVA/IM","permalink":"https://hui46226021.github.io/categories/Android/JAVA/IM/"}],"tags":[{"name":"环信","slug":"环信","permalink":"https://hui46226021.github.io/tags/环信/"},{"name":"即时通讯","slug":"即时通讯","permalink":"https://hui46226021.github.io/tags/即时通讯/"}]},{"title":"Android分包MultiDex原理详解","slug":"Android分包MultiDex原理详解","date":"2015-09-17T14:37:23.000Z","updated":"2017-09-29T14:59:59.902Z","comments":true,"path":"2015/09/17/Android分包MultiDex原理详解/","link":"","permalink":"https://hui46226021.github.io/2015/09/17/Android分包MultiDex原理详解/","excerpt":"摘要:windowIsTranslucent 和windowAnimationStyle冲突","text":"摘要:windowIsTranslucent 和windowAnimationStyle冲突 MultiDex的产生背景当Android系统安装一个应用的时候，有一步是对Dex进行优化，这个过程有一个专门的工具来处理，叫DexOpt。DexOpt的执行过程是在第一次加载Dex文件的时候执行的。这个过程会生成一个ODEX文件，即Optimised Dex。执行ODex的效率会比直接执行Dex文件的效率要高很多。 但是在早期的Android系统中，DexOpt有一个问题，DexOpt会把每一个类的方法id检索起来，存在一个链表结构里面。但是这个链表的长度是用一个short类型来保存的，导致了方法id的数目不能够超过65536个。当一个项目足够大的时候，显然这个方法数的上限是不够的。尽管在新版本的Android系统中，DexOpt修复了这个问题，但是我们仍然需要对低版本的Android系统做兼容。 为了解决方法数超限的问题，需要将该dex文件拆成两个或多个，为此谷歌官方推出了multidex兼容包，配合AndroidStudio实现了一个APK包含多个dex的功能。 MultiDex的简要原理我们以APK中有两个dex文件为例，第二个dex文件为classes2.dex。 兼容包在Applicaion实例化之后，会检查系统版本是否支持 multidex，classes2.dex是否需要安装。 如果需要安装则会从APK中解压出classes2.dex并将其拷贝到应用的沙盒目录下。 通过反射将classes2.dex注入到当前的classloader中。 下面引入一下官方的文档。 https://developer.android.com/tools/building/multidex.html#about 笔者，针对官方文档的翻译如下： 构建超过65K方法的App 随着Android设备的慢慢发展，App的大小会变得越来越大。当我们在开发App的时候由于报的大小和引用库的原因，我们在编译我们项目的时候通常会遇到下面一个错误：1Conversion to Dalvik format failed: Unable to execute dex: method ID not in [0, 0xffff]: 65536 当然，也有一些系统设备会出现以下log信息，不过反馈的是同一个问题：1trouble writing output:Too many field references: 131000; max is 65536.You may try using --multi-dex option. 这两个错误条件显示一个共同的数字：65536。这个数字，它表示的是你在一个dex包中的函数方法超过了65535个。 如果你已经构建了一个Android App时，并收到了这个错误，那么恭喜你，你有很多代码！ 下面我们就具体说说，如何解决这个问题。 关于65K方法限制我们知道Android中的可执行伟剑都存储在dex文件中，其中包含已编译的代码来运行你的应用程序。Dalvik虚拟机对可执行dex文件的规格是有方法限制的，即一个单一的dex文件的方法总数最多为65536。 其中包括： 引用的Android Framework方法 library的方法 我们自己书写代码的方法。 为了突破这个方法数的限制，我们就提出了一个方案——生成多个dex文件。这个多个dex文件的方案，我们又称为multidex方案配置。 Multidex支持Android 5.0之前的版本Android5.0版本的平台之前，Android使用的是Dalvik Runtime执行的程序代码。默认情况下，限制应用到一个单一的classes.dex。 Dalvik字节码文件每APK。为了绕过这个限制，你可以使用multidex支持库，成为你的应用程序的主要部分和DEX文件进行管理，获得额外的dex文件，它们包含的代码。 Multidex支持Android 5.0及更高版本Android 5.0和更高的Runtime 如art，本身就支持从应用的APK文件加载多个DEX文件。art支持预编译的应用程序在安装时扫描类（..）。Dex文件编译成一个单一的Android设备上执行.oat文件。 避免65K限制当你确定使用multidex的分包策略的时候，请你先确定自己的代码中都是优秀的。你还需要做以下几步： 去掉一些未使用的import和library 使用ProGuard去掉一些未使用的代码 用Gradle配置使用MultidexAndroid 的 Gradle插件在 Android Build Tool 21.1开始就支持使用multidex了。 设置你的应用程序开发项目中使用multidex配置，要求你做出一些修改您的应用程序开发项目。： 修改Gradle的配置，支持multidex 修改你的manifest。让其支持multidexapplication类 修改Gradle的build如下：123456789101112131415android &#123; compileSdkVersion 21 buildToolsVersion \"21.1.0\" defaultConfig &#123; ... minSdkVersion 14 targetSdkVersion 21 ... // Enabling multidex support. multiDexEnabled true &#125; ...&#125;dependencies &#123; compile ‘com.android.support:multidex:1.0.0‘&#125; Tips: 你可以在Gradle配置文件中的 multiDexEnabled 在 defaultConfig、buildType、productFlavor选项设置。 在manifest文件中，添加MultidexApplication Class的引用，如下所示：1234567&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.example.android.multidex.myapplication\"&gt; &lt;application ... android:name=\"android.support.multidex.MultiDexApplication\"&gt; ... &lt;/application&gt;&lt;/manifest&gt; 当然，如果你重写了 Application，就对自定义Application的继承方式做一个修改。 Multidex的方式的局限性虽然我们开起来multidex是一个极好的东西，但是multidex还是存在自己的局限性，我们在开发测试之前要清楚局限性是什么： 如果二DEX文件太大，安装分割dex文件是一个复杂的过程，可能会导致应用程序无响应（ANR）的错误。在这种情况下，你应该尽量的减小dex文件的大小和删除无用的逻辑，而不是完全依赖于multidex。 在Android 4.0设备（API Level 14）之前，由于Dalvik linearalloc bug（问题22586），multidex很可能是无法运行的。如果希望运行在Level 14之前的Android系统版本，请先确保完整的测试和使用。 应用程序使用了multiedex配置的，会造成使用比较大的内存。当然，可能还会引起dalvik虚拟机的崩溃(issue 78035)。 对于应用程序比较复杂的，存在较多的library的项目。multidex可能会造成不同依赖项目间的dex文件函数相互调用，找不到方法。 优化multidex开发和构建一个multidex的配置，对系统apk的构建、签名、打包复杂性大大的增加。这就意味着，你每一次的构建过程都是相当耗时的。 为了加快我们的开发速度，加快构建的过程，我们可以在Gradle productFlavors新建出来一个 development flavor 和 production flavor 来满足我们不同构建需求。 下面是一个列子演示我们如何设置这些flavors在Gradle build文件中:1234567891011121314151617181920212223android &#123; productFlavors &#123; // Define separate dev and prod product flavors. dev &#123; // dev utilizes minSDKVersion = 21 to allow the Android gradle plugin // to pre-dex each module and produce an APK that can be tested on // Android Lollipop without time consuming dex merging processes. minSdkVersion 21 &#125; prod &#123; // The actual minSdkVersion for the application. minSdkVersion 14 &#125; &#125; ... buildTypes &#123; release &#123; runProguard true proguardFiles getDefaultProguardFile(‘proguard-android.txt‘), ‘proguard-rules.pro‘ &#125; &#125;&#125;dependencies &#123; compile ‘com.android.support:multidex:1.0.0‘&#125; 在你完成了伤处的配置修改之后，你配置productFlavor 和 buildType来使用 ，devDebug 变种app。使用这些变种app，可以设置proguard disable、multidex enable方便我们测试。 这些配置需要针对Android Gradle插件做如下操作： 在分包前，编译应用程序中的每一个module包括依赖项目，这个步骤称为 pre-dexing。 include每一个dex文件 最重要的是，对于主dex文件，不会做切分。以保证计算速度。 这样设置既能够保证我们的最终报是一个使用了multidex模式的，而又不影响我们平时开发的测试效率。 在Android Studio中使用变种App使用multidex工具构建变种App是非常方便的。在Android Studio允许我们选择这种变种构建方式的接口。 使用Android Studio构建 “devDebug”构建变种app需要完成两步： 打开变种编辑窗口，选择favorites选项。 点击编译不同的变种，如下图所示 原文地址：http://www.mamicode.com/info-detail-1031299.html","categories":[{"name":"Android","slug":"Android","permalink":"https://hui46226021.github.io/categories/Android/"},{"name":"JAVA","slug":"Android/JAVA","permalink":"https://hui46226021.github.io/categories/Android/JAVA/"}],"tags":[{"name":"移动开发","slug":"移动开发","permalink":"https://hui46226021.github.io/tags/移动开发/"},{"name":"原创","slug":"原创","permalink":"https://hui46226021.github.io/tags/原创/"},{"name":"MultiDex","slug":"MultiDex","permalink":"https://hui46226021.github.io/tags/MultiDex/"},{"name":"65535","slug":"65535","permalink":"https://hui46226021.github.io/tags/65535/"}]},{"title":"windowIsTranslucent 和windowAnimationStyle冲突","slug":"windowIsTranslucent 和windowAnimationStyle冲突","date":"2015-09-17T14:37:23.000Z","updated":"2017-09-29T15:00:01.429Z","comments":true,"path":"2015/09/17/windowIsTranslucent 和windowAnimationStyle冲突/","link":"","permalink":"https://hui46226021.github.io/2015/09/17/windowIsTranslucent 和windowAnimationStyle冲突/","excerpt":"摘要:windowIsTranslucent 和windowAnimationStyle冲突","text":"摘要:windowIsTranslucent 和windowAnimationStyle冲突 今天在写 android仿IOS 侧滑销毁的时候 需要把activity的背景设置成透明 在滑出的时候漏出 栈下面一层的activity 在AppTheme里面 设置了windowIsTranslucent 属性123456&lt;style name=\"AppTheme\" parent=\"Theme.AppCompat.Light.NoActionBar\"&gt; &lt;item name=\"colorPrimary\"&gt;#333333&lt;/item&gt; &lt;item name=\"colorPrimaryDark\"&gt;#333333&lt;/item&gt; &lt;item name=\"android:windowAnimationStyle\"&gt;@style/MyActivitySiwtchAnimation&lt;/item&gt; &lt;item name=\"android:windowBackground\"&gt;@color/transparent&lt;/item&gt; &lt;item name=\"android:windowIsTranslucent\"&gt;true&lt;/item&gt; &lt;/style&gt; 这里之前设置过 activity 切换动画接下来 问题来了 设置windowIsTranslucent 后android:windowAnimationStyle 失效了，不好使了 差了写资料 已解决 再次记录下123456789101112&lt;style name=\"MyActivitySiwtchAnimation\" parent=\"@android:style/Animation.Translucent\"&gt; &lt;!--创建效果--&gt; &lt;!--&lt;item name=\"@android:activityOpenEnterAnimation\"&gt;@anim/out_from_right&lt;/item&gt;--&gt; &lt;!--&amp;lt;!&amp;ndash;上一个被覆盖效果&amp;ndash;&amp;gt;--&gt; &lt;!--&lt;item name=\"@android:activityOpenExitAnimation\"&gt;@anim/out_middle&lt;/item&gt;--&gt; &lt;!--&amp;lt;!&amp;ndash;推出效果&amp;ndash;&amp;gt;--&gt; &lt;!--&lt;item name=\"@android:activityCloseExitAnimation\"&gt;@anim/out_toleft&lt;/item&gt;--&gt; &lt;!--&amp;lt;!&amp;ndash;上一个还原效果&amp;ndash;&amp;gt;--&gt; &lt;!--&lt;item name=\"@android:activityCloseEnterAnimation\"&gt;@anim/out_middle2&lt;/item&gt;--&gt; &lt;item name=\"android:windowEnterAnimation\"&gt;@anim/out_from_right&lt;/item&gt; &lt;item name=\"android:windowExitAnimation\"&gt;@anim/out_toleft&lt;/item&gt; &lt;/style&gt; 1.让 android:windowAnimationStyle 继承 @android :style/Animation.Translucent此方法 在退出actvity时候动画有效 创建的时候无效 212&lt;item name=\"android:windowEnterAnimation\"&gt;@anim/out_from_right&lt;/item&gt; &lt;item name=\"android:windowExitAnimation\"&gt;@anim/out_toleft&lt;/item&gt; 此方法有效。不过本人是坑爹的锤子手机 在activity切换的时候 自带 一个由下到上的动画 目前的状态是 创建activity是重屏幕右下角出现 ，在其他手机上 还可以 方法二：绝对完美解决取消1&lt;item name=\"android:windowAnimationStyle\"&gt;@style/MyActivitySiwtchAnimation&lt;/item&gt; 改在 activity 和 fragment的基类里 重写1234567891011121314151617181920212223242526272829/** * 重写 activity切换方法 消除系统自带动画 * @param intent */ @Override public void startActivity(Intent intent) &#123; super.startActivity(intent); overridePendingTransition(R.anim.out_from_right,android.R.anim.slide_out_right); &#125; @Override public void finish() &#123; super.finish(); overridePendingTransition(R.anim.out_from_right,android.R.anim.slide_out_right); &#125; @Override public void startActivityForResult(Intent intent, int requestCode, @Nullable Bundle options) &#123; super.startActivityForResult(intent, requestCode, options); overridePendingTransition(R.anim.out_from_right,android.R.anim.slide_out_right); &#125; @Override public void startActivityForResult(Intent intent, int requestCode) &#123; super.startActivityForResult(intent, requestCode); overridePendingTransition(R.anim.out_from_right,android.R.anim.slide_out_right); &#125; 实现 切换动画 这里收集了一些系统动画 //实现淡入浅出的效果1overridePendingTransition(android.R.anim.fade_in,android.R.anim.fade_out); // 由左向右滑入的效果1overridePendingTransition(android.R.anim.slide_in_left,android.R.anim.slide_out_right);","categories":[{"name":"Android","slug":"Android","permalink":"https://hui46226021.github.io/categories/Android/"},{"name":"JAVA","slug":"Android/JAVA","permalink":"https://hui46226021.github.io/categories/Android/JAVA/"}],"tags":[{"name":"移动开发","slug":"移动开发","permalink":"https://hui46226021.github.io/tags/移动开发/"},{"name":"原创","slug":"原创","permalink":"https://hui46226021.github.io/tags/原创/"},{"name":"windowIsTranslucent","slug":"windowIsTranslucent","permalink":"https://hui46226021.github.io/tags/windowIsTranslucent/"}]},{"title":"Android代码和JS 相互调用 html js","slug":"Android代码和JS 相互调用 html js","date":"2015-09-12T03:37:23.000Z","updated":"2017-09-29T15:00:08.411Z","comments":true,"path":"2015/09/12/Android代码和JS 相互调用 html js/","link":"","permalink":"https://hui46226021.github.io/2015/09/12/Android代码和JS 相互调用 html js/","excerpt":"摘要:今天接到需求要调用相机拍照 但页面是H5写的 所以研究了下 android里 JAVA 代码和JS 相互调用这方面的姿势","text":"摘要:今天接到需求要调用相机拍照 但页面是H5写的 所以研究了下 android里 JAVA 代码和JS 相互调用这方面的姿势 一:JS调用 JAVA1.首先让webview 支持JS1webView.getSettings().setJavaScriptEnabled(true); 2.注入 Java 对象到 WebView 中。12JSKit js = new JSKit(this); mWebView.addJavascriptInterface(js, \"myjs\"); 1234567891011121314/** * Created by zhush on 2016/5/3. */public class JSKit &#123; private MainActivity ma; public JSKit(MainActivity context) &#123; this.ma = context; &#125; @JavascriptInterface public void showMsg(String msg) &#123; Toast.makeText(ma, msg, Toast.LENGTH_SHORT).show(); &#125;&#125; 注意：在 JELLY_BEAN_MR1以后 需要在被调用的方法上加 @JavascriptInterface 要不然调用会失败[Android版本和API Level对应关系]（http://blog.csdn.net/huiguixian/article/details/39928027） 3.JS代码12345678910111213141516171819&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01//EN\" \"http://www.w3.org/TR/html40/strict.dtd\"&gt;&lt;HTML&gt;&lt;HEAD&gt; &lt;meta name=\"viewport\" content=\"width=device-width, target-densitydpi=device-dpi\" /&gt; &lt;META http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;script&gt; function showMsgInAndroid()&#123; myjs.showMsg('标识符'); &#125;&lt;/script&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;span&gt;测试js使用&lt;/span&gt;&lt;button id='btntest' onclick='showMsgInAndroid()'&gt;调用android方法&lt;/button&gt;&lt;/BODY&gt;&lt;/HTML&gt; 二：JAVA调用JS1.JAVA 代码1mWebView.loadUrl(\"javascript:funFromjs('\"+imageUrl+\"')\") 2.JS代码123function funFromjs(str)&#123; alert(str); &#125; Demo下载：https://github.com/hui46226021/JSAndroidCallCamera.git","categories":[{"name":"Android","slug":"Android","permalink":"https://hui46226021.github.io/categories/Android/"},{"name":"JAVA","slug":"Android/JAVA","permalink":"https://hui46226021.github.io/categories/Android/JAVA/"},{"name":"Html5","slug":"Android/JAVA/Html5","permalink":"https://hui46226021.github.io/categories/Android/JAVA/Html5/"},{"name":"JS","slug":"Android/JAVA/Html5/JS","permalink":"https://hui46226021.github.io/categories/Android/JAVA/Html5/JS/"}],"tags":[{"name":"移动开发","slug":"移动开发","permalink":"https://hui46226021.github.io/tags/移动开发/"},{"name":"原创","slug":"原创","permalink":"https://hui46226021.github.io/tags/原创/"},{"name":"JS JAVA调用","slug":"JS-JAVA调用","permalink":"https://hui46226021.github.io/tags/JS-JAVA调用/"}]},{"title":"Android开发--Intent-filter属性详解","slug":"Intent-filter属性详解","date":"2015-08-17T14:37:23.000Z","updated":"2017-03-19T03:15:21.975Z","comments":true,"path":"2015/08/17/Intent-filter属性详解/","link":"","permalink":"https://hui46226021.github.io/2015/08/17/Intent-filter属性详解/","excerpt":"摘要: 一直没有对 Intent-filter 做过多的了解 可能之前 做的项目比较弱 没有被其他程序调用过 这次正好有机会学习了 记录下","text":"摘要: 一直没有对 Intent-filter 做过多的了解 可能之前 做的项目比较弱 没有被其他程序调用过 这次正好有机会学习了 记录下 如果一个 Intent 请求在一片数据上执行一个动作， Android 如何知道哪个应用程序（和组件）能用来响应这个请求呢？ Intent Filter就是 用来注册 Activity 、 Service 和 Broadcast Receiver 具有能在某种数据上执行一个动作的能力。使用 Intent Filter ，应用程序组件告诉 Android ，它们能为其它程序的组件的动作请求提供服务，包括同一个程序的组件、本地的或第三方的应用程序。 为了注册一个应用程序组件为 Intent 处理者，在组件的 manifest 节点添加一个 intent-filter 标签。 在 Intent Filter 节点里使用下面的标签（关联属性），你能指定组件支持的动作、种类和数据： 1．动作测试元素中可以包括子元素，比如：view source print ? &lt; intent-filter &gt; &lt; action android:name=”com.example.project.SHOW_CURRENT” /&gt; &lt; action android:name=”com.example.project.SHOW_RECENT” /&gt; &lt; action android:name=”com.example.project.SHOW_PENDING” /&gt; &lt;/ intent-filter &gt;一条元素至少应该包含一个，否则任何Intent请求都不能和该匹配。如果Intent请求的Action和中个某一条匹配，那么该Intent就通过了这条的动作测试。如果Intent请求或中没有说明具体的Action类型，那么会出现下面两种情况。(1) 如果中没有包含任何Action类型，那么无论什么Intent请求都无法和这条匹配；(2) 反之，如果Intent请求中没有设定Action类型，那么只要中包含有Action类型，这个Intent请求就将顺利地通过的行为测试。 2．类别测试元素可以包含子元素，比如：view source print ? &lt; intent-filter . . . &gt; &lt; category android:name=”android.Intent.Category.DEFAULT” /&gt; &lt; category android:name=”android.Intent.Category.BROWSABLE” /&gt; &lt;/ intent-filter &gt;只有当Intent请求中所有的Category与组件中某一个IntentFilter的完全匹配时，才会让该 Intent请求通过测试，IntentFilter中多余的声明并不会导致匹配失败。一个没有指定任何类别测试的 IntentFilter仅仅只会匹配没有设置类别的Intent请求。 3．数据测试数据在中的描述如下：view source print ? &lt; intent-filter . . . &gt; &lt; data android:type=”video/mpeg” android:scheme=”http” . . . /&gt; &lt; data android:type=”audio/mpeg” android:scheme=”http” . . . /&gt; &lt;/ intent-filter &gt;元素指定了希望接受的Intent请求的数据URI和数据类型，URI被分成三部分来进行匹配：scheme、 authority和path。其中，用setData()设定的Inteat请求的URI数据类型和scheme必须与IntentFilter中所指定的一致。若IntentFilter中还指定了authority或path，它们也需要相匹配才会通过测试。 action使用 android:name 特性来指定对响应的动作名。动作名必须是独一无二的字符串，所以，一个好的习惯是使用基于 Java 包的命名方式的命名系统。 category使用 Android:category 属性用来指定在什么样的环境下动作才被响应。每个 Intent Filter 标签可以包含多个 category 标签。你可以指定自定义的种类或使用 Android 提供的标准值，如下所示： ALTERNATIVE你将在这章的后面所看到的，一个 Intent Filter 的用途是使用动作来帮忙填入上下文菜单。 ALTERNATIVE 种类指定，在某种数据类型的项目上可以替代默认执行的动作。例如，一个联系人的默认动作时浏览它，替代的可能是去编辑或删除它。 SELECTED_ALTERNATIVE与 ALTERNATIVE 类似，但 ALTERNATIVE 总是使用下面所述的 Intent 解析来指向单一的动作。SELECTED_ALTERNATIVE在需要一个可能性列表时使用。 BROWSABLE指定在浏览器中的动作。当 Intent 在浏览器中被引发，都会被指定成 BROWSABLE 种类。 DEFAULT设置这个种类来让组件成为 Intent Filter 中定义的 data 的默认动作。这对使用显式 Intent 启动的 Activity 来说也是必要的。 GADGET通过设置 GADGET 种类，你可以指定这个 Activity 可以嵌入到其他的 Activity 来允许。 HOMEHOME Activity 是设备启动（登陆屏幕）时显示的第一个 Activity 。通过指定 Intent Filter 为 HOME 种类而不指定动作的话，你正在将其设为本地 home 画面的替代。 LAUNCHER使用这个种类来让一个 Activity 作为应用程序的启动项。 datadata 标签允许你指定组件能作用的数据的匹配；如果你的组件能处理多个的话，你可以包含多个条件。你可以使用下面属性的任意组合来指定组件支持的数据： android:host指定一个有效的主机名（例如， com.google ）。 android:mimetype允许你设定组件能处理的数据类型。例如，能匹配任何 Android 游标。 android:path有效地 URI 路径值（例如， /transport/boats/ ）。 android:port特定主机上的有效端口。 android:scheme需要一个特殊的图示（例如， content 或 http ）。 接下来的代码片段显示了如何配置 Activity 的 Intent Filter ，使其以在特定数据下的默认的或可替代的动作的身份来执行 SHOW_DAMAGE动作.1234567891011121314151617181920212223242526272829 &lt;activity android:name=\".EarthquakeDamageViewer\" android:label=\"View Damage\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"com.paad.earthquake.intent.action.SHOW_DAMAGE\"&gt; &lt;/action&gt; &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt; &lt;category android:name=\"android.intent.category.ALTERNATIVE_SELECTED\" /&gt; &lt;data android:mimeType=\"vnd.earthquake.cursor.item/*\"/&gt; &lt;/intent-filter&gt; &lt;/activity&gt; &lt;activity android:name=\".EarthquakeDamageViewer\" android:label=\"View Damage\"&gt; &lt;intent-filter&gt; &lt;action android:name=\"com.paad.earthquake.intent.action.SHOW_DAMAGE\"&gt; &lt;/action&gt; &lt;category android:name=\"android.intent.category.DEFAULT\"/&gt; 原文地址：http://blog.csdn.net/wuwenxiang91322/article/details/7671593","categories":[{"name":"Android","slug":"Android","permalink":"https://hui46226021.github.io/categories/Android/"},{"name":"JAVA","slug":"Android/JAVA","permalink":"https://hui46226021.github.io/categories/Android/JAVA/"}],"tags":[{"name":"移动开发","slug":"移动开发","permalink":"https://hui46226021.github.io/tags/移动开发/"},{"name":"Intent-filter","slug":"Intent-filter","permalink":"https://hui46226021.github.io/tags/Intent-filter/"},{"name":"转载","slug":"转载","permalink":"https://hui46226021.github.io/tags/转载/"}]},{"title":"Android动画 详解(二 帧动画 属性动画 )","slug":"Android动画 详解(二 帧动画 属性动画 )","date":"2015-05-17T14:37:23.000Z","updated":"2017-09-29T15:00:04.823Z","comments":true,"path":"2015/05/17/Android动画 详解(二 帧动画 属性动画 )/","link":"","permalink":"https://hui46226021.github.io/2015/05/17/Android动画 详解(二 帧动画 属性动画 )/","excerpt":"","text":"一 帧动画介绍帧动画 就类似于 电影那种一张图一张图的切换 XML代码先通过XML配置好 需要切换的图片 和 执行是否循环 和执行时间等 文件放在res/drawable 目录下 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt; &lt;!-- oneshot代表着是否只展示一遍，false 不停的循环播放动画 android:duration 时间长度 --&gt; &lt;animation-list xmlns:android=\"http://schemas.android.com/apk/res/android\" android:oneshot=\"true\" &gt; &lt;item android:drawable=\"@drawable/icon6\" android:duration=\"150\"&gt;&lt;/item&gt; &lt;item android:drawable=\"@drawable/icon5\" android:duration=\"150\"&gt;&lt;/item&gt; &lt;item android:drawable=\"@drawable/icon4\" android:duration=\"150\"&gt;&lt;/item&gt; &lt;item android:drawable=\"@drawable/icon3\" android:duration=\"150\"&gt;&lt;/item&gt; &lt;item android:drawable=\"@drawable/icon2\" android:duration=\"150\"&gt;&lt;/item&gt; &lt;item android:drawable=\"@drawable/icon1\" android:duration=\"150\"&gt;&lt;/item&gt; &lt;/animation-list&gt; JAVA调用XML开启动画先创建一个IamgeView 将其背景设置成 之前配置好的xml 1234ImageView imageView = (ImageView) findViewById(R.id.imageView); imageView.setImageResource(R.drawable.animation1); AnimationDrawable animationDrawable = (AnimationDrawable) animationIV.getDrawable(); animationDrawable.start(); 注意事项要在代码中调用 ImageView 的 setBackgroundResource 方法，如果直接在 XML 布局文件中设置其 src 属性当触发动画时会 ForceClose ； 在动画 start 之前要先 stop，不然在第一次动画之后会停在最后一帧，这样动画就只会触发一次； 正如SDK中所提到的，不要在 onCreate 中调用 start，因为 AnimationDrawable 还没有完全跟 Window 相关联，如果想要界面显示时就开始动画的话，可以在 onWindowFoucsChanged 中调用 start 。 属性动画 属性动画指的是 通过改变view 的属性来实现动画 跟补间动画本质的区别在于 补间动画 在改变的只是样子 例如将一个Button 放大 补间动画 放大后 其点击时间 并没有变 还是原来的大小 具体先看这篇文章 http://blog.csdn.net/lmj623565791/article/details/38067475 插值器 Interpolator class Resource ID 备注 AccelerateDecelerateInterpolator @android:anim/accelerate_decelerate_interpolator 加速减速 AccelerateInterpolator @android:anim/accelerate_interpolator 加速 AnticipateInterpolator @android:anim/anticipate_interpolator 退小步往前冲 AnticipateOvershootInterpolator @android:anim/anticipate_overshoot_interpolator 退小步冲过头退回 BounceInterpolator @android:anim/bounce_interpolator 球落地弹动效果 CycleInterpolator @android:anim/cycle_interpolator 周期重复 DecelerateInterpolator @android:anim/decelerate_interpolator 减速 LinearInterpolator @android:anim/linear_interpolator 匀速 OvershootInterpolator @android:anim/overshoot_interpolator 冲过头再退回","categories":[{"name":"Android","slug":"Android","permalink":"https://hui46226021.github.io/categories/Android/"},{"name":"JAVA","slug":"Android/JAVA","permalink":"https://hui46226021.github.io/categories/Android/JAVA/"}],"tags":[{"name":"原创","slug":"原创","permalink":"https://hui46226021.github.io/tags/原创/"},{"name":"动画","slug":"动画","permalink":"https://hui46226021.github.io/tags/动画/"}]},{"title":"git 常用命令","slug":"git 常用命令","date":"2015-04-18T14:37:23.000Z","updated":"2017-03-19T04:58:20.604Z","comments":true,"path":"2015/04/18/git 常用命令/","link":"","permalink":"https://hui46226021.github.io/2015/04/18/git 常用命令/","excerpt":"摘要:记录","text":"摘要:记录 git config –global user.name “Tony” //设置名字 git config –global user.email “tony@gmail.com” //设置邮箱 git init git add AndroidManifest.xml //添加单个文件 git add src //添加文件夹 git add . //添加所有文件 git commit -m “First commit.” //提交 我们在ProviderTest项目的根目录下创建一个名为.gitignore的文件，然后编辑这个文件 排除 git status //查看修改项目 git diff src/com/example/providertest/MainActivity.java //查看修改文件的内容 git checkout src/com/example/providertest/MainActivity.java //撤销修改的文件 在提交之前 git reset HEAD src/com/example/providertest/MainActivity.java //取消添加 git log //查看日志 git log 2e7c0547af28cc1e9f303a4a1126fddbb704281b -1 -p //查看具体内容 git branch –a //查看分支 git branch version1.0 //创建分支 git checkout version1.0 //切换分支 git checkout master git merge version1.0 //合并分支 git branch -D version1.0 //删除分支 git clone https://github.com/exmaple/test.git //远程代码下载到本地 git push origin master //提交到远程仓库 其中origin部分指定的是远程版本库的Git地址，master部分指定的是同步到哪一个分支 git fetch origin master //下载远程代码 执行这个命令后，就会将远程版本库上的代码同步到本地，不过同步下来的代码并不会合并到任何分支上去，而是会存放在到一个origin/master分支上，这时我们可以通过diff命令来查看远程版本库上到底修改了哪些东西： git diff origin/master 之后再调用merge命令将origin/master分支上的修改合并到主分支上即可，如下所示： git merge origin/master git pull origin master //相当于上面两条命令","categories":[{"name":"git","slug":"git","permalink":"https://hui46226021.github.io/categories/git/"}],"tags":[{"name":"原创","slug":"原创","permalink":"https://hui46226021.github.io/tags/原创/"},{"name":"版本控制","slug":"版本控制","permalink":"https://hui46226021.github.io/tags/版本控制/"},{"name":"git命令","slug":"git命令","permalink":"https://hui46226021.github.io/tags/git命令/"}]},{"title":"Linux中vi编辑器的使用详解","slug":"Linux环境配置","date":"2015-01-22T14:37:23.000Z","updated":"2017-09-29T14:59:33.767Z","comments":true,"path":"2015/01/22/Linux环境配置/","link":"","permalink":"https://hui46226021.github.io/2015/01/22/Linux环境配置/","excerpt":"摘要:记录","text":"摘要:记录 模式vi编辑器是Linux系统下标准的编辑器.而且不逊色于其他任何最新的编辑器.可是会用的有多少呢.下面介绍一下vi编辑器的简单用法和部分命令.让你在Linux系统中畅行无阻. 基本上vi可以分为三种状态，分别是命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode）. 1) 命令行模式command mode） 控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode。 2) 插入模式（Insert mode） 只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。 3) 底行模式（last line mode） 将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。 不过一般我们在使用时把vi简化成两个模式，就是将底行模式（last line mode）也算入命令行模式command mode）。 工具/原料 Linux 方法/步骤 1首先进入Linux的命令行界面.在目录下创建一个用于测试的文本文件(touch filename).我这里就新建了一个test12文本文件.当然这个名字是可以随便取得. 2用”vi test12”命令进入vi命令行模式(vi filename). 如果要想编辑文本文件.必须要转换到插入模式下,也就是按一下键盘上的”i”就可以了.这样你就可以编辑文本,删除文本中的内容.按键盘上的上下左右键.来回移动了.就跟你在windows 系统中编辑文本一样. 3输入你要输入的内容.如果你想退出文本编辑模式.并且保存刚刚编辑的文本.首先点击一下键盘上的”ESC”,然后输入”:wq!”这样就将文本保存了.然后推出了vi编辑器.如果不想保存就按一下键盘上的”ESC”,输入”:q!”.如果你不确定是否成功.可以通过”cat filename” 命令来查看. 4光标的移动除了键盘上的上下左右键.也可以是小写模式下,按键盘上的”h,j,k,l”,“ctrl+b”:屏幕往后移动一页“ctrl+f”:屏幕往前移动一页“ctrl+u”:屏幕往后移动半页“ctrl+d”:屏幕往前移动半页输入任何一个整数,然后输入”shift+G” 就可以到这一页的开头了.按键盘上的大写”G”移动到文章的最后.按”$”符号将光标移动到行尾“^”将光标移到行头“w”:将光标移到下一行头“b”:跟”w”相反.移到上一行行头“e”:将光标移到下一行尾.如果想让文本显示行号.就在命令行 模式下,在文本最后输入”:set nu”命令.就可以了 5复制 「yw」：将光标所在之处到字尾的字符复制到缓冲区中。 「yy」：复制光标所在行到缓冲区。 「#yy」：例如，「6yy」表示拷贝从光标所在的该行”往下数”6行文字。 「p」：将缓冲区内的字符贴到光标所在位置。注意：所有与”y”有关的复制命令都必须与”p”配合才能完成复制与粘贴功能。 6查找用”/“加上要查找的内容.例如”/hello”或者是”?hello”也是可以的.7替换 「r」：替换光标所在处的字符。 ,按一下”r”然后输入要即可. 「R」：替换光标所到之处的字符，直到按下「ESC」键为止。 8恢复上一次操作 「u」：如果您误执行一个命令，可以马上按下「u」，回到上一个操作。按多次”u”可以执行多次恢复.就相当于”CTRL +Z”的操作.","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hui46226021.github.io/categories/Linux/"},{"name":"vi","slug":"Linux/vi","permalink":"https://hui46226021.github.io/categories/Linux/vi/"}],"tags":[{"name":"原创","slug":"原创","permalink":"https://hui46226021.github.io/tags/原创/"},{"name":"vi","slug":"vi","permalink":"https://hui46226021.github.io/tags/vi/"},{"name":"Linux","slug":"Linux","permalink":"https://hui46226021.github.io/tags/Linux/"}]},{"title":"Linux中vi编辑器的使用详解","slug":"Linux中vi编辑器的使用详解","date":"2015-01-22T14:37:23.000Z","updated":"2017-09-29T14:59:58.781Z","comments":true,"path":"2015/01/22/Linux中vi编辑器的使用详解/","link":"","permalink":"https://hui46226021.github.io/2015/01/22/Linux中vi编辑器的使用详解/","excerpt":"摘要:记录","text":"摘要:记录 模式vi编辑器是Linux系统下标准的编辑器.而且不逊色于其他任何最新的编辑器.可是会用的有多少呢.下面介绍一下vi编辑器的简单用法和部分命令.让你在Linux系统中畅行无阻. 基本上vi可以分为三种状态，分别是命令模式（command mode）、插入模式（Insert mode）和底行模式（last line mode）. 1) 命令行模式command mode） 控制屏幕光标的移动，字符、字或行的删除，移动复制某区段及进入Insert mode下，或者到 last line mode。 2) 插入模式（Insert mode） 只有在Insert mode下，才可以做文字输入，按「ESC」键可回到命令行模式。 3) 底行模式（last line mode） 将文件保存或退出vi，也可以设置编辑环境，如寻找字符串、列出行号……等。 不过一般我们在使用时把vi简化成两个模式，就是将底行模式（last line mode）也算入命令行模式command mode）。 工具/原料 Linux 方法/步骤 1首先进入Linux的命令行界面.在目录下创建一个用于测试的文本文件(touch filename).我这里就新建了一个test12文本文件.当然这个名字是可以随便取得. 2用”vi test12”命令进入vi命令行模式(vi filename). 如果要想编辑文本文件.必须要转换到插入模式下,也就是按一下键盘上的”i”就可以了.这样你就可以编辑文本,删除文本中的内容.按键盘上的上下左右键.来回移动了.就跟你在windows 系统中编辑文本一样. 3输入你要输入的内容.如果你想退出文本编辑模式.并且保存刚刚编辑的文本.首先点击一下键盘上的”ESC”,然后输入”:wq!”这样就将文本保存了.然后推出了vi编辑器.如果不想保存就按一下键盘上的”ESC”,输入”:q!”.如果你不确定是否成功.可以通过”cat filename” 命令来查看. 4光标的移动除了键盘上的上下左右键.也可以是小写模式下,按键盘上的”h,j,k,l”,“ctrl+b”:屏幕往后移动一页“ctrl+f”:屏幕往前移动一页“ctrl+u”:屏幕往后移动半页“ctrl+d”:屏幕往前移动半页输入任何一个整数,然后输入”shift+G” 就可以到这一页的开头了.按键盘上的大写”G”移动到文章的最后.按”$”符号将光标移动到行尾“^”将光标移到行头“w”:将光标移到下一行头“b”:跟”w”相反.移到上一行行头“e”:将光标移到下一行尾.如果想让文本显示行号.就在命令行 模式下,在文本最后输入”:set nu”命令.就可以了 5复制 「yw」：将光标所在之处到字尾的字符复制到缓冲区中。 「yy」：复制光标所在行到缓冲区。 「#yy」：例如，「6yy」表示拷贝从光标所在的该行”往下数”6行文字。 「p」：将缓冲区内的字符贴到光标所在位置。注意：所有与”y”有关的复制命令都必须与”p”配合才能完成复制与粘贴功能。 6查找用”/“加上要查找的内容.例如”/hello”或者是”?hello”也是可以的.7替换 「r」：替换光标所在处的字符。 ,按一下”r”然后输入要即可. 「R」：替换光标所到之处的字符，直到按下「ESC」键为止。 8恢复上一次操作 「u」：如果您误执行一个命令，可以马上按下「u」，回到上一个操作。按多次”u”可以执行多次恢复.就相当于”CTRL +Z”的操作.","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hui46226021.github.io/categories/Linux/"},{"name":"vi","slug":"Linux/vi","permalink":"https://hui46226021.github.io/categories/Linux/vi/"}],"tags":[{"name":"原创","slug":"原创","permalink":"https://hui46226021.github.io/tags/原创/"},{"name":"vi","slug":"vi","permalink":"https://hui46226021.github.io/tags/vi/"},{"name":"Linux","slug":"Linux","permalink":"https://hui46226021.github.io/tags/Linux/"}]},{"title":"Linux环境配置","slug":"Linux服务器环境配置","date":"2015-01-12T13:35:23.000Z","updated":"2017-09-29T14:59:27.280Z","comments":true,"path":"2015/01/12/Linux服务器环境配置/","link":"","permalink":"https://hui46226021.github.io/2015/01/12/Linux服务器环境配置/","excerpt":"摘要:记录","text":"摘要:记录 Linux安装JDK步骤1、先从网上下载jdk(jdk-7u1-linux-i586.rpm)，下载地址:http://www.oracle.com/technetwork/java/javase/downloads/jdk-7u1-download-513651.html下载后放在/home目录中，当然其它地方也行。 2、进入安装目录 #cd /home #cp jdk-7u1-linux-i586.rpm /usr/local #cd /usr/local 给所有用户添加可执行的权限 #rpm -ivh jdk-7u1-linux-i586.rpm 安装过程如图所示： 3、设置环境变量 #vi /etc/profile 打开后，在文档最下方加上以下环境变量配置代码： export JAVA_HOME=/usr/java/javajdk1.7.0_01 export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar export PATH=$JAVA_HOME/bin:$PATH 注意：export PATH=$JAVA_HOME/bin:$PATH，注意将$PATH放到最后。以免造成新旧版本问题。 编辑profile文档立即生效 source /etc/profile 4、检查JDK是否安装成功。 #java -version 如果看到JVM版本及相关信息，即安装成功！ Linux下Tomcat的安装配置下载安装tomcat http://tomcat.apache.org/ [root@master ~]# unzip apache-tomcat-6.0.30.zip [root@master ~]# mv apache-tomcat-6.0.30/ /usr/local/ [root@master ~]cd /usr/local/ [root@master local]# ln -s /usr/local/apache-tomcat-6.0.30/ /usr/local/tomcat [root@master local]# cd tomcat/bin/ [root@master bin]#ls [root@master bin]#vim catalina.sh 添加以下内容： CATALINA_HOME=/usr/local/apache-tomcat-6.0.30/ [root@master local]#chmod +x *.sh 三．启动tomcat服务器 [root@master tomcat]# /usr/local/tomcat /bin/catalina.sh start 安装及启动nginx输入yum install nginx命令进行nginx的安装，当需要确认时输入”y“确认。 输入service nginx start启动nginx服务。 输入wget http://127.0.0.1测试nginx服务。 使用命令nginx -t查找nginx配置文件，并使用vi命令修改该配置文件：","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hui46226021.github.io/categories/Linux/"},{"name":"nginx","slug":"Linux/nginx","permalink":"https://hui46226021.github.io/categories/Linux/nginx/"},{"name":"tomcat","slug":"Linux/nginx/tomcat","permalink":"https://hui46226021.github.io/categories/Linux/nginx/tomcat/"}],"tags":[{"name":"原创","slug":"原创","permalink":"https://hui46226021.github.io/tags/原创/"},{"name":"Linux","slug":"Linux","permalink":"https://hui46226021.github.io/tags/Linux/"},{"name":"nginx","slug":"nginx","permalink":"https://hui46226021.github.io/tags/nginx/"}]},{"title":"Linux环境配置","slug":"Linux中vi编辑器的使用详解 - 副本","date":"2015-01-12T13:35:23.000Z","updated":"2017-09-29T14:59:34.676Z","comments":true,"path":"2015/01/12/Linux中vi编辑器的使用详解 - 副本/","link":"","permalink":"https://hui46226021.github.io/2015/01/12/Linux中vi编辑器的使用详解 - 副本/","excerpt":"摘要:记录","text":"摘要:记录 Linux安装JDK步骤1、先从网上下载jdk(jdk-7u1-linux-i586.rpm)，下载地址:http://www.oracle.com/technetwork/java/javase/downloads/jdk-7u1-download-513651.html下载后放在/home目录中，当然其它地方也行。 2、进入安装目录 #cd /home #cp jdk-7u1-linux-i586.rpm /usr/local #cd /usr/local 给所有用户添加可执行的权限 #rpm -ivh jdk-7u1-linux-i586.rpm 安装过程如图所示： 3、设置环境变量 #vi /etc/profile 打开后，在文档最下方加上以下环境变量配置代码： export JAVA_HOME=/usr/java/javajdk1.7.0_01 export CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar export PATH=$JAVA_HOME/bin:$PATH 注意：export PATH=$JAVA_HOME/bin:$PATH，注意将$PATH放到最后。以免造成新旧版本问题。 编辑profile文档立即生效 source /etc/profile 4、检查JDK是否安装成功。 #java -version 如果看到JVM版本及相关信息，即安装成功！ Linux下Tomcat的安装配置下载安装tomcat http://tomcat.apache.org/ [root@master ~]# unzip apache-tomcat-6.0.30.zip [root@master ~]# mv apache-tomcat-6.0.30/ /usr/local/ [root@master ~]cd /usr/local/ [root@master local]# ln -s /usr/local/apache-tomcat-6.0.30/ /usr/local/tomcat [root@master local]# cd tomcat/bin/ [root@master bin]#ls [root@master bin]#vim catalina.sh 添加以下内容： CATALINA_HOME=/usr/local/apache-tomcat-6.0.30/ [root@master local]#chmod +x *.sh 三．启动tomcat服务器 [root@master tomcat]# /usr/local/tomcat /bin/catalina.sh start 安装及启动nginx输入yum install nginx命令进行nginx的安装，当需要确认时输入”y“确认。 输入service nginx start启动nginx服务。 输入wget http://127.0.0.1测试nginx服务。 使用命令nginx -t查找nginx配置文件，并使用vi命令修改该配置文件：","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hui46226021.github.io/categories/Linux/"},{"name":"nginx","slug":"Linux/nginx","permalink":"https://hui46226021.github.io/categories/Linux/nginx/"},{"name":"tomcat","slug":"Linux/nginx/tomcat","permalink":"https://hui46226021.github.io/categories/Linux/nginx/tomcat/"}],"tags":[{"name":"原创","slug":"原创","permalink":"https://hui46226021.github.io/tags/原创/"},{"name":"Linux","slug":"Linux","permalink":"https://hui46226021.github.io/tags/Linux/"},{"name":"nginx","slug":"nginx","permalink":"https://hui46226021.github.io/tags/nginx/"}]},{"title":"JAVA 多线程","slug":"JAVA多线程深度解析","date":"2015-01-12T10:37:23.000Z","updated":"2017-09-29T15:00:03.805Z","comments":true,"path":"2015/01/12/JAVA多线程深度解析/","link":"","permalink":"https://hui46226021.github.io/2015/01/12/JAVA多线程深度解析/","excerpt":"摘要:之前学习过一下JAVA的多线程知识 当时也没有 做记录 等再次用到的时候 发现已经忘干净了 所以这次记录下来 可能不是很详细 以后看不到 就单个点 继续百度学习","text":"摘要:之前学习过一下JAVA的多线程知识 当时也没有 做记录 等再次用到的时候 发现已经忘干净了 所以这次记录下来 可能不是很详细 以后看不到 就单个点 继续百度学习 后台线程所谓的后台线程，是指在程序运行的时候在后台提供一种通用服务的线程，并且这种线程并不属于程序中不可或缺的部分。因此当所有的非后台线程结束时，程序也就终止了，同时会杀死所有后台线程。反过来说，只要有任何非后台线程(用户线程)还在运行，程序就不会终止。后台线程在不执行finally子句的情况下就会终止其run方法。后台线程创建的子线程也是后台线程 main 是非后台线程 setDaemon(true); 必须在线程start(); 方法前执行 isDaemon() 来判断一个线程是否是守护线程 在Daemon线程中产生的新线程也是Daemon的 带返回值的线程 Callable Future f1 = pool.submit(); call()方法 线程阻塞到 所有线程都 返回结果 线程本地缓存 ThreadLocalThreadLocal.set() 到线程中的对象是该线程自己使用的对象，其他线程是不需要访问的，也访问不到的 实际是放到当前线程的ThreadLocalMap这个map中 线程安全1.即有synchronized关键字修饰的方法。由于java的每个对象都有一个内置锁，当用此关键字修饰方法时， 内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就处于阻塞状态。 代码如：1public synchronized void save()&#123;&#125; 2 即有synchronized关键字修饰的语句块。被该关键字修饰的语句块会自动被加上内置锁，从而实现同步 代码如： 123 synchronized(object)&#123;&#125; 3.使用特殊域变量(volatile)实现线程同步当一个共享变量被volatile修饰时，它会保证修改的值会立即被更新到主存，当有其他线程需要读取时，它会去内存中读取新值 volatile保证了 可见性 但不保证原子行 private volatile int account = 100; 4.使用重入锁实现线程同步 ReentrantLock() : 创建一个ReentrantLock实例 lock() : 获得锁 unlock() : 释放锁 5.wait() notify()Obj.wait()，与Obj.notify()必须要与synchronized(Obj)一起使用，也就是wait,与notify是针对已经获取了Obj锁进行操作，从语法角度来说就是Obj.wait(),Obj.notify必须在synchronized(Obj){…}语句块内。从功能上来说wait就是说线程在获取对象锁后，主动释放对象锁，同时本线程休眠。直到有其它线程调用对象的notify()唤醒该线程，才能继续获取对象锁，并继续执行 调用 notify() 方法导致解除阻塞的线程是从因调用该对象的 wait() 方法而阻塞的线程中随机选取的 除了 notify()，还有一个方法 notifyAll() 也可起到类似作用，唯一的区别在于，调用 notifyAll() 方法将把因调用该对象的 wait() 方法而阻塞的所有线程一次性全部解除阻塞。 和 suspend() 和 resume()功能类似 不过后者不会释放锁 注 ：Lock有比synchronized更精确的线程语义和更好的性能。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放 CountDownLatchCountDownLatch是减计数方式，计数==0时释放所有等待的线程；CyclicBarrier是加计数方式，计数达到构造方法中参数指定的值时释放所有等待的线程。CountDownLatch当计数到0时，计数无法被重置；CyclicBarrier计数达到指定值时，计数置为0重新开始。CountDownLatch每次调用countDown()方法计数减一，调用await()方法只进行阻塞，对计数没任何影响；CyclicBarrier只有一个await()方法，调用await()方法计数加1，若加1后的值不等于构造方法的值，则线程阻塞 线程池1.减少了创建和销毁线程的次数，每个工作线程都可以被重复利用，可执行多个任务。2.可以根据系统的承受能力，调整线程池中工作线线程的数目，防止因为消耗过多的内存，而把服务器累趴下(每个线程需要大约1MB内存，线程开的越多，消耗的内存也就越大，最后死机)。Java里面线程池的顶级接口是Executor，但是严格意义上讲Executor并不是一个线程池，而只是一个执行线程的工具。真正的线程池接口是ExecutorService。 Executors 静态方法 newSingleThreadExecutor 创建一个单线程的线程池 newFixedThreadPool 创建固定大小的线程池 newCachedThreadPool 创建一个可缓存的线程池 newScheduledThreadPool 创建一个大小无限的线程池 ThreadPoolExecutor的完整构造方法的签名是：ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) corePoolSize：核心池的大小 maximumPoolSize：线程池最大线程数 keepAliveTime：表示线程没有任务执行时最多保持多久时间会终止 unit：参数keepAliveTime的时间单位 workQueue：一个阻塞队列 threadFactory：线程工厂，主要用来创建线程 handler：表示当拒绝处理任务时的策略，有以下四种取值 常用方法 execute() submit() shutdown() shutdownNow() 线程异常捕获：线程代码不能抛出任何checked异常。所有的线程中的checked异常都只能被线程本身消化掉当 线程代码抛出运行级别异常之后，线程会中断。 在thread.start()之前 设置 异常回调12345678910111213thread.setDefaultUncaughtExceptionHandler(new Thread.UncaughtExceptionHandler() &#123; @Override public void uncaughtException(Thread t, Throwable e) &#123; System.out.println(\"线程\"+t.getName()+\"--异常信息\"); e.printStackTrace(); &#125; &#125;) 线程池捕获异常而在线程池中却比较特殊。默认情况下，线程池 java.util.concurrent.ThreadPoolExecutor 会Catch住所有异常 通过覆盖ThreadPoolExecutor.afterExecute 方法，我们才能捕获到任务的异常1234567protected void afterExecute(Runnable r, Throwable t) &#123; super.afterExecute(r, t); &#125;","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://hui46226021.github.io/categories/JAVA/"},{"name":"Web","slug":"JAVA/Web","permalink":"https://hui46226021.github.io/categories/JAVA/Web/"}],"tags":[{"name":"原创","slug":"原创","permalink":"https://hui46226021.github.io/tags/原创/"},{"name":"服务器开发","slug":"服务器开发","permalink":"https://hui46226021.github.io/tags/服务器开发/"},{"name":"JAVA 多线程","slug":"JAVA-多线程","permalink":"https://hui46226021.github.io/tags/JAVA-多线程/"}]},{"title":"基于注解的mybatis","slug":"基于注解的mybatis","date":"2014-12-17T08:17:33.000Z","updated":"2017-03-19T05:34:47.005Z","comments":true,"path":"2014/12/17/基于注解的mybatis/","link":"","permalink":"https://hui46226021.github.io/2014/12/17/基于注解的mybatis/","excerpt":"","text":"原文地址：http://wwww.iteye.com/blog/1235996","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://hui46226021.github.io/categories/JAVA/"},{"name":"Mybatis","slug":"JAVA/Mybatis","permalink":"https://hui46226021.github.io/categories/JAVA/Mybatis/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://hui46226021.github.io/tags/数据库/"},{"name":"注解","slug":"注解","permalink":"https://hui46226021.github.io/tags/注解/"}]},{"title":"基于Redis的Session共享示例","slug":"基于Redis的Session共享示例","date":"2014-12-17T08:17:33.000Z","updated":"2017-09-29T14:59:45.662Z","comments":true,"path":"2014/12/17/基于Redis的Session共享示例/","link":"","permalink":"https://hui46226021.github.io/2014/12/17/基于Redis的Session共享示例/","excerpt":"摘要: 在单机情况下，Session可由部署在服务器上的Web容器来管理 (如Tomcat、JBoss)。 在负载均衡的集群环境下，负载均衡可能将请求分发到不同的服务器上去，在这种情况，需要将有状态的session统一管理起来","text":"摘要: 在单机情况下，Session可由部署在服务器上的Web容器来管理 (如Tomcat、JBoss)。 在负载均衡的集群环境下，负载均衡可能将请求分发到不同的服务器上去，在这种情况，需要将有状态的session统一管理起来https://my.oschina.net/wangmengjun/blog/810179#0-tsina-1-15650-397232819ff9a47a7b7e80a40613cfe1","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://hui46226021.github.io/categories/JAVA/"},{"name":"Redis","slug":"JAVA/Redis","permalink":"https://hui46226021.github.io/categories/JAVA/Redis/"},{"name":"Session","slug":"JAVA/Redis/Session","permalink":"https://hui46226021.github.io/categories/JAVA/Redis/Session/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"https://hui46226021.github.io/tags/Redis/"},{"name":"session共享","slug":"session共享","permalink":"https://hui46226021.github.io/tags/session共享/"},{"name":"分布式","slug":"分布式","permalink":"https://hui46226021.github.io/tags/分布式/"}]},{"title":"基于注解的mybatis","slug":"MySQL DBA 面试全揭秘","date":"2014-12-17T08:17:33.000Z","updated":"2017-09-27T07:00:33.825Z","comments":true,"path":"2014/12/17/MySQL DBA 面试全揭秘/","link":"","permalink":"https://hui46226021.github.io/2014/12/17/MySQL DBA 面试全揭秘/","excerpt":"","text":"原文地址：http://wwww.iteye.com/blog/1235996","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://hui46226021.github.io/categories/JAVA/"},{"name":"Mybatis","slug":"JAVA/Mybatis","permalink":"https://hui46226021.github.io/categories/JAVA/Mybatis/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://hui46226021.github.io/tags/数据库/"},{"name":"注解","slug":"注解","permalink":"https://hui46226021.github.io/tags/注解/"}]},{"title":"Java程序打包成jar包/","slug":"Java程序打包成jar包","date":"2014-12-05T05:47:23.000Z","updated":"2017-03-19T05:05:27.920Z","comments":true,"path":"2014/12/05/Java程序打包成jar包/","link":"","permalink":"https://hui46226021.github.io/2014/12/05/Java程序打包成jar包/","excerpt":"","text":"方法一：通过jar命令jar命令的用法：下面是jar命令的帮助说明： 用法：jar {ctxui}[vfm0Me] [jar-file] [manifest-file] [entry-point] [-C dir] files … 选项包括： -c 创建新的归档文件 -t 列出归档目录 -x 解压缩已归档的指定（或所有）文件 -u 更新现有的归档文件 -v 在标准输出中生成详细输出 -f 指定归档文件名 -m 包含指定清单文件中的清单信息 -e 为捆绑到可执行 jar 文件的独立应用程序 指定应用程序入口点 -0 仅存储；不使用任何 ZIP 压缩 -M 不创建条目的清单文件 -i 为指定的 jar 文件生成索引信息 -C 更改为指定的目录并包含其中的文件如果有任何目录文件，则对其进行递归处理。清单文件名、归档文件名和入口点名的指定顺序与 “m”、”f” 和 “e” 标志的指定顺序相同。 示例 1：将两个类文件归档到一个名为 classes.jar 的归档文件中： jar cvf classes.jar Foo.class Bar.class示例 2：使用现有的清单文件 “mymanifest” 并 将 foo/ 目录中的所有文件归档到 “classes.jar” 中： jar cvfm classes.jar mymanifest -C foo/ . 下文假设编译后的class文件在bin目录下 一、打包成一般的jar包输入如下命令即可： Cmd代码 复制代码 收藏代码jar cvf counter.jar -C bin .其中，“-C bin”实际上是告诉jar命令先cd到bin目录下，再在此目录执行没有参数“-C bin”的命令，等价于： Cmd代码 复制代码 收藏代码cd binjar cvf counter.jar . // “.”代表当前路径 二、打包成可运行的jar包要打包成可运行的jar包，有两种方法，一是手动创建MANIFEST.MF文件，并在其中指定主类;二是使用jar的-e参数指定可运行jar包的入口点（即main类的完全名称）. 以Java源代码行数统计程序的打包为例，演示如何打包: 手动创建MANIFEST.MF文件： 1）首先编辑MANIFEST.MF文件，内容如下： Mf代码 收藏代码 复制代码Manifest-Version: 1.0Created-By: rsljdktClass-Path: .Main-Class: Main 说明： 第一行指定清单的版本，若无，则JDK默认生成：Manifest-Version: 1.0 第二行指明创建的作者，若无，则JDK默认生成Created-By: 1.6.0_22(Sun Microsystems Inc.) 第三行指定主类所在类路径， 第四行指明程序运行的主类 2）使用jar命令进行打包： Cmd代码 复制代码 收藏代码jar cvfm counter.jar MANIFEST.MF -C bin . 说明： 参数f：指定打包后的包名。 参数m：指定自定义的MANIFEST.MF清单文件，否则，JDK会自动生成不包含Main-Class的默认清单。 参数c：指定是创建新的归档文件。 参数v：在标准输出中生成详细输出，该选项是可选的。 使用-e参数指定入口点： 执行如下命令即可： Cmd代码 复制代码 收藏代码jar cvfe counter.jar Main -C bin . 原文地址：http://blog.sina.com.cn/s/blog_93d133c601013hdm.html","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://hui46226021.github.io/categories/JAVA/"}],"tags":[{"name":"转载","slug":"转载","permalink":"https://hui46226021.github.io/tags/转载/"},{"name":"Jar包","slug":"Jar包","permalink":"https://hui46226021.github.io/tags/Jar包/"}]},{"title":"spring security的原理及教程","slug":"spring security的原理及教程","date":"2014-11-17T08:17:33.000Z","updated":"2017-03-19T05:55:53.070Z","comments":true,"path":"2014/11/17/spring security的原理及教程/","link":"","permalink":"https://hui46226021.github.io/2014/11/17/spring security的原理及教程/","excerpt":"","text":"原文地址：http://www.2cto.com/kf/201408/329607.html#0-tsina-1-20953-397232819ff9a47a7b7e80a40613cfe1","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://hui46226021.github.io/categories/JAVA/"},{"name":"spring","slug":"JAVA/spring","permalink":"https://hui46226021.github.io/categories/JAVA/spring/"}],"tags":[{"name":"spring","slug":"spring","permalink":"https://hui46226021.github.io/tags/spring/"},{"name":"权限","slug":"权限","permalink":"https://hui46226021.github.io/tags/权限/"},{"name":"后端开发","slug":"后端开发","permalink":"https://hui46226021.github.io/tags/后端开发/"}]},{"title":"JAVA Web缓存","slug":"JAVA Web缓存","date":"2014-11-12T10:37:23.000Z","updated":"2017-09-29T15:00:07.191Z","comments":true,"path":"2014/11/12/JAVA Web缓存/","link":"","permalink":"https://hui46226021.github.io/2014/11/12/JAVA Web缓存/","excerpt":"摘要:去年整理过关于JAVA web的一些缓冲知识 今天无疑见翻出这篇笔记 怕以后弄丢了 就在这里记录下吧","text":"摘要:去年整理过关于JAVA web的一些缓冲知识 今天无疑见翻出这篇笔记 怕以后弄丢了 就在这里记录下吧 JAVA缓存最简单一种实现创建一个静态的map ConcurrentHashMap 线程安全 本地文件缓存Ehcache 缓存jar包ehcache-core-2.5.2.jar slf4j-api-1.6.1.jar slf4j-jdk14-1.6.1.jar 配置 ehcache.xml可配置多个cache通过 Cache sample = cacheManager.getCache(“name”);获取缓存对象 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;ehcache xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:noNamespaceSchemaLocation=\"../bin/ehcache.xsd\"&gt; &lt;!-- name：Cache的唯一标识 maxElementsInMemory：内存中最大缓存对象数 maxElementsOnDisk：磁盘中最大缓存对象数，若是0表示无穷大 eternal：Element是否永久有效，一但设置了，timeout将不起作用 overflowToDisk：配置此属性，当内存中Element数量达到maxElementsInMemory时，Ehcache将会Element写到磁盘中 timeToIdleSeconds：设置Element在失效前的允许闲置时间。仅当element不是永久有效时使用，可选属性，默认值是0，也就是可闲置时间无穷大 11. timeToLiveSeconds：设置Element在失效前允许存活时间。最大时间介于创建时间和失效时间之间。仅当element不是永久有效时使用，默认是0.，也就是element存活时间无穷大 diskPersistent ： 是否持久化磁盘缓存。当这个属性的值为true时，系统在初始化的时候会在磁盘中查找文件名为cache名称，后缀名为index的的文件 diskExpiryThreadIntervalSeconds：磁盘失效线程运行时间间隔，默认是120秒 diskSpoolBufferSizeMB：这个参数设置DiskStore（磁盘缓存）的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区 memoryStoreEvictionPolicy：当达到maxElementsInMemory限制时，Ehcache将会根据指定的策略去清理内存。默认策略是LRU（最近最少使用）。你可以设置为FIFO（先进先出）或是LFU（较少使用） --&gt; &lt;defaultCache overflowToDisk=\"true\" eternal=\"false\"/&gt; &lt;diskStore path=\"D:/cache\" /&gt; &lt;!-- &lt;cache name=\"zzugxy\" overflowToDisk=\"true\" eternal=\"false\" timeToIdleSeconds=\"300\" timeToLiveSeconds=\"600\" maxElementsInMemory=\"1000\" &gt; maxElementsOnDisk=\"10\" diskPersistent=\"true\" diskExpiryThreadIntervalSeconds=\"300\" diskSpoolBufferSizeMB=\"100\" memoryStoreEvictionPolicy=\"LRU\" /&gt; --&gt; &lt;/ehcache&gt; JAVA 代码 1.获取CacheManager 对象 不传参数表示默认路径 可以传入文件路径和网络地址 2.CacheManager cacheManager = CacheManager.create(); 获取ehcache.xml 文件里配置好的 cache Cache sample = cacheManager.getCache(“SimplePageCachingFilter”); 3.创建 缓存元素 key 和 val 字面意思 Element element = new Element(“key”, “val”); 4.sample.put(element); 将缓存对象 加入缓存 通过key获取cache中的 缓存元素 Element result = sample.get(“key”); 注意添加到cache中对象要序列化 实现Serializable接口 通过 次元素 可获取 val等 属性的值 删除缓存 sample.remove(“key”); sample.removeAll(); 获取所有的缓存对象 for (Object key : cache.getKeys()) { System.out.println(key); } 得到缓存中的对象数 cache.getSize(); 得到缓存对象占用内存的大小 cache.getMemoryStoreSize(); 得到缓存读取的命中次数 cache.getStatistics().getCacheHits(); 得到缓存读取的错失次数 cache.getStatistics().getCacheMisses(); 写入磁盘 cache.flush(); 要想把cache真正持久化到磁盘，写程序时必须注意，在是用net.sf.ehcache.Cache的void put (Element element)方法后要使用void flush()方法 创建个缓存123Ehcache cache = new Cache(\"testCache\", 5000, false, false, 5, 2);sample.add(cache ) Ehcache整合MyBatis导入 mybatis-ehcache-1.0.0.jar 还有其他myBatis相关包1234567891011&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt; &lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; &lt;mapper namespace=\"com.qiuqiu.dao.PersonDao\"&gt; &lt;!-- 以下两个&lt;cache&gt;标签二选一,第一个可以输出日志,第二个不输出日志 --&gt; &lt;cache type=\"org.mybatis.caches.ehcache.LoggingEhcache\"/&gt; &lt;!-- &lt;cache type=\"org.mybatis.caches.ehcache.EhcacheCache\"/&gt; --&gt; &lt;select id=\"selectUserById\" parameterType=\"int\" resultType=\"org.qiuqiu.vo.Person\"&gt; select * from person where id=#&#123;id&#125; &lt;/select&gt; &lt;/mapper&gt; 通过注释的方式 整合 1@CacheNamespace(implementation=org.mybatis.caches.ehcache.EhcacheCache.class) EhcacheCache 实现了 mybatis的 Cache接口 默认获取根目录下的ehcache.xml文件 如果 之前在ehcache.xml 没有配置过 相应的cache 这里会根据 id创建一个cache id= Dao的地址 在ehcache.xml配置 cache麻烦的话 可以 自定义类 继承EhcacheCache 重写 获取cache 将@CacheNamespace 注解里面的参数传进去 自定义 cache Ehcache页面缓存jar包 12345&lt;dependency&gt; &lt;groupId&gt;net.sf.ehcache&lt;/groupId&gt; &lt;artifactId&gt;ehcache-web&lt;/artifactId&gt; &lt;version&gt;2.0.4&lt;/version&gt;&lt;/dependency&gt; 页面缓存主要用Filter过滤器对请求的url进行过滤，如果该url在缓存中出现。那么页面数据就从缓存对象中获取，并以gzip压缩后返回。其速度是没有压缩缓存时速度的3-5倍，效率相当之高！其中页面缓存的过滤器有CachingFilter，一般要扩展filter或是自定义Filter都继承该CachingFilter 自定义类 继承 SimplePageCachingFilter 重写 doFilter 方法 在里面先判断 是否是要缓存的地址 如果是就调用super.doFilter(request, response, chain); 如果不是就调用chain.doFilter(request, response); SimplePageCachingFilter里面默认获取 名字SimplePageCachingFilter 的 cache配置 重写 getCacheName方法 设置 cache名字 默认 key :1stringBuffer.append(httpRequest.getMethod()).append(httpRequest.getRequestURI()).append(httpRequest.getQueryString()) 可以重写 SimplePageCachingFilter 的 calculateKey() 方法 自己定义key Ehcache Spring 整合123456789101112&lt;bean id=\"defaultCacheManager\" class=\"org.springframework.cache.ehcache.EhCacheManagerFactoryBean\"&gt; &lt;property name=\"configLocation\" value=\"classpath:ehcache.xml\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"cacheManager\" class=\"org.springframework.cache.ehcache.EhCacheCacheManager\"&gt; &lt;property name=\"cacheManager\"&gt; &lt;ref local=\"defaultCacheManager\"/&gt; &lt;/property&gt; &lt;/bean&gt; &lt;cache:annotation-driven cache-manager=\"cacheManager\"/&gt; 在类或方法上@Cacheable @Cacheable(value=”cache”) 这个注释的意思是，当调用这个方法的时候，会从一个名叫 cache的缓存中查询，如果没有，则执行实际的方法（即查询数据库），并将执行的结果存入缓存中，否则返回缓存中的对象。 同时 还有@CacheEvict @CachePut 等注解 详解http://wenku.baidu.com/link?url=g5ptu1e1vHrJ2FePys7a9ILMhoI_JkX4-3vX9Ir3VfSiTGuE6eOqEx-DuWGMZBWoIa9zKQ9RmM4eiJw86Q_uXx7U1Ux75X2odvUGxqL8JaW 远程缓存Memcachedjava memcached clientjar包 commons-pool-1.5.6.jar java_memcached-release_2.6.6.jar slf4j-api-1.6.1.jar slf4j-simple-1.6.1.jar 主要是两个类 SockIOPool 和 MemCachedClient SockIOPool 这个类用来创建管理客户端和服务器通讯连接池 MemCachedClient 缓存的管理 set方法 gei 方法 等 memcached 缓存对象 需要 实现序列化 set方法 gei 方法 等 注：设置有效时间为5秒是 new Date(5000) 不是 new Date(System.currentTimeMillis()+5000) 神逻辑 更多API http://wenku.baidu.com/link?url=vxMR6BGKj7_8RHMN9H_trAV4p4NVPfVjxSl08uQcL8eooRTk7g1PQVmiqcKP4MQPr5Hm3NsIlEHqdFcPFroddtzHaOliasg5I2MYGjz0XiC java memcached client 整合spring1234567891011121314151617181920212223242526272829303132&lt;bean id=\"sockIOPool\" class=\"com.danga.MemCached.SockIOPool\" factory-method=\"getInstance\" init-method=\"initialize\" destroy-method=\"shutDown\"&gt; &lt;constructor-arg&gt; &lt;value&gt;neeaMemcachedPool&lt;/value&gt; &lt;/constructor-arg&gt; &lt;property name=\"servers\"&gt; &lt;list&gt; &lt;value&gt;127.1.0.1:11211&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;property name=\"initConn\"&gt; &lt;value&gt;10&lt;/value&gt; &lt;/property&gt; &lt;property name=\"maxConn\"&gt; &lt;value&gt;250&lt;/value&gt; &lt;/property&gt; &lt;property name=\"maintSleep\"&gt; &lt;value&gt;30&lt;/value&gt; &lt;/property&gt; &lt;property name=\"nagle\"&gt; &lt;value&gt;false&lt;/value&gt; &lt;/property&gt; &lt;property name=\"socketTO\"&gt; &lt;value&gt;3000&lt;/value&gt; &lt;/property&gt;&lt;/bean&gt; &lt;bean id=\"memcachedClient\" class=\"com.danga.MemCached.MemCachedClient\"&gt; &lt;constructor-arg&gt; &lt;value&gt;neeaMemcachedPool&lt;/value&gt; &lt;/constructor-arg&gt; &lt;/bean&gt; 参考 Ehcache 整合 Spring org.springframework.cache.ehcache.EhCacheCacheManager 重org.springframework.cache.Cache和 org.springframework.cache.support.AbstractCacheManager 1234567&lt;bean id=\"cacheManager\" class=\"com.dingxin.kunyu.cache.MemcachedCacheManager\"&gt; &lt;property name=\"memcachedClient\"&gt; &lt;ref bean=\"memcachedClient\"/&gt; &lt;/property&gt;&lt;/bean&gt;&lt;cache:annotation-driven cache-manager=\"cacheManager\"/&gt;mybatis和memcached的整合 mybatis和memcached的整合JAR 包12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt; &lt;artifactId&gt;mybatis-memcached&lt;/artifactId&gt; &lt;version&gt;1.0.0&lt;/version&gt; &lt;/dependency&gt; 1&lt;mapper namespace=\"org.acme.FooMapper\"&gt; &lt;cache type=\"org.mybatis.caches.memcached.MemcachedCache\" /&gt; 打印日志1&lt;cache type=\"org.mybatis.caches.memcached.LoggingMemcachedCache\" /&gt; ...&lt;/mapper&gt; memcache的配置是根据classpath下的 /memcached.properties 配置的，如果没有使用默 还可以实现 mybatis的 Cache接口 进行整合 使用Simple-Spring-Memcached注解做缓存操作 针对xmemcached 客户端 1234567891011&lt;dependency&gt; &lt;groupId&gt;com.google.code.simple-spring-memcached&lt;/groupId&gt; &lt;artifactId&gt;xmemcached-provider&lt;/artifactId&gt; &lt;version&gt;3.6.0&lt;/version&gt;&lt;/dependency&gt; &lt;!--spymemcached客户端 --&gt;&lt;dependency&gt; &lt;groupId&gt;com.google.code.simple-spring-memcached&lt;/groupId&gt; &lt;artifactId&gt;spymemcached-provider&lt;/artifactId&gt; &lt;version&gt;3.6.0&lt;/version&gt;&lt;/dependency&gt; Spring 配置 12&lt;import resource=\"simplesm-context.xml\" /&gt;&lt;aop:aspectj-autoproxy /&gt; http://https://code.google.com/p/simple-spring-memcached/wiki/Getting_Started#@CacheKeyMethod 这里面有针对不同客户端的spring配置 simplesm-context.xml 在simple-spring-memcached-3.4.0.jar 包里 在方法上 使用 @ReadThroughSingleCache 两个参数 namespace key前缀 expiration到期时间 在参数上@ParameterValueKeyProvider 生成key 多个参数时候 需要指定 order 值 注 参数不能带空格 或者空的 会报错 @InvalidateSingleCache 作用：失效Cache中的数据 @UpdateSingleCache 作用：更新Cache中的数据 等等 @CacheKeyMethod 标记做为参数 的对象方法上 调用该方法生产key 不包含此注解则调用 toString方法 xmemcached 客户端 Jar 包 12345&lt;dependency&gt; &lt;groupId&gt;com.googlecode.xmemcached&lt;/groupId&gt; &lt;artifactId&gt;xmemcached&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt;&lt;/dependency&gt; 1234567891011121314151617181920212223242526MemcachedClientBuilder builder = new XMemcachedClientBuilder( AddrUtil.getAddresses(\"127.1.0.1:11211\"), new int[] &#123; 1, 1, 1, 1 &#125; //设置连接池大小，即客户端个数 builder.setConnectionPoolSize(50); //宕机报警 builder.setFailureMode(true); //使用二进制文件 builder.setCommandFactory(new BinaryCommandFactory()); MemcachedClient memcachedClient = null; try &#123; memcachedClient = builder.build(); try &#123; memcachedClient.set(\"zlex\", 36000, \"set/get\"); memcachedClient.get(\"zlex\",); &#125; catch (TimeoutException e) &#123; e.printStackTrace(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (MemcachedException e) &#123; e.printStackTrace(); &#125; &#125; catch (IOException e) &#123; e.printStackTrace();&#125; API http://www.tuicool.com/articles/qMnQVfe Redis1&lt;dependency&gt; &lt;groupId&gt;redis.clients&lt;/groupId&gt; &lt;artifactId&gt;jedis&lt;/artifactId&gt; &lt;version&gt;2.0.0&lt;/version&gt; &lt;/dependency&gt; Jedis客户端连接池配置 12345678//连接池配置 JedisPoolConfig config = new JedisPoolConfig(); config.setMaxTotal(10); config.setMaxIdle(50);//设置最大空闲数 config.setBlockWhenExhausted(false); config.setMaxWaitMillis(timeout);//设置超时时间 config.setMinEvictableIdleTimeMillis(30000); 更多参数 详解 http://shift-alt-ctrl.iteye.com/blog/1885910 1234567891011121314151617181920//获得连接池JedisPool pool == new JedisPool(config, host, port, timeout)//jedisPool对象 可以通过spring 进行封装//获得JedisJedis client = jedisPool.getResource(); try&#123; client.set(\"k1\", \"v1\"); client.expire(\"k1\", time) //设置有效时间 client.get(\"k1\"); //获取值 client.del(\"k1\"); //删除值 &#125;catch(Exception e)&#123; e.printStackTrace(); &#125;finally&#123; jedisPool.returnResource(client); //必须 释放对象池 &#125; 更多API http://tool.oschina.net/uploads/apidocs/ Redis的key和value都支持二进制安全的字符串 保存对象 需要 序列化对象 序列化工具 123456789101112131415161718192021222324252627282930public class SerializeUtil &#123; public static byte[] serialize(Object object) &#123; ObjectOutputStream oos = null; ByteArrayOutputStream baos = null; try &#123; //序列化 baos = new ByteArrayOutputStream(); oos = new ObjectOutputStream(baos); oos.writeObject(object); byte[] bytes = baos.toByteArray(); return bytes; &#125; catch (Exception e) &#123; &#125; return null; &#125; public static Object unserialize(byte[] bytes) &#123; ByteArrayInputStream bais = null; try &#123; //反序列化 bais = new ByteArrayInputStream(bytes); ObjectInputStream ois = new ObjectInputStream(bais); return ois.readObject(); &#125; catch (Exception e) &#123; &#125; return null; &#125;&#125; Spring Data Redis在Jedis的基础上，提供了对Redis访问的进一步封装。使用SDR，不在需要手动维护连接的建立、释放，对对象序列化提供了默认实现 SDR依赖的的是Spring的高版本3.x12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.data&lt;/groupId&gt; &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt; &lt;version&gt;1.5.2.RELEASE&lt;/version&gt;&lt;/dependency&gt; Spring 配置 123456789101112131415161718&lt;!--定义连接工厂--&gt;&lt;bean id = \"jedisConnectionFactory\" class=\"org.springframework.data.redis.connection.jedis.JedisConnectionFactory\"&gt; &lt;constructor-arg index=\"0\" ref=\"jedisPoolConfig\"/&gt; &lt;property name=\"hostName\" value=\"$&#123;redis.host&#125;\"/&gt; &lt;property name=\"port\" value=\"$&#123;redis.port&#125;\"/&gt; &lt;property name=\"timeout\" value=\"$&#123;redis.timeout&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;redis.password&#125;\"/&gt; &lt;/bean&gt;&lt;!--定义redisTemplate：提供了对Jedis进行的通用API操作。--&gt;&lt;bean id = \"redisTemplate\" class=\"org.springframework.data.redis.core.RedisTemplate\"&gt; &lt;property name=\"connectionFactory\" ref=\"jedisConnectionFactory\"/&gt; &lt;property name=\"keySerializer\"&gt; &lt;bean class=\"org.springframework.data.redis.serializer.StringRedisSerializer\"&gt;&lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; SDR默认采用JDK的序列化机制 使用JdkSerializationRedisSerializer类，进行对象和byte[]之间的相互转换，就像上面的序列化代码 这里是设置 keySerializer 为StringRedisSerializer 所以使用字符串形式的key123redisTemplate.opsForValue().set(key, value);redisTemplate.opsForValue().get(key);redisTemplate.delete(key); 更多apihttp://docs.spring.io/spring-data/redis/docs/1.0.x/api/org/springframework/data/redis/core/RedisTemplate.html Redis 整合 MyBatis自定义类 继承myBatis 的cache接口 http://www.tuicool.com/articles/j2AzA3","categories":[{"name":"JAVA","slug":"JAVA","permalink":"https://hui46226021.github.io/categories/JAVA/"},{"name":"Web","slug":"JAVA/Web","permalink":"https://hui46226021.github.io/categories/JAVA/Web/"},{"name":"Cache","slug":"JAVA/Web/Cache","permalink":"https://hui46226021.github.io/categories/JAVA/Web/Cache/"},{"name":"Ehcache","slug":"JAVA/Web/Cache/Ehcache","permalink":"https://hui46226021.github.io/categories/JAVA/Web/Cache/Ehcache/"},{"name":"Memcached","slug":"JAVA/Web/Cache/Ehcache/Memcached","permalink":"https://hui46226021.github.io/categories/JAVA/Web/Cache/Ehcache/Memcached/"},{"name":"Redis","slug":"JAVA/Web/Cache/Ehcache/Memcached/Redis","permalink":"https://hui46226021.github.io/categories/JAVA/Web/Cache/Ehcache/Memcached/Redis/"}],"tags":[{"name":"原创","slug":"原创","permalink":"https://hui46226021.github.io/tags/原创/"},{"name":"JAVA Web缓存","slug":"JAVA-Web缓存","permalink":"https://hui46226021.github.io/tags/JAVA-Web缓存/"},{"name":"服务器开发","slug":"服务器开发","permalink":"https://hui46226021.github.io/tags/服务器开发/"}]},{"title":"安装ubuntu 配置环境","slug":"安装ubuntu 配置环境","date":"2014-10-12T05:21:35.000Z","updated":"2017-03-19T05:03:25.147Z","comments":true,"path":"2014/10/12/安装ubuntu 配置环境/","link":"","permalink":"https://hui46226021.github.io/2014/10/12/安装ubuntu 配置环境/","excerpt":"摘要:记录","text":"摘要:记录 1.sudo apt-get update 2.安装chrome 在（百度云） 3.安装 flash sudo apt-get install flashplugin-installer 4.安装sougo输入法 （百度云） 5.安装JDK 官网下载 解压到 /use/lib/jva 目录 名字改为java 6.配置jdk环境变量：gedit /etc/profile #set jdk environmentexport JAVA_HOME=/usr/lib/jvm/jdk1.7.0_21export CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/jre/lib:$CLASSPATHexport PATH=$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATH source /etc/profile查看配置是否成功。 java -version 如果显示仍是openJDK， 配置默认JDK，ubuntu下默认JDK是openJDK。。终端输入sudo update-alternatives –install /usr/lib/java java /usr/lib/jvm/java/bin/java 300sudo update-alternatives –install /usr/lib/javac javac /usr/lib/java/bin/javac 300 sudo update-alternatives –config java会列出jdk版本，其中被“*”标注的为默认JDK。如果要维持当前默认JDK，直接按回车键即可；否则输入相应JDK的编号将其设置为默认版本。 7.安装32位库sudo apt-get install lib32z1 lib32ncurses5 lib32bz2-1.0 lib32stdc++6 8.安装 android studio 中文社区 下载（快他妈安装100遍了）、 9.装QQ ubuntu麒麟官网 下载","categories":[{"name":"Linux","slug":"Linux","permalink":"https://hui46226021.github.io/categories/Linux/"},{"name":"ubuntu","slug":"Linux/ubuntu","permalink":"https://hui46226021.github.io/categories/Linux/ubuntu/"}],"tags":[{"name":"原创","slug":"原创","permalink":"https://hui46226021.github.io/tags/原创/"},{"name":"操作系统","slug":"操作系统","permalink":"https://hui46226021.github.io/tags/操作系统/"},{"name":"ubuntu","slug":"ubuntu","permalink":"https://hui46226021.github.io/tags/ubuntu/"}]}]}